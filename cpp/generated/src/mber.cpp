//
// mber.cpp
//
// This file is generated. Do not edit.
//
// Implementation of the C++ Mber API using the Mber REST interface.
//
// Copyright (c) 2012-2013, FirePub, Inc. All Rights Reserved.
//

#include "mber.h"
#include "PocoSessionWrapper.h"

#include "Poco/Net/HTTPSessionInstantiator.h"
#include "Poco/Net/HTTPClientSession.h"
#include "Poco/Net/HTTPRequest.h"
#include "Poco/Net/HTTPResponse.h"
#include "Poco/StreamCopier.h"
#include "Poco/UUIDGenerator.h"
#include "Poco/UUID.h"
#include "Poco/Base64Encoder.h"
#include "Poco/Base64Decoder.h"
#include "Poco/JSON/Object.h"
#include "Poco/JSON/Parser.h"
#include "Poco/JSON/Query.h"
#include "Poco/JSON/JSONException.h"
#include "Poco/JSON/Stringifier.h"
#include "Poco/JSON/ParseHandler.h"
#include "Poco/JSON/Template.h"
#include "Poco/URI.h"

#include <sstream>
#include <stdexcept>

using namespace Poco;
using namespace Poco::Net;
using namespace Poco::JSON;
using namespace Poco::Dynamic;

namespace Mber{
  Mber::MberSession::MberSession() :
    m_uri(),
    m_token(),
    m_refreshToken(),
    m_profileId(),
    m_accountId(),
    m_lastError(),
    m_displayName(),
    m_ownedEntities(0),
    m_loggedIn(false)
  {
  };

  Mber::MberSession::MberSession(const char* const uri) :
    m_uri(uri),
    m_token(),
    m_refreshToken(),
    m_profileId(),
    m_accountId(),
    m_lastError(),
    m_displayName(),
    m_ownedEntities(0),
    m_loggedIn(false)
  {
  };

  Mber::MberSession::~MberSession()
  {
    EntityPointerList_FreeAll(m_ownedEntities);
  }

  void Mber::MberSession::setOwnedEntities(MBER_ENTITY_POINTER_LIST* entities) {
    EntityPointerList_FreeAll(m_ownedEntities);
    m_ownedEntities = entities;
  }

  const MBER_ENTITY_POINTER_LIST* const Mber::MberSession::getOwnedEntities() const {
    return m_ownedEntities;
  }

  const char* const Mber::MberSession::getLastError() const {
    return m_lastError.c_str();
  }

  void Mber::MberSession::setLastError(const std::string& error) {
    m_lastError = error;
  }

  const char* const Mber::MberSession::getDisplayName() const {
    return m_displayName.c_str();
  }

  void Mber::MberSession::setDisplayName(const std::string& name) {
    m_displayName = name;
  }

  void Mber::MberSession::setToken(const std::string& token)
  {
    m_token = token;
  }

  std::string* Mber::MberSession::getToken(){
    if(m_loggedIn){
      return &m_token;
    } else {
      return NULL;
    }
  };

  const char* const Mber::MberSession::getRefreshToken() const
  {
    if (m_loggedIn && !m_refreshToken.empty()) {
      return m_refreshToken.c_str();
    }
    return NULL;
  };

  const char* const Mber::MberSession::getURI() const
  {
    if (!m_uri.empty()) {
      return m_uri.c_str();
    }
    return NULL;
  }

  void Mber::MberSession::setLoggedIn(bool flag)
  {
    m_loggedIn = flag;
  }

  void Mber::MberSession::setProfileId(const std::string& id)
  {
    m_profileId = id;
  }

    std::string* Mber::MberSession::getProfileId(){
        if(m_loggedIn){
            return &m_profileId;
        } else {
            return NULL;
        }
    };

    void Mber::MberSession::setAccountId(const std::string& id)
    {
      m_accountId = id;
    }

    const char* const Mber::MberSession::getAccountId() const
    {
        if(m_loggedIn){
            return m_accountId.c_str();
        } else {
            return NULL;
        }
    };

    Mber::Status Mber::MberSession::login( Mber::oauth::AccessToken::Create::Request req ){
        MberPtr<Mber::oauth::AccessToken::Create::Response> rsp = req.execute(m_uri, NULL, NULL, NULL);
        if (rsp.isNull()) {
            return Mber::Status_Failed;
        }
        if (rsp->status == Mber::Status_Success) {
            m_token = *rsp->access_token;
            m_refreshToken = *rsp->refresh_token;
            m_profileId = *rsp->profileId;
            m_accountId = *rsp->accountId;
            m_displayName = *rsp->displayname;
            m_loggedIn = true;
        }
        setLastError(rsp->errorMessage);
        return rsp->status;
    };

    std::string base64Encode(const std::string& data)
    {
      std::ostringstream output;
      Base64Encoder encoder(output);
      encoder << data;
      encoder.close();
      std::string result = output.str();
      result.erase(std::remove(result.begin(), result.end(), '\r'), result.end());
      result.erase(std::remove(result.begin(), result.end(), '\n'), result.end());
      return result;
    }

    std::string generateTransactionId(){
        char buffer[16];
        UUID uuid = UUIDGenerator().createOne();
        uuid.copyTo(buffer);
        return base64Encode(std::string(buffer, 16));
    };

    std::string base64Encode( const char* buffer, int size ){
        return base64Encode(std::string(buffer, size));
    };

    std::string base64Decode( std::string buffer ){
		std::istringstream stream(buffer);
		Base64Decoder decoder(stream);
        int next = decoder.get();
        std::string result;
        while (next != -1) { result += char(next); next = decoder.get(); }
        return result;
    };
    
    std::string intToString(int val){
        std::ostringstream stream;
        stream << val;
        return stream.str();
    }

    std::string longToString(long val){
        std::ostringstream stream;
        stream << val;
        return stream.str();
    }

    std::string uint64ToString(uint64_t val){
        std::ostringstream stream;
        stream << val;
        return stream.str();
    }

    std::string doubleToString(double val){
        std::ostringstream stream;
        stream << val;
        return stream.str();
    }

    std::string boolToString(bool val){
        if(val){ return "true"; }else{ return "false"; }
    }

    std::string stringToString(std::string val){ return val; }

    
    EntityType stringToEntityType(const std::string& val){
      if (val == "Account") {
        return EntityType_Account;
      }
      if (val == "Profile") {
        return EntityType_Profile;
      }
      if (val == "Application") {
        return EntityType_Application;
      }
      if (val == "Group") {
        return EntityType_Group;
      }
      if (val == "Tag") {
        return EntityType_Tag;
      }
      if (val == "Document") {
        return EntityType_Document;
      }
      if (val == "Any") {
        return EntityType_Any;
      }
      if (val == "Token") {
        return EntityType_Token;
      }
      if (val == "Entitlement") {
        return EntityType_Entitlement;
      }
      if (val == "Role") {
        return EntityType_Role;
      }
      if (val == "Achievement") {
        return EntityType_Achievement;
      }
      if (val == "Metrics") {
        return EntityType_Metrics;
      }
      if (val == "Offer") {
        return EntityType_Offer;
      }
      if (val == "RealCurrency") {
        return EntityType_RealCurrency;
      }
      if (val == "Store") {
        return EntityType_Store;
      }
      if (val == "DigitalGood") {
        return EntityType_DigitalGood;
      }
      if (val == "Cart") {
        return EntityType_Cart;
      }
      if (val == "Invoice") {
        return EntityType_Invoice;
      }
      if (val == "Server") {
        return EntityType_Server;
      }
      if (val == "Email") {
        return EntityType_Email;
      }
      if (val == "Lobby") {
        return EntityType_Lobby;
      }
      if (val == "VirtualCurrency") {
        return EntityType_VirtualCurrency;
      }
      if (val == "WalletLot") {
        return EntityType_WalletLot;
      }
      if (val == "DocumentTemplate") {
        return EntityType_DocumentTemplate;
      }
      if (val == "Catalog") {
        return EntityType_Catalog;
      }
      if (val == "AchievementInstance") {
        return EntityType_AchievementInstance;
      }
      if (val == "DigitalGoodInstance") {
        return EntityType_DigitalGoodInstance;
      }
      if (val == "Directory") {
        return EntityType_Directory;
      }
      if (val == "DocumentLink") {
        return EntityType_DocumentLink;
      }
      if (val == "DirectoryLink") {
        return EntityType_DirectoryLink;
      }
      if (val == "BuildProject") {
        return EntityType_BuildProject;
      }
      if (val == "Build") {
        return EntityType_Build;
      }
      if (val == "ProfileGroup") {
        return EntityType_ProfileGroup;
      }
      if (val == "PaymentProvider") {
        return EntityType_PaymentProvider;
      }
      if (val == "SteamApplication") {
        return EntityType_SteamApplication;
      }
      if (val == "Affiliate") {
        return EntityType_Affiliate;
      }
      if (val == "Campaign") {
        return EntityType_Campaign;
      }
      if (val == "Persona") {
        return EntityType_Persona;
      }
      if (val == "CDNConfig") {
        return EntityType_CDNConfig;
      }
      throw std::invalid_argument(val);
    }
    
    EventType stringToEventType(const std::string& val){
      if (val == "CREATE") {
        return EventType_CREATE;
      }
      if (val == "READ") {
        return EventType_READ;
      }
      if (val == "UPDATE") {
        return EventType_UPDATE;
      }
      if (val == "DELETE") {
        return EventType_DELETE;
      }
      if (val == "DISABLE") {
        return EventType_DISABLE;
      }
      if (val == "ENABLE") {
        return EventType_ENABLE;
      }
      if (val == "START") {
        return EventType_START;
      }
      if (val == "STOP") {
        return EventType_STOP;
      }
      if (val == "PAUSE") {
        return EventType_PAUSE;
      }
      throw std::invalid_argument(val);
    }
    
    MetricType stringToMetricType(const std::string& val){
      if (val == "String") {
        return MetricType_String;
      }
      if (val == "Int") {
        return MetricType_Int;
      }
      if (val == "Long") {
        return MetricType_Long;
      }
      if (val == "Boolean") {
        return MetricType_Boolean;
      }
      if (val == "Double") {
        return MetricType_Double;
      }
      if (val == "StringArray") {
        return MetricType_StringArray;
      }
      if (val == "CompositeData") {
        return MetricType_CompositeData;
      }
      if (val == "TabularData") {
        return MetricType_TabularData;
      }
      throw std::invalid_argument(val);
    }
    
    PermissionType stringToPermissionType(const std::string& val){
      if (val == "Create") {
        return PermissionType_Create;
      }
      if (val == "Read") {
        return PermissionType_Read;
      }
      if (val == "Update") {
        return PermissionType_Update;
      }
      if (val == "Delete") {
        return PermissionType_Delete;
      }
      if (val == "Assign") {
        return PermissionType_Assign;
      }
      if (val == "History") {
        return PermissionType_History;
      }
      throw std::invalid_argument(val);
    }
    
    Status stringToStatus(const std::string& val){
      if (val == "Success") {
        return Status_Success;
      }
      if (val == "NotAuthorized") {
        return Status_NotAuthorized;
      }
      if (val == "TransactionAlreadyApplied") {
        return Status_TransactionAlreadyApplied;
      }
      if (val == "DuplicateTransactionId") {
        return Status_DuplicateTransactionId;
      }
      if (val == "Failed") {
        return Status_Failed;
      }
      if (val == "Duplicate") {
        return Status_Duplicate;
      }
      if (val == "NotFound") {
        return Status_NotFound;
      }
      if (val == "WrongEntityVersion") {
        return Status_WrongEntityVersion;
      }
      if (val == "NotAllowed") {
        return Status_NotAllowed;
      }
      if (val == "PasswordReset") {
        return Status_PasswordReset;
      }
      throw std::invalid_argument(val);
    }
    
    TokenType stringToTokenType(const std::string& val){
      if (val == "Access") {
        return TokenType_Access;
      }
      if (val == "Refresh") {
        return TokenType_Refresh;
      }
      if (val == "Authorization") {
        return TokenType_Authorization;
      }
      if (val == "EmailValidation") {
        return TokenType_EmailValidation;
      }
      if (val == "PasswordReset") {
        return TokenType_PasswordReset;
      }
      if (val == "SingleUse") {
        return TokenType_SingleUse;
      }
      if (val == "ForgotPassword") {
        return TokenType_ForgotPassword;
      }
      if (val == "Client") {
        return TokenType_Client;
      }
      throw std::invalid_argument(val);
    }
    
    AccessTokenType stringToAccessTokenType(const std::string& val){
      if (val == "Bearer") {
        return AccessTokenType_Bearer;
      }
      throw std::invalid_argument(val);
    }
    
    AccountStatus stringToAccountStatus(const std::string& val){
      if (val == "Activated") {
        return AccountStatus_Activated;
      }
      throw std::invalid_argument(val);
    }
    
    ApplicationStatus stringToApplicationStatus(const std::string& val){
      if (val == "Activated") {
        return ApplicationStatus_Activated;
      }
      if (val == "Disabled") {
        return ApplicationStatus_Disabled;
      }
      if (val == "Deleted") {
        return ApplicationStatus_Deleted;
      }
      throw std::invalid_argument(val);
    }
    
    OauthError stringToOauthError(const std::string& val){
      if (val == "invalid_request") {
        return OauthError_invalid_request;
      }
      if (val == "invalid_client") {
        return OauthError_invalid_client;
      }
      if (val == "invalid_grant") {
        return OauthError_invalid_grant;
      }
      if (val == "unauthorized_client") {
        return OauthError_unauthorized_client;
      }
      if (val == "unsupported_grant_type") {
        return OauthError_unsupported_grant_type;
      }
      if (val == "invalid_scope") {
        return OauthError_invalid_scope;
      }
      throw std::invalid_argument(val);
    }
    
    PermissionFlags stringToPermissionFlags(const std::string& val){
      if (val == "SelfOnly") {
        return PermissionFlags_SelfOnly;
      }
      if (val == "AllowPrivate") {
        return PermissionFlags_AllowPrivate;
      }
      throw std::invalid_argument(val);
    }
    
    ProfileAddressType stringToProfileAddressType(const std::string& val){
      if (val == "Shipping") {
        return ProfileAddressType_Shipping;
      }
      throw std::invalid_argument(val);
    }
    
    ProfileGroupStatus stringToProfileGroupStatus(const std::string& val){
      if (val == "Active") {
        return ProfileGroupStatus_Active;
      }
      if (val == "Disabled") {
        return ProfileGroupStatus_Disabled;
      }
      if (val == "System") {
        return ProfileGroupStatus_System;
      }
      throw std::invalid_argument(val);
    }
    
    ProfileStatus stringToProfileStatus(const std::string& val){
      if (val == "Activated") {
        return ProfileStatus_Activated;
      }
      if (val == "Disabled") {
        return ProfileStatus_Disabled;
      }
      if (val == "Deleted") {
        return ProfileStatus_Deleted;
      }
      if (val == "EmailValidationPending") {
        return ProfileStatus_EmailValidationPending;
      }
      if (val == "PasswordReset") {
        return ProfileStatus_PasswordReset;
      }
      throw std::invalid_argument(val);
    }
    
    Region stringToRegion(const std::string& val){
      if (val == "Global") {
        return Region_Global;
      }
      if (val == "China") {
        return Region_China;
      }
      throw std::invalid_argument(val);
    }
    
    RoleStatus stringToRoleStatus(const std::string& val){
      if (val == "Disabled") {
        return RoleStatus_Disabled;
      }
      throw std::invalid_argument(val);
    }
    
    SteamUserStatus stringToSteamUserStatus(const std::string& val){
      if (val == "Active") {
        return SteamUserStatus_Active;
      }
      if (val == "UnlinkPending") {
        return SteamUserStatus_UnlinkPending;
      }
      throw std::invalid_argument(val);
    }
    
    DefinitionStatus stringToDefinitionStatus(const std::string& val){
      if (val == "Enabled") {
        return DefinitionStatus_Enabled;
      }
      if (val == "SelfGrant") {
        return DefinitionStatus_SelfGrant;
      }
      throw std::invalid_argument(val);
    }
    
    EntitlementPropertyAvailability stringToEntitlementPropertyAvailability(const std::string& val){
      if (val == "Unavailable") {
        return EntitlementPropertyAvailability_Unavailable;
      }
      if (val == "Optional") {
        return EntitlementPropertyAvailability_Optional;
      }
      if (val == "Required") {
        return EntitlementPropertyAvailability_Required;
      }
      throw std::invalid_argument(val);
    }
    
    EntitlementState stringToEntitlementState(const std::string& val){
      if (val == "Granted") {
        return EntitlementState_Granted;
      }
      if (val == "Claimed") {
        return EntitlementState_Claimed;
      }
      if (val == "Revoked") {
        return EntitlementState_Revoked;
      }
      throw std::invalid_argument(val);
    }
    
    EntitlementType stringToEntitlementType(const std::string& val){
      if (val == "Entitlement") {
        return EntitlementType_Entitlement;
      }
      if (val == "Achievement") {
        return EntitlementType_Achievement;
      }
      if (val == "DigitalGood") {
        return EntitlementType_DigitalGood;
      }
      throw std::invalid_argument(val);
    }
    
    KeyFormat stringToKeyFormat(const std::string& val){
      if (val == "Print") {
        return KeyFormat_Print;
      }
      if (val == "URL") {
        return KeyFormat_URL;
      }
      throw std::invalid_argument(val);
    }
    
    CDNType stringToCDNType(const std::string& val){
      if (val == "Highwinds") {
        return CDNType_Highwinds;
      }
      throw std::invalid_argument(val);
    }
    
    DataStorageLocation stringToDataStorageLocation(const std::string& val){
      if (val == "Cassandra") {
        return DataStorageLocation_Cassandra;
      }
      if (val == "S3") {
        return DataStorageLocation_S3;
      }
      if (val == "CDN") {
        return DataStorageLocation_CDN;
      }
      throw std::invalid_argument(val);
    }
    
    DocumentStatus stringToDocumentStatus(const std::string& val){
      if (val == "Incomplete") {
        return DocumentStatus_Incomplete;
      }
      if (val == "Invalid") {
        return DocumentStatus_Invalid;
      }
      if (val == "NotIndexed") {
        return DocumentStatus_NotIndexed;
      }
      if (val == "SyncPending") {
        return DocumentStatus_SyncPending;
      }
      if (val == "SyncFailed") {
        return DocumentStatus_SyncFailed;
      }
      if (val == "SyncComplete") {
        return DocumentStatus_SyncComplete;
      }
      if (val == "SyncEnabled") {
        return DocumentStatus_SyncEnabled;
      }
      throw std::invalid_argument(val);
    }
    
    TemplateFieldType stringToTemplateFieldType(const std::string& val){
      if (val == "Number") {
        return TemplateFieldType_Number;
      }
      if (val == "String") {
        return TemplateFieldType_String;
      }
      if (val == "Boolean") {
        return TemplateFieldType_Boolean;
      }
      if (val == "Object") {
        return TemplateFieldType_Object;
      }
      throw std::invalid_argument(val);
    }
    
    AppCountType stringToAppCountType(const std::string& val){
      if (val == "SELFONLY") {
        return AppCountType_SELFONLY;
      }
      if (val == "INCLUSIVE") {
        return AppCountType_INCLUSIVE;
      }
      throw std::invalid_argument(val);
    }
    
    ProfileHistoryFilter stringToProfileHistoryFilter(const std::string& val){
      if (val == "Profile") {
        return ProfileHistoryFilter_Profile;
      }
      if (val == "VirtualPurchase") {
        return ProfileHistoryFilter_VirtualPurchase;
      }
      if (val == "InvoicePurchase") {
        return ProfileHistoryFilter_InvoicePurchase;
      }
      if (val == "PasswordReset") {
        return ProfileHistoryFilter_PasswordReset;
      }
      throw std::invalid_argument(val);
    }
    
    TimeUnit stringToTimeUnit(const std::string& val){
      if (val == "SECONDS") {
        return TimeUnit_SECONDS;
      }
      if (val == "MINUTES") {
        return TimeUnit_MINUTES;
      }
      if (val == "HOURS") {
        return TimeUnit_HOURS;
      }
      if (val == "DAYS") {
        return TimeUnit_DAYS;
      }
      if (val == "MONTHS") {
        return TimeUnit_MONTHS;
      }
      if (val == "YEARS") {
        return TimeUnit_YEARS;
      }
      throw std::invalid_argument(val);
    }
    
    AffiliateStatus stringToAffiliateStatus(const std::string& val){
      if (val == "Activated") {
        return AffiliateStatus_Activated;
      }
      if (val == "Deleted") {
        return AffiliateStatus_Deleted;
      }
      throw std::invalid_argument(val);
    }
    
    CurrencyCode stringToCurrencyCode(const std::string& val){
      if (val == "AED") {
        return CurrencyCode_AED;
      }
      if (val == "AFN") {
        return CurrencyCode_AFN;
      }
      if (val == "ALL") {
        return CurrencyCode_ALL;
      }
      if (val == "AMD") {
        return CurrencyCode_AMD;
      }
      if (val == "ANG") {
        return CurrencyCode_ANG;
      }
      if (val == "AOA") {
        return CurrencyCode_AOA;
      }
      if (val == "ARS") {
        return CurrencyCode_ARS;
      }
      if (val == "AUD") {
        return CurrencyCode_AUD;
      }
      if (val == "AWG") {
        return CurrencyCode_AWG;
      }
      if (val == "AZN") {
        return CurrencyCode_AZN;
      }
      if (val == "BAM") {
        return CurrencyCode_BAM;
      }
      if (val == "BBD") {
        return CurrencyCode_BBD;
      }
      if (val == "BDT") {
        return CurrencyCode_BDT;
      }
      if (val == "BGN") {
        return CurrencyCode_BGN;
      }
      if (val == "BHD") {
        return CurrencyCode_BHD;
      }
      if (val == "BIF") {
        return CurrencyCode_BIF;
      }
      if (val == "BMD") {
        return CurrencyCode_BMD;
      }
      if (val == "BND") {
        return CurrencyCode_BND;
      }
      if (val == "BOB") {
        return CurrencyCode_BOB;
      }
      if (val == "BRL") {
        return CurrencyCode_BRL;
      }
      if (val == "BSD") {
        return CurrencyCode_BSD;
      }
      if (val == "BTN") {
        return CurrencyCode_BTN;
      }
      if (val == "BWP") {
        return CurrencyCode_BWP;
      }
      if (val == "BYR") {
        return CurrencyCode_BYR;
      }
      if (val == "BZD") {
        return CurrencyCode_BZD;
      }
      if (val == "CAD") {
        return CurrencyCode_CAD;
      }
      if (val == "CDF") {
        return CurrencyCode_CDF;
      }
      if (val == "CHF") {
        return CurrencyCode_CHF;
      }
      if (val == "CLP") {
        return CurrencyCode_CLP;
      }
      if (val == "CNY") {
        return CurrencyCode_CNY;
      }
      if (val == "COP") {
        return CurrencyCode_COP;
      }
      if (val == "CRC") {
        return CurrencyCode_CRC;
      }
      if (val == "CUC") {
        return CurrencyCode_CUC;
      }
      if (val == "CUP") {
        return CurrencyCode_CUP;
      }
      if (val == "CVE") {
        return CurrencyCode_CVE;
      }
      if (val == "CZK") {
        return CurrencyCode_CZK;
      }
      if (val == "DJF") {
        return CurrencyCode_DJF;
      }
      if (val == "DKK") {
        return CurrencyCode_DKK;
      }
      if (val == "DOP") {
        return CurrencyCode_DOP;
      }
      if (val == "DZD") {
        return CurrencyCode_DZD;
      }
      if (val == "EGP") {
        return CurrencyCode_EGP;
      }
      if (val == "ERN") {
        return CurrencyCode_ERN;
      }
      if (val == "ETB") {
        return CurrencyCode_ETB;
      }
      if (val == "EUR") {
        return CurrencyCode_EUR;
      }
      if (val == "FJD") {
        return CurrencyCode_FJD;
      }
      if (val == "FKP") {
        return CurrencyCode_FKP;
      }
      if (val == "GBP") {
        return CurrencyCode_GBP;
      }
      if (val == "GEL") {
        return CurrencyCode_GEL;
      }
      if (val == "GGP") {
        return CurrencyCode_GGP;
      }
      if (val == "GHS") {
        return CurrencyCode_GHS;
      }
      if (val == "GIP") {
        return CurrencyCode_GIP;
      }
      if (val == "GMD") {
        return CurrencyCode_GMD;
      }
      if (val == "GNF") {
        return CurrencyCode_GNF;
      }
      if (val == "GTQ") {
        return CurrencyCode_GTQ;
      }
      if (val == "GYD") {
        return CurrencyCode_GYD;
      }
      if (val == "HKD") {
        return CurrencyCode_HKD;
      }
      if (val == "HNL") {
        return CurrencyCode_HNL;
      }
      if (val == "HRK") {
        return CurrencyCode_HRK;
      }
      if (val == "HTG") {
        return CurrencyCode_HTG;
      }
      if (val == "HUF") {
        return CurrencyCode_HUF;
      }
      if (val == "IDR") {
        return CurrencyCode_IDR;
      }
      if (val == "ILS") {
        return CurrencyCode_ILS;
      }
      if (val == "IMP") {
        return CurrencyCode_IMP;
      }
      if (val == "INR") {
        return CurrencyCode_INR;
      }
      if (val == "IQD") {
        return CurrencyCode_IQD;
      }
      if (val == "IRR") {
        return CurrencyCode_IRR;
      }
      if (val == "ISK") {
        return CurrencyCode_ISK;
      }
      if (val == "JEP") {
        return CurrencyCode_JEP;
      }
      if (val == "JMD") {
        return CurrencyCode_JMD;
      }
      if (val == "JOD") {
        return CurrencyCode_JOD;
      }
      if (val == "JPY") {
        return CurrencyCode_JPY;
      }
      if (val == "KES") {
        return CurrencyCode_KES;
      }
      if (val == "KGS") {
        return CurrencyCode_KGS;
      }
      if (val == "KHR") {
        return CurrencyCode_KHR;
      }
      if (val == "KMF") {
        return CurrencyCode_KMF;
      }
      if (val == "KPW") {
        return CurrencyCode_KPW;
      }
      if (val == "KRW") {
        return CurrencyCode_KRW;
      }
      if (val == "KWD") {
        return CurrencyCode_KWD;
      }
      if (val == "KYD") {
        return CurrencyCode_KYD;
      }
      if (val == "KZT") {
        return CurrencyCode_KZT;
      }
      if (val == "LAK") {
        return CurrencyCode_LAK;
      }
      if (val == "LBP") {
        return CurrencyCode_LBP;
      }
      if (val == "LKR") {
        return CurrencyCode_LKR;
      }
      if (val == "LRD") {
        return CurrencyCode_LRD;
      }
      if (val == "LSL") {
        return CurrencyCode_LSL;
      }
      if (val == "LTL") {
        return CurrencyCode_LTL;
      }
      if (val == "LVL") {
        return CurrencyCode_LVL;
      }
      if (val == "LYD") {
        return CurrencyCode_LYD;
      }
      if (val == "MAD") {
        return CurrencyCode_MAD;
      }
      if (val == "MDL") {
        return CurrencyCode_MDL;
      }
      if (val == "MGA") {
        return CurrencyCode_MGA;
      }
      if (val == "MKD") {
        return CurrencyCode_MKD;
      }
      if (val == "MMK") {
        return CurrencyCode_MMK;
      }
      if (val == "MNT") {
        return CurrencyCode_MNT;
      }
      if (val == "MOP") {
        return CurrencyCode_MOP;
      }
      if (val == "MRO") {
        return CurrencyCode_MRO;
      }
      if (val == "MUR") {
        return CurrencyCode_MUR;
      }
      if (val == "MVR") {
        return CurrencyCode_MVR;
      }
      if (val == "MWK") {
        return CurrencyCode_MWK;
      }
      if (val == "MXN") {
        return CurrencyCode_MXN;
      }
      if (val == "MYR") {
        return CurrencyCode_MYR;
      }
      if (val == "MZN") {
        return CurrencyCode_MZN;
      }
      if (val == "NAD") {
        return CurrencyCode_NAD;
      }
      if (val == "NGN") {
        return CurrencyCode_NGN;
      }
      if (val == "NIO") {
        return CurrencyCode_NIO;
      }
      if (val == "NOK") {
        return CurrencyCode_NOK;
      }
      if (val == "NPR") {
        return CurrencyCode_NPR;
      }
      if (val == "NZD") {
        return CurrencyCode_NZD;
      }
      if (val == "OMR") {
        return CurrencyCode_OMR;
      }
      if (val == "PAB") {
        return CurrencyCode_PAB;
      }
      if (val == "PEN") {
        return CurrencyCode_PEN;
      }
      if (val == "PGK") {
        return CurrencyCode_PGK;
      }
      if (val == "PHP") {
        return CurrencyCode_PHP;
      }
      if (val == "PKR") {
        return CurrencyCode_PKR;
      }
      if (val == "PLN") {
        return CurrencyCode_PLN;
      }
      if (val == "PYG") {
        return CurrencyCode_PYG;
      }
      if (val == "QAR") {
        return CurrencyCode_QAR;
      }
      if (val == "RON") {
        return CurrencyCode_RON;
      }
      if (val == "RSD") {
        return CurrencyCode_RSD;
      }
      if (val == "RUB") {
        return CurrencyCode_RUB;
      }
      if (val == "RWF") {
        return CurrencyCode_RWF;
      }
      if (val == "SAR") {
        return CurrencyCode_SAR;
      }
      if (val == "SBD") {
        return CurrencyCode_SBD;
      }
      if (val == "SCR") {
        return CurrencyCode_SCR;
      }
      if (val == "SDG") {
        return CurrencyCode_SDG;
      }
      if (val == "SEK") {
        return CurrencyCode_SEK;
      }
      if (val == "SGD") {
        return CurrencyCode_SGD;
      }
      if (val == "SHP") {
        return CurrencyCode_SHP;
      }
      if (val == "SLL") {
        return CurrencyCode_SLL;
      }
      if (val == "SOS") {
        return CurrencyCode_SOS;
      }
      if (val == "SRD") {
        return CurrencyCode_SRD;
      }
      if (val == "STD") {
        return CurrencyCode_STD;
      }
      if (val == "SVC") {
        return CurrencyCode_SVC;
      }
      if (val == "SYP") {
        return CurrencyCode_SYP;
      }
      if (val == "SZL") {
        return CurrencyCode_SZL;
      }
      if (val == "THB") {
        return CurrencyCode_THB;
      }
      if (val == "TJS") {
        return CurrencyCode_TJS;
      }
      if (val == "TMT") {
        return CurrencyCode_TMT;
      }
      if (val == "TND") {
        return CurrencyCode_TND;
      }
      if (val == "TOP") {
        return CurrencyCode_TOP;
      }
      if (val == "TRY") {
        return CurrencyCode_TRY;
      }
      if (val == "TTD") {
        return CurrencyCode_TTD;
      }
      if (val == "TVD") {
        return CurrencyCode_TVD;
      }
      if (val == "TWD") {
        return CurrencyCode_TWD;
      }
      if (val == "TZS") {
        return CurrencyCode_TZS;
      }
      if (val == "UAH") {
        return CurrencyCode_UAH;
      }
      if (val == "UGX") {
        return CurrencyCode_UGX;
      }
      if (val == "USD") {
        return CurrencyCode_USD;
      }
      if (val == "UYU") {
        return CurrencyCode_UYU;
      }
      if (val == "UZS") {
        return CurrencyCode_UZS;
      }
      if (val == "VEF") {
        return CurrencyCode_VEF;
      }
      if (val == "VND") {
        return CurrencyCode_VND;
      }
      if (val == "VUV") {
        return CurrencyCode_VUV;
      }
      if (val == "WST") {
        return CurrencyCode_WST;
      }
      if (val == "XAF") {
        return CurrencyCode_XAF;
      }
      if (val == "XCD") {
        return CurrencyCode_XCD;
      }
      if (val == "XDR") {
        return CurrencyCode_XDR;
      }
      if (val == "XOF") {
        return CurrencyCode_XOF;
      }
      if (val == "XPF") {
        return CurrencyCode_XPF;
      }
      if (val == "YER") {
        return CurrencyCode_YER;
      }
      if (val == "ZAR") {
        return CurrencyCode_ZAR;
      }
      if (val == "ZMW") {
        return CurrencyCode_ZMW;
      }
      if (val == "ZWD") {
        return CurrencyCode_ZWD;
      }
      throw std::invalid_argument(val);
    }
    
    DeductionRulePriority stringToDeductionRulePriority(const std::string& val){
      if (val == "Most") {
        return DeductionRulePriority_Most;
      }
      if (val == "Least") {
        return DeductionRulePriority_Least;
      }
      throw std::invalid_argument(val);
    }
    
    DeductionRuleProperty stringToDeductionRuleProperty(const std::string& val){
      if (val == "Recent") {
        return DeductionRuleProperty_Recent;
      }
      if (val == "Expensive") {
        return DeductionRuleProperty_Expensive;
      }
      throw std::invalid_argument(val);
    }
    
    InvoiceItemStatus stringToInvoiceItemStatus(const std::string& val){
      if (val == "Waiting") {
        return InvoiceItemStatus_Waiting;
      }
      if (val == "Processing") {
        return InvoiceItemStatus_Processing;
      }
      if (val == "Failed") {
        return InvoiceItemStatus_Failed;
      }
      if (val == "Completed") {
        return InvoiceItemStatus_Completed;
      }
      if (val == "Refunded") {
        return InvoiceItemStatus_Refunded;
      }
      throw std::invalid_argument(val);
    }
    
    InvoiceSource stringToInvoiceSource(const std::string& val){
      if (val == "OnMber") {
        return InvoiceSource_OnMber;
      }
      if (val == "OnSteam") {
        return InvoiceSource_OnSteam;
      }
      throw std::invalid_argument(val);
    }
    
    InvoiceStatus stringToInvoiceStatus(const std::string& val){
      if (val == "Open") {
        return InvoiceStatus_Open;
      }
      if (val == "Collecting") {
        return InvoiceStatus_Collecting;
      }
      if (val == "Fulfilling") {
        return InvoiceStatus_Fulfilling;
      }
      if (val == "Failed") {
        return InvoiceStatus_Failed;
      }
      if (val == "Completed") {
        return InvoiceStatus_Completed;
      }
      if (val == "Refunded") {
        return InvoiceStatus_Refunded;
      }
      throw std::invalid_argument(val);
    }
    
    RealMoneyTransactionProvider stringToRealMoneyTransactionProvider(const std::string& val){
      if (val == "AmazonFPS") {
        return RealMoneyTransactionProvider_AmazonFPS;
      }
      if (val == "Adyen") {
        return RealMoneyTransactionProvider_Adyen;
      }
      if (val == "Steam") {
        return RealMoneyTransactionProvider_Steam;
      }
      if (val == "BoaCompra") {
        return RealMoneyTransactionProvider_BoaCompra;
      }
      throw std::invalid_argument(val);
    }
    
    VirtualCurrencyStatus stringToVirtualCurrencyStatus(const std::string& val){
      if (val == "Deleted") {
        return VirtualCurrencyStatus_Deleted;
      }
      if (val == "DisableSpending") {
        return VirtualCurrencyStatus_DisableSpending;
      }
      if (val == "DisableEarning") {
        return VirtualCurrencyStatus_DisableEarning;
      }
      throw std::invalid_argument(val);
    }
    
    ServerState stringToServerState(const std::string& val){
      if (val == "Unknown") {
        return ServerState_Unknown;
      }
      if (val == "Online") {
        return ServerState_Online;
      }
      throw std::invalid_argument(val);
    }
    

    
    std::string EntityTypeToString(Mber::EntityType val){
      switch(val){
        case Mber::EntityType_Account:
          return "Account";
          break;
      
        case Mber::EntityType_Profile:
          return "Profile";
          break;
      
        case Mber::EntityType_Application:
          return "Application";
          break;
      
        case Mber::EntityType_Group:
          return "Group";
          break;
      
        case Mber::EntityType_Tag:
          return "Tag";
          break;
      
        case Mber::EntityType_Document:
          return "Document";
          break;
      
        case Mber::EntityType_Any:
          return "Any";
          break;
      
        case Mber::EntityType_Token:
          return "Token";
          break;
      
        case Mber::EntityType_Entitlement:
          return "Entitlement";
          break;
      
        case Mber::EntityType_Role:
          return "Role";
          break;
      
        case Mber::EntityType_Achievement:
          return "Achievement";
          break;
      
        case Mber::EntityType_Metrics:
          return "Metrics";
          break;
      
        case Mber::EntityType_Offer:
          return "Offer";
          break;
      
        case Mber::EntityType_RealCurrency:
          return "RealCurrency";
          break;
      
        case Mber::EntityType_Store:
          return "Store";
          break;
      
        case Mber::EntityType_DigitalGood:
          return "DigitalGood";
          break;
      
        case Mber::EntityType_Cart:
          return "Cart";
          break;
      
        case Mber::EntityType_Invoice:
          return "Invoice";
          break;
      
        case Mber::EntityType_Server:
          return "Server";
          break;
      
        case Mber::EntityType_Email:
          return "Email";
          break;
      
        case Mber::EntityType_Lobby:
          return "Lobby";
          break;
      
        case Mber::EntityType_VirtualCurrency:
          return "VirtualCurrency";
          break;
      
        case Mber::EntityType_WalletLot:
          return "WalletLot";
          break;
      
        case Mber::EntityType_DocumentTemplate:
          return "DocumentTemplate";
          break;
      
        case Mber::EntityType_Catalog:
          return "Catalog";
          break;
      
        case Mber::EntityType_AchievementInstance:
          return "AchievementInstance";
          break;
      
        case Mber::EntityType_DigitalGoodInstance:
          return "DigitalGoodInstance";
          break;
      
        case Mber::EntityType_Directory:
          return "Directory";
          break;
      
        case Mber::EntityType_DocumentLink:
          return "DocumentLink";
          break;
      
        case Mber::EntityType_DirectoryLink:
          return "DirectoryLink";
          break;
      
        case Mber::EntityType_BuildProject:
          return "BuildProject";
          break;
      
        case Mber::EntityType_Build:
          return "Build";
          break;
      
        case Mber::EntityType_ProfileGroup:
          return "ProfileGroup";
          break;
      
        case Mber::EntityType_PaymentProvider:
          return "PaymentProvider";
          break;
      
        case Mber::EntityType_SteamApplication:
          return "SteamApplication";
          break;
      
        case Mber::EntityType_Affiliate:
          return "Affiliate";
          break;
      
        case Mber::EntityType_Campaign:
          return "Campaign";
          break;
      
        case Mber::EntityType_Persona:
          return "Persona";
          break;
      
        case Mber::EntityType_CDNConfig:
          return "CDNConfig";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string EventTypeToString(Mber::EventType val){
      switch(val){
        case Mber::EventType_CREATE:
          return "CREATE";
          break;
      
        case Mber::EventType_READ:
          return "READ";
          break;
      
        case Mber::EventType_UPDATE:
          return "UPDATE";
          break;
      
        case Mber::EventType_DELETE:
          return "DELETE";
          break;
      
        case Mber::EventType_DISABLE:
          return "DISABLE";
          break;
      
        case Mber::EventType_ENABLE:
          return "ENABLE";
          break;
      
        case Mber::EventType_START:
          return "START";
          break;
      
        case Mber::EventType_STOP:
          return "STOP";
          break;
      
        case Mber::EventType_PAUSE:
          return "PAUSE";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string MetricTypeToString(Mber::MetricType val){
      switch(val){
        case Mber::MetricType_String:
          return "String";
          break;
      
        case Mber::MetricType_Int:
          return "Int";
          break;
      
        case Mber::MetricType_Long:
          return "Long";
          break;
      
        case Mber::MetricType_Boolean:
          return "Boolean";
          break;
      
        case Mber::MetricType_Double:
          return "Double";
          break;
      
        case Mber::MetricType_StringArray:
          return "StringArray";
          break;
      
        case Mber::MetricType_CompositeData:
          return "CompositeData";
          break;
      
        case Mber::MetricType_TabularData:
          return "TabularData";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string PermissionTypeToString(Mber::PermissionType val){
      switch(val){
        case Mber::PermissionType_Create:
          return "Create";
          break;
      
        case Mber::PermissionType_Read:
          return "Read";
          break;
      
        case Mber::PermissionType_Update:
          return "Update";
          break;
      
        case Mber::PermissionType_Delete:
          return "Delete";
          break;
      
        case Mber::PermissionType_Assign:
          return "Assign";
          break;
      
        case Mber::PermissionType_History:
          return "History";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string StatusToString(Mber::Status val){
      switch(val){
        case Mber::Status_Success:
          return "Success";
          break;
      
        case Mber::Status_NotAuthorized:
          return "NotAuthorized";
          break;
      
        case Mber::Status_TransactionAlreadyApplied:
          return "TransactionAlreadyApplied";
          break;
      
        case Mber::Status_DuplicateTransactionId:
          return "DuplicateTransactionId";
          break;
      
        case Mber::Status_Failed:
          return "Failed";
          break;
      
        case Mber::Status_Duplicate:
          return "Duplicate";
          break;
      
        case Mber::Status_NotFound:
          return "NotFound";
          break;
      
        case Mber::Status_WrongEntityVersion:
          return "WrongEntityVersion";
          break;
      
        case Mber::Status_NotAllowed:
          return "NotAllowed";
          break;
      
        case Mber::Status_PasswordReset:
          return "PasswordReset";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string TokenTypeToString(Mber::TokenType val){
      switch(val){
        case Mber::TokenType_Access:
          return "Access";
          break;
      
        case Mber::TokenType_Refresh:
          return "Refresh";
          break;
      
        case Mber::TokenType_Authorization:
          return "Authorization";
          break;
      
        case Mber::TokenType_EmailValidation:
          return "EmailValidation";
          break;
      
        case Mber::TokenType_PasswordReset:
          return "PasswordReset";
          break;
      
        case Mber::TokenType_SingleUse:
          return "SingleUse";
          break;
      
        case Mber::TokenType_ForgotPassword:
          return "ForgotPassword";
          break;
      
        case Mber::TokenType_Client:
          return "Client";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string AccessTokenTypeToString(Mber::AccessTokenType val){
      switch(val){
        case Mber::AccessTokenType_Bearer:
          return "Bearer";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string AccountStatusToString(Mber::AccountStatus val){
      switch(val){
        case Mber::AccountStatus_Activated:
          return "Activated";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string ApplicationStatusToString(Mber::ApplicationStatus val){
      switch(val){
        case Mber::ApplicationStatus_Activated:
          return "Activated";
          break;
      
        case Mber::ApplicationStatus_Disabled:
          return "Disabled";
          break;
      
        case Mber::ApplicationStatus_Deleted:
          return "Deleted";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string OauthErrorToString(Mber::OauthError val){
      switch(val){
        case Mber::OauthError_invalid_request:
          return "invalid_request";
          break;
      
        case Mber::OauthError_invalid_client:
          return "invalid_client";
          break;
      
        case Mber::OauthError_invalid_grant:
          return "invalid_grant";
          break;
      
        case Mber::OauthError_unauthorized_client:
          return "unauthorized_client";
          break;
      
        case Mber::OauthError_unsupported_grant_type:
          return "unsupported_grant_type";
          break;
      
        case Mber::OauthError_invalid_scope:
          return "invalid_scope";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string PermissionFlagsToString(Mber::PermissionFlags val){
      switch(val){
        case Mber::PermissionFlags_SelfOnly:
          return "SelfOnly";
          break;
      
        case Mber::PermissionFlags_AllowPrivate:
          return "AllowPrivate";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string ProfileAddressTypeToString(Mber::ProfileAddressType val){
      switch(val){
        case Mber::ProfileAddressType_Shipping:
          return "Shipping";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string ProfileGroupStatusToString(Mber::ProfileGroupStatus val){
      switch(val){
        case Mber::ProfileGroupStatus_Active:
          return "Active";
          break;
      
        case Mber::ProfileGroupStatus_Disabled:
          return "Disabled";
          break;
      
        case Mber::ProfileGroupStatus_System:
          return "System";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string ProfileStatusToString(Mber::ProfileStatus val){
      switch(val){
        case Mber::ProfileStatus_Activated:
          return "Activated";
          break;
      
        case Mber::ProfileStatus_Disabled:
          return "Disabled";
          break;
      
        case Mber::ProfileStatus_Deleted:
          return "Deleted";
          break;
      
        case Mber::ProfileStatus_EmailValidationPending:
          return "EmailValidationPending";
          break;
      
        case Mber::ProfileStatus_PasswordReset:
          return "PasswordReset";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string RegionToString(Mber::Region val){
      switch(val){
        case Mber::Region_Global:
          return "Global";
          break;
      
        case Mber::Region_China:
          return "China";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string RoleStatusToString(Mber::RoleStatus val){
      switch(val){
        case Mber::RoleStatus_Disabled:
          return "Disabled";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string SteamUserStatusToString(Mber::SteamUserStatus val){
      switch(val){
        case Mber::SteamUserStatus_Active:
          return "Active";
          break;
      
        case Mber::SteamUserStatus_UnlinkPending:
          return "UnlinkPending";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string DefinitionStatusToString(Mber::DefinitionStatus val){
      switch(val){
        case Mber::DefinitionStatus_Enabled:
          return "Enabled";
          break;
      
        case Mber::DefinitionStatus_SelfGrant:
          return "SelfGrant";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string EntitlementPropertyAvailabilityToString(Mber::EntitlementPropertyAvailability val){
      switch(val){
        case Mber::EntitlementPropertyAvailability_Unavailable:
          return "Unavailable";
          break;
      
        case Mber::EntitlementPropertyAvailability_Optional:
          return "Optional";
          break;
      
        case Mber::EntitlementPropertyAvailability_Required:
          return "Required";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string EntitlementStateToString(Mber::EntitlementState val){
      switch(val){
        case Mber::EntitlementState_Granted:
          return "Granted";
          break;
      
        case Mber::EntitlementState_Claimed:
          return "Claimed";
          break;
      
        case Mber::EntitlementState_Revoked:
          return "Revoked";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string EntitlementTypeToString(Mber::EntitlementType val){
      switch(val){
        case Mber::EntitlementType_Entitlement:
          return "Entitlement";
          break;
      
        case Mber::EntitlementType_Achievement:
          return "Achievement";
          break;
      
        case Mber::EntitlementType_DigitalGood:
          return "DigitalGood";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string KeyFormatToString(Mber::KeyFormat val){
      switch(val){
        case Mber::KeyFormat_Print:
          return "Print";
          break;
      
        case Mber::KeyFormat_URL:
          return "URL";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string CDNTypeToString(Mber::CDNType val){
      switch(val){
        case Mber::CDNType_Highwinds:
          return "Highwinds";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string DataStorageLocationToString(Mber::DataStorageLocation val){
      switch(val){
        case Mber::DataStorageLocation_Cassandra:
          return "Cassandra";
          break;
      
        case Mber::DataStorageLocation_S3:
          return "S3";
          break;
      
        case Mber::DataStorageLocation_CDN:
          return "CDN";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string DocumentStatusToString(Mber::DocumentStatus val){
      switch(val){
        case Mber::DocumentStatus_Incomplete:
          return "Incomplete";
          break;
      
        case Mber::DocumentStatus_Invalid:
          return "Invalid";
          break;
      
        case Mber::DocumentStatus_NotIndexed:
          return "NotIndexed";
          break;
      
        case Mber::DocumentStatus_SyncPending:
          return "SyncPending";
          break;
      
        case Mber::DocumentStatus_SyncFailed:
          return "SyncFailed";
          break;
      
        case Mber::DocumentStatus_SyncComplete:
          return "SyncComplete";
          break;
      
        case Mber::DocumentStatus_SyncEnabled:
          return "SyncEnabled";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string TemplateFieldTypeToString(Mber::TemplateFieldType val){
      switch(val){
        case Mber::TemplateFieldType_Number:
          return "Number";
          break;
      
        case Mber::TemplateFieldType_String:
          return "String";
          break;
      
        case Mber::TemplateFieldType_Boolean:
          return "Boolean";
          break;
      
        case Mber::TemplateFieldType_Object:
          return "Object";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string AppCountTypeToString(Mber::AppCountType val){
      switch(val){
        case Mber::AppCountType_SELFONLY:
          return "SELFONLY";
          break;
      
        case Mber::AppCountType_INCLUSIVE:
          return "INCLUSIVE";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string ProfileHistoryFilterToString(Mber::ProfileHistoryFilter val){
      switch(val){
        case Mber::ProfileHistoryFilter_Profile:
          return "Profile";
          break;
      
        case Mber::ProfileHistoryFilter_VirtualPurchase:
          return "VirtualPurchase";
          break;
      
        case Mber::ProfileHistoryFilter_InvoicePurchase:
          return "InvoicePurchase";
          break;
      
        case Mber::ProfileHistoryFilter_PasswordReset:
          return "PasswordReset";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string TimeUnitToString(Mber::TimeUnit val){
      switch(val){
        case Mber::TimeUnit_SECONDS:
          return "SECONDS";
          break;
      
        case Mber::TimeUnit_MINUTES:
          return "MINUTES";
          break;
      
        case Mber::TimeUnit_HOURS:
          return "HOURS";
          break;
      
        case Mber::TimeUnit_DAYS:
          return "DAYS";
          break;
      
        case Mber::TimeUnit_MONTHS:
          return "MONTHS";
          break;
      
        case Mber::TimeUnit_YEARS:
          return "YEARS";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string AffiliateStatusToString(Mber::AffiliateStatus val){
      switch(val){
        case Mber::AffiliateStatus_Activated:
          return "Activated";
          break;
      
        case Mber::AffiliateStatus_Deleted:
          return "Deleted";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string CurrencyCodeToString(Mber::CurrencyCode val){
      switch(val){
        case Mber::CurrencyCode_AED:
          return "AED";
          break;
      
        case Mber::CurrencyCode_AFN:
          return "AFN";
          break;
      
        case Mber::CurrencyCode_ALL:
          return "ALL";
          break;
      
        case Mber::CurrencyCode_AMD:
          return "AMD";
          break;
      
        case Mber::CurrencyCode_ANG:
          return "ANG";
          break;
      
        case Mber::CurrencyCode_AOA:
          return "AOA";
          break;
      
        case Mber::CurrencyCode_ARS:
          return "ARS";
          break;
      
        case Mber::CurrencyCode_AUD:
          return "AUD";
          break;
      
        case Mber::CurrencyCode_AWG:
          return "AWG";
          break;
      
        case Mber::CurrencyCode_AZN:
          return "AZN";
          break;
      
        case Mber::CurrencyCode_BAM:
          return "BAM";
          break;
      
        case Mber::CurrencyCode_BBD:
          return "BBD";
          break;
      
        case Mber::CurrencyCode_BDT:
          return "BDT";
          break;
      
        case Mber::CurrencyCode_BGN:
          return "BGN";
          break;
      
        case Mber::CurrencyCode_BHD:
          return "BHD";
          break;
      
        case Mber::CurrencyCode_BIF:
          return "BIF";
          break;
      
        case Mber::CurrencyCode_BMD:
          return "BMD";
          break;
      
        case Mber::CurrencyCode_BND:
          return "BND";
          break;
      
        case Mber::CurrencyCode_BOB:
          return "BOB";
          break;
      
        case Mber::CurrencyCode_BRL:
          return "BRL";
          break;
      
        case Mber::CurrencyCode_BSD:
          return "BSD";
          break;
      
        case Mber::CurrencyCode_BTN:
          return "BTN";
          break;
      
        case Mber::CurrencyCode_BWP:
          return "BWP";
          break;
      
        case Mber::CurrencyCode_BYR:
          return "BYR";
          break;
      
        case Mber::CurrencyCode_BZD:
          return "BZD";
          break;
      
        case Mber::CurrencyCode_CAD:
          return "CAD";
          break;
      
        case Mber::CurrencyCode_CDF:
          return "CDF";
          break;
      
        case Mber::CurrencyCode_CHF:
          return "CHF";
          break;
      
        case Mber::CurrencyCode_CLP:
          return "CLP";
          break;
      
        case Mber::CurrencyCode_CNY:
          return "CNY";
          break;
      
        case Mber::CurrencyCode_COP:
          return "COP";
          break;
      
        case Mber::CurrencyCode_CRC:
          return "CRC";
          break;
      
        case Mber::CurrencyCode_CUC:
          return "CUC";
          break;
      
        case Mber::CurrencyCode_CUP:
          return "CUP";
          break;
      
        case Mber::CurrencyCode_CVE:
          return "CVE";
          break;
      
        case Mber::CurrencyCode_CZK:
          return "CZK";
          break;
      
        case Mber::CurrencyCode_DJF:
          return "DJF";
          break;
      
        case Mber::CurrencyCode_DKK:
          return "DKK";
          break;
      
        case Mber::CurrencyCode_DOP:
          return "DOP";
          break;
      
        case Mber::CurrencyCode_DZD:
          return "DZD";
          break;
      
        case Mber::CurrencyCode_EGP:
          return "EGP";
          break;
      
        case Mber::CurrencyCode_ERN:
          return "ERN";
          break;
      
        case Mber::CurrencyCode_ETB:
          return "ETB";
          break;
      
        case Mber::CurrencyCode_EUR:
          return "EUR";
          break;
      
        case Mber::CurrencyCode_FJD:
          return "FJD";
          break;
      
        case Mber::CurrencyCode_FKP:
          return "FKP";
          break;
      
        case Mber::CurrencyCode_GBP:
          return "GBP";
          break;
      
        case Mber::CurrencyCode_GEL:
          return "GEL";
          break;
      
        case Mber::CurrencyCode_GGP:
          return "GGP";
          break;
      
        case Mber::CurrencyCode_GHS:
          return "GHS";
          break;
      
        case Mber::CurrencyCode_GIP:
          return "GIP";
          break;
      
        case Mber::CurrencyCode_GMD:
          return "GMD";
          break;
      
        case Mber::CurrencyCode_GNF:
          return "GNF";
          break;
      
        case Mber::CurrencyCode_GTQ:
          return "GTQ";
          break;
      
        case Mber::CurrencyCode_GYD:
          return "GYD";
          break;
      
        case Mber::CurrencyCode_HKD:
          return "HKD";
          break;
      
        case Mber::CurrencyCode_HNL:
          return "HNL";
          break;
      
        case Mber::CurrencyCode_HRK:
          return "HRK";
          break;
      
        case Mber::CurrencyCode_HTG:
          return "HTG";
          break;
      
        case Mber::CurrencyCode_HUF:
          return "HUF";
          break;
      
        case Mber::CurrencyCode_IDR:
          return "IDR";
          break;
      
        case Mber::CurrencyCode_ILS:
          return "ILS";
          break;
      
        case Mber::CurrencyCode_IMP:
          return "IMP";
          break;
      
        case Mber::CurrencyCode_INR:
          return "INR";
          break;
      
        case Mber::CurrencyCode_IQD:
          return "IQD";
          break;
      
        case Mber::CurrencyCode_IRR:
          return "IRR";
          break;
      
        case Mber::CurrencyCode_ISK:
          return "ISK";
          break;
      
        case Mber::CurrencyCode_JEP:
          return "JEP";
          break;
      
        case Mber::CurrencyCode_JMD:
          return "JMD";
          break;
      
        case Mber::CurrencyCode_JOD:
          return "JOD";
          break;
      
        case Mber::CurrencyCode_JPY:
          return "JPY";
          break;
      
        case Mber::CurrencyCode_KES:
          return "KES";
          break;
      
        case Mber::CurrencyCode_KGS:
          return "KGS";
          break;
      
        case Mber::CurrencyCode_KHR:
          return "KHR";
          break;
      
        case Mber::CurrencyCode_KMF:
          return "KMF";
          break;
      
        case Mber::CurrencyCode_KPW:
          return "KPW";
          break;
      
        case Mber::CurrencyCode_KRW:
          return "KRW";
          break;
      
        case Mber::CurrencyCode_KWD:
          return "KWD";
          break;
      
        case Mber::CurrencyCode_KYD:
          return "KYD";
          break;
      
        case Mber::CurrencyCode_KZT:
          return "KZT";
          break;
      
        case Mber::CurrencyCode_LAK:
          return "LAK";
          break;
      
        case Mber::CurrencyCode_LBP:
          return "LBP";
          break;
      
        case Mber::CurrencyCode_LKR:
          return "LKR";
          break;
      
        case Mber::CurrencyCode_LRD:
          return "LRD";
          break;
      
        case Mber::CurrencyCode_LSL:
          return "LSL";
          break;
      
        case Mber::CurrencyCode_LTL:
          return "LTL";
          break;
      
        case Mber::CurrencyCode_LVL:
          return "LVL";
          break;
      
        case Mber::CurrencyCode_LYD:
          return "LYD";
          break;
      
        case Mber::CurrencyCode_MAD:
          return "MAD";
          break;
      
        case Mber::CurrencyCode_MDL:
          return "MDL";
          break;
      
        case Mber::CurrencyCode_MGA:
          return "MGA";
          break;
      
        case Mber::CurrencyCode_MKD:
          return "MKD";
          break;
      
        case Mber::CurrencyCode_MMK:
          return "MMK";
          break;
      
        case Mber::CurrencyCode_MNT:
          return "MNT";
          break;
      
        case Mber::CurrencyCode_MOP:
          return "MOP";
          break;
      
        case Mber::CurrencyCode_MRO:
          return "MRO";
          break;
      
        case Mber::CurrencyCode_MUR:
          return "MUR";
          break;
      
        case Mber::CurrencyCode_MVR:
          return "MVR";
          break;
      
        case Mber::CurrencyCode_MWK:
          return "MWK";
          break;
      
        case Mber::CurrencyCode_MXN:
          return "MXN";
          break;
      
        case Mber::CurrencyCode_MYR:
          return "MYR";
          break;
      
        case Mber::CurrencyCode_MZN:
          return "MZN";
          break;
      
        case Mber::CurrencyCode_NAD:
          return "NAD";
          break;
      
        case Mber::CurrencyCode_NGN:
          return "NGN";
          break;
      
        case Mber::CurrencyCode_NIO:
          return "NIO";
          break;
      
        case Mber::CurrencyCode_NOK:
          return "NOK";
          break;
      
        case Mber::CurrencyCode_NPR:
          return "NPR";
          break;
      
        case Mber::CurrencyCode_NZD:
          return "NZD";
          break;
      
        case Mber::CurrencyCode_OMR:
          return "OMR";
          break;
      
        case Mber::CurrencyCode_PAB:
          return "PAB";
          break;
      
        case Mber::CurrencyCode_PEN:
          return "PEN";
          break;
      
        case Mber::CurrencyCode_PGK:
          return "PGK";
          break;
      
        case Mber::CurrencyCode_PHP:
          return "PHP";
          break;
      
        case Mber::CurrencyCode_PKR:
          return "PKR";
          break;
      
        case Mber::CurrencyCode_PLN:
          return "PLN";
          break;
      
        case Mber::CurrencyCode_PYG:
          return "PYG";
          break;
      
        case Mber::CurrencyCode_QAR:
          return "QAR";
          break;
      
        case Mber::CurrencyCode_RON:
          return "RON";
          break;
      
        case Mber::CurrencyCode_RSD:
          return "RSD";
          break;
      
        case Mber::CurrencyCode_RUB:
          return "RUB";
          break;
      
        case Mber::CurrencyCode_RWF:
          return "RWF";
          break;
      
        case Mber::CurrencyCode_SAR:
          return "SAR";
          break;
      
        case Mber::CurrencyCode_SBD:
          return "SBD";
          break;
      
        case Mber::CurrencyCode_SCR:
          return "SCR";
          break;
      
        case Mber::CurrencyCode_SDG:
          return "SDG";
          break;
      
        case Mber::CurrencyCode_SEK:
          return "SEK";
          break;
      
        case Mber::CurrencyCode_SGD:
          return "SGD";
          break;
      
        case Mber::CurrencyCode_SHP:
          return "SHP";
          break;
      
        case Mber::CurrencyCode_SLL:
          return "SLL";
          break;
      
        case Mber::CurrencyCode_SOS:
          return "SOS";
          break;
      
        case Mber::CurrencyCode_SRD:
          return "SRD";
          break;
      
        case Mber::CurrencyCode_STD:
          return "STD";
          break;
      
        case Mber::CurrencyCode_SVC:
          return "SVC";
          break;
      
        case Mber::CurrencyCode_SYP:
          return "SYP";
          break;
      
        case Mber::CurrencyCode_SZL:
          return "SZL";
          break;
      
        case Mber::CurrencyCode_THB:
          return "THB";
          break;
      
        case Mber::CurrencyCode_TJS:
          return "TJS";
          break;
      
        case Mber::CurrencyCode_TMT:
          return "TMT";
          break;
      
        case Mber::CurrencyCode_TND:
          return "TND";
          break;
      
        case Mber::CurrencyCode_TOP:
          return "TOP";
          break;
      
        case Mber::CurrencyCode_TRY:
          return "TRY";
          break;
      
        case Mber::CurrencyCode_TTD:
          return "TTD";
          break;
      
        case Mber::CurrencyCode_TVD:
          return "TVD";
          break;
      
        case Mber::CurrencyCode_TWD:
          return "TWD";
          break;
      
        case Mber::CurrencyCode_TZS:
          return "TZS";
          break;
      
        case Mber::CurrencyCode_UAH:
          return "UAH";
          break;
      
        case Mber::CurrencyCode_UGX:
          return "UGX";
          break;
      
        case Mber::CurrencyCode_USD:
          return "USD";
          break;
      
        case Mber::CurrencyCode_UYU:
          return "UYU";
          break;
      
        case Mber::CurrencyCode_UZS:
          return "UZS";
          break;
      
        case Mber::CurrencyCode_VEF:
          return "VEF";
          break;
      
        case Mber::CurrencyCode_VND:
          return "VND";
          break;
      
        case Mber::CurrencyCode_VUV:
          return "VUV";
          break;
      
        case Mber::CurrencyCode_WST:
          return "WST";
          break;
      
        case Mber::CurrencyCode_XAF:
          return "XAF";
          break;
      
        case Mber::CurrencyCode_XCD:
          return "XCD";
          break;
      
        case Mber::CurrencyCode_XDR:
          return "XDR";
          break;
      
        case Mber::CurrencyCode_XOF:
          return "XOF";
          break;
      
        case Mber::CurrencyCode_XPF:
          return "XPF";
          break;
      
        case Mber::CurrencyCode_YER:
          return "YER";
          break;
      
        case Mber::CurrencyCode_ZAR:
          return "ZAR";
          break;
      
        case Mber::CurrencyCode_ZMW:
          return "ZMW";
          break;
      
        case Mber::CurrencyCode_ZWD:
          return "ZWD";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string DeductionRulePriorityToString(Mber::DeductionRulePriority val){
      switch(val){
        case Mber::DeductionRulePriority_Most:
          return "Most";
          break;
      
        case Mber::DeductionRulePriority_Least:
          return "Least";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string DeductionRulePropertyToString(Mber::DeductionRuleProperty val){
      switch(val){
        case Mber::DeductionRuleProperty_Recent:
          return "Recent";
          break;
      
        case Mber::DeductionRuleProperty_Expensive:
          return "Expensive";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string InvoiceItemStatusToString(Mber::InvoiceItemStatus val){
      switch(val){
        case Mber::InvoiceItemStatus_Waiting:
          return "Waiting";
          break;
      
        case Mber::InvoiceItemStatus_Processing:
          return "Processing";
          break;
      
        case Mber::InvoiceItemStatus_Failed:
          return "Failed";
          break;
      
        case Mber::InvoiceItemStatus_Completed:
          return "Completed";
          break;
      
        case Mber::InvoiceItemStatus_Refunded:
          return "Refunded";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string InvoiceSourceToString(Mber::InvoiceSource val){
      switch(val){
        case Mber::InvoiceSource_OnMber:
          return "OnMber";
          break;
      
        case Mber::InvoiceSource_OnSteam:
          return "OnSteam";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string InvoiceStatusToString(Mber::InvoiceStatus val){
      switch(val){
        case Mber::InvoiceStatus_Open:
          return "Open";
          break;
      
        case Mber::InvoiceStatus_Collecting:
          return "Collecting";
          break;
      
        case Mber::InvoiceStatus_Fulfilling:
          return "Fulfilling";
          break;
      
        case Mber::InvoiceStatus_Failed:
          return "Failed";
          break;
      
        case Mber::InvoiceStatus_Completed:
          return "Completed";
          break;
      
        case Mber::InvoiceStatus_Refunded:
          return "Refunded";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string RealMoneyTransactionProviderToString(Mber::RealMoneyTransactionProvider val){
      switch(val){
        case Mber::RealMoneyTransactionProvider_AmazonFPS:
          return "AmazonFPS";
          break;
      
        case Mber::RealMoneyTransactionProvider_Adyen:
          return "Adyen";
          break;
      
        case Mber::RealMoneyTransactionProvider_Steam:
          return "Steam";
          break;
      
        case Mber::RealMoneyTransactionProvider_BoaCompra:
          return "BoaCompra";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string VirtualCurrencyStatusToString(Mber::VirtualCurrencyStatus val){
      switch(val){
        case Mber::VirtualCurrencyStatus_Deleted:
          return "Deleted";
          break;
      
        case Mber::VirtualCurrencyStatus_DisableSpending:
          return "DisableSpending";
          break;
      
        case Mber::VirtualCurrencyStatus_DisableEarning:
          return "DisableEarning";
          break;
      
        default:
          return "";
          break;
      }
    }
    std::string ServerStateToString(Mber::ServerState val){
      switch(val){
        case Mber::ServerState_Unknown:
          return "Unknown";
          break;
      
        case Mber::ServerState_Online:
          return "Online";
          break;
      
        default:
          return "";
          break;
      }
    }

    // Templated conversion for intrinsic types
    template <typename T>
    T toJson(const T& val) {
      return val;
    }
    
    // Enum conversions
    std::string toJson(const Mber::EntityType& val) {
      return EntityTypeToString(val);
    }
    Mber::EntityType jsonToEntityType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Account").compare(enumName) == 0){ return Mber::EntityType_Account; }
      if(std::string("Profile").compare(enumName) == 0){ return Mber::EntityType_Profile; }
      if(std::string("Application").compare(enumName) == 0){ return Mber::EntityType_Application; }
      if(std::string("Group").compare(enumName) == 0){ return Mber::EntityType_Group; }
      if(std::string("Tag").compare(enumName) == 0){ return Mber::EntityType_Tag; }
      if(std::string("Document").compare(enumName) == 0){ return Mber::EntityType_Document; }
      if(std::string("Any").compare(enumName) == 0){ return Mber::EntityType_Any; }
      if(std::string("Token").compare(enumName) == 0){ return Mber::EntityType_Token; }
      if(std::string("Entitlement").compare(enumName) == 0){ return Mber::EntityType_Entitlement; }
      if(std::string("Role").compare(enumName) == 0){ return Mber::EntityType_Role; }
      if(std::string("Achievement").compare(enumName) == 0){ return Mber::EntityType_Achievement; }
      if(std::string("Metrics").compare(enumName) == 0){ return Mber::EntityType_Metrics; }
      if(std::string("Offer").compare(enumName) == 0){ return Mber::EntityType_Offer; }
      if(std::string("RealCurrency").compare(enumName) == 0){ return Mber::EntityType_RealCurrency; }
      if(std::string("Store").compare(enumName) == 0){ return Mber::EntityType_Store; }
      if(std::string("DigitalGood").compare(enumName) == 0){ return Mber::EntityType_DigitalGood; }
      if(std::string("Cart").compare(enumName) == 0){ return Mber::EntityType_Cart; }
      if(std::string("Invoice").compare(enumName) == 0){ return Mber::EntityType_Invoice; }
      if(std::string("Server").compare(enumName) == 0){ return Mber::EntityType_Server; }
      if(std::string("Email").compare(enumName) == 0){ return Mber::EntityType_Email; }
      if(std::string("Lobby").compare(enumName) == 0){ return Mber::EntityType_Lobby; }
      if(std::string("VirtualCurrency").compare(enumName) == 0){ return Mber::EntityType_VirtualCurrency; }
      if(std::string("WalletLot").compare(enumName) == 0){ return Mber::EntityType_WalletLot; }
      if(std::string("DocumentTemplate").compare(enumName) == 0){ return Mber::EntityType_DocumentTemplate; }
      if(std::string("Catalog").compare(enumName) == 0){ return Mber::EntityType_Catalog; }
      if(std::string("AchievementInstance").compare(enumName) == 0){ return Mber::EntityType_AchievementInstance; }
      if(std::string("DigitalGoodInstance").compare(enumName) == 0){ return Mber::EntityType_DigitalGoodInstance; }
      if(std::string("Directory").compare(enumName) == 0){ return Mber::EntityType_Directory; }
      if(std::string("DocumentLink").compare(enumName) == 0){ return Mber::EntityType_DocumentLink; }
      if(std::string("DirectoryLink").compare(enumName) == 0){ return Mber::EntityType_DirectoryLink; }
      if(std::string("BuildProject").compare(enumName) == 0){ return Mber::EntityType_BuildProject; }
      if(std::string("Build").compare(enumName) == 0){ return Mber::EntityType_Build; }
      if(std::string("ProfileGroup").compare(enumName) == 0){ return Mber::EntityType_ProfileGroup; }
      if(std::string("PaymentProvider").compare(enumName) == 0){ return Mber::EntityType_PaymentProvider; }
      if(std::string("SteamApplication").compare(enumName) == 0){ return Mber::EntityType_SteamApplication; }
      if(std::string("Affiliate").compare(enumName) == 0){ return Mber::EntityType_Affiliate; }
      if(std::string("Campaign").compare(enumName) == 0){ return Mber::EntityType_Campaign; }
      if(std::string("Persona").compare(enumName) == 0){ return Mber::EntityType_Persona; }
      if(std::string("CDNConfig").compare(enumName) == 0){ return Mber::EntityType_CDNConfig; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::EventType& val) {
      return EventTypeToString(val);
    }
    Mber::EventType jsonToEventType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("CREATE").compare(enumName) == 0){ return Mber::EventType_CREATE; }
      if(std::string("READ").compare(enumName) == 0){ return Mber::EventType_READ; }
      if(std::string("UPDATE").compare(enumName) == 0){ return Mber::EventType_UPDATE; }
      if(std::string("DELETE").compare(enumName) == 0){ return Mber::EventType_DELETE; }
      if(std::string("DISABLE").compare(enumName) == 0){ return Mber::EventType_DISABLE; }
      if(std::string("ENABLE").compare(enumName) == 0){ return Mber::EventType_ENABLE; }
      if(std::string("START").compare(enumName) == 0){ return Mber::EventType_START; }
      if(std::string("STOP").compare(enumName) == 0){ return Mber::EventType_STOP; }
      if(std::string("PAUSE").compare(enumName) == 0){ return Mber::EventType_PAUSE; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::MetricType& val) {
      return MetricTypeToString(val);
    }
    Mber::MetricType jsonToMetricType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("String").compare(enumName) == 0){ return Mber::MetricType_String; }
      if(std::string("Int").compare(enumName) == 0){ return Mber::MetricType_Int; }
      if(std::string("Long").compare(enumName) == 0){ return Mber::MetricType_Long; }
      if(std::string("Boolean").compare(enumName) == 0){ return Mber::MetricType_Boolean; }
      if(std::string("Double").compare(enumName) == 0){ return Mber::MetricType_Double; }
      if(std::string("StringArray").compare(enumName) == 0){ return Mber::MetricType_StringArray; }
      if(std::string("CompositeData").compare(enumName) == 0){ return Mber::MetricType_CompositeData; }
      if(std::string("TabularData").compare(enumName) == 0){ return Mber::MetricType_TabularData; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::PermissionType& val) {
      return PermissionTypeToString(val);
    }
    Mber::PermissionType jsonToPermissionType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Create").compare(enumName) == 0){ return Mber::PermissionType_Create; }
      if(std::string("Read").compare(enumName) == 0){ return Mber::PermissionType_Read; }
      if(std::string("Update").compare(enumName) == 0){ return Mber::PermissionType_Update; }
      if(std::string("Delete").compare(enumName) == 0){ return Mber::PermissionType_Delete; }
      if(std::string("Assign").compare(enumName) == 0){ return Mber::PermissionType_Assign; }
      if(std::string("History").compare(enumName) == 0){ return Mber::PermissionType_History; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::Status& val) {
      return StatusToString(val);
    }
    Mber::Status jsonToStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Success").compare(enumName) == 0){ return Mber::Status_Success; }
      if(std::string("NotAuthorized").compare(enumName) == 0){ return Mber::Status_NotAuthorized; }
      if(std::string("TransactionAlreadyApplied").compare(enumName) == 0){ return Mber::Status_TransactionAlreadyApplied; }
      if(std::string("DuplicateTransactionId").compare(enumName) == 0){ return Mber::Status_DuplicateTransactionId; }
      if(std::string("Failed").compare(enumName) == 0){ return Mber::Status_Failed; }
      if(std::string("Duplicate").compare(enumName) == 0){ return Mber::Status_Duplicate; }
      if(std::string("NotFound").compare(enumName) == 0){ return Mber::Status_NotFound; }
      if(std::string("WrongEntityVersion").compare(enumName) == 0){ return Mber::Status_WrongEntityVersion; }
      if(std::string("NotAllowed").compare(enumName) == 0){ return Mber::Status_NotAllowed; }
      if(std::string("PasswordReset").compare(enumName) == 0){ return Mber::Status_PasswordReset; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::TokenType& val) {
      return TokenTypeToString(val);
    }
    Mber::TokenType jsonToTokenType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Access").compare(enumName) == 0){ return Mber::TokenType_Access; }
      if(std::string("Refresh").compare(enumName) == 0){ return Mber::TokenType_Refresh; }
      if(std::string("Authorization").compare(enumName) == 0){ return Mber::TokenType_Authorization; }
      if(std::string("EmailValidation").compare(enumName) == 0){ return Mber::TokenType_EmailValidation; }
      if(std::string("PasswordReset").compare(enumName) == 0){ return Mber::TokenType_PasswordReset; }
      if(std::string("SingleUse").compare(enumName) == 0){ return Mber::TokenType_SingleUse; }
      if(std::string("ForgotPassword").compare(enumName) == 0){ return Mber::TokenType_ForgotPassword; }
      if(std::string("Client").compare(enumName) == 0){ return Mber::TokenType_Client; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::AccessTokenType& val) {
      return AccessTokenTypeToString(val);
    }
    Mber::AccessTokenType jsonToAccessTokenType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Bearer").compare(enumName) == 0){ return Mber::AccessTokenType_Bearer; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::AccountStatus& val) {
      return AccountStatusToString(val);
    }
    Mber::AccountStatus jsonToAccountStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Activated").compare(enumName) == 0){ return Mber::AccountStatus_Activated; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::ApplicationStatus& val) {
      return ApplicationStatusToString(val);
    }
    Mber::ApplicationStatus jsonToApplicationStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Activated").compare(enumName) == 0){ return Mber::ApplicationStatus_Activated; }
      if(std::string("Disabled").compare(enumName) == 0){ return Mber::ApplicationStatus_Disabled; }
      if(std::string("Deleted").compare(enumName) == 0){ return Mber::ApplicationStatus_Deleted; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::OauthError& val) {
      return OauthErrorToString(val);
    }
    Mber::OauthError jsonToOauthError(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("invalid_request").compare(enumName) == 0){ return Mber::OauthError_invalid_request; }
      if(std::string("invalid_client").compare(enumName) == 0){ return Mber::OauthError_invalid_client; }
      if(std::string("invalid_grant").compare(enumName) == 0){ return Mber::OauthError_invalid_grant; }
      if(std::string("unauthorized_client").compare(enumName) == 0){ return Mber::OauthError_unauthorized_client; }
      if(std::string("unsupported_grant_type").compare(enumName) == 0){ return Mber::OauthError_unsupported_grant_type; }
      if(std::string("invalid_scope").compare(enumName) == 0){ return Mber::OauthError_invalid_scope; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::PermissionFlags& val) {
      return PermissionFlagsToString(val);
    }
    Mber::PermissionFlags jsonToPermissionFlags(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("SelfOnly").compare(enumName) == 0){ return Mber::PermissionFlags_SelfOnly; }
      if(std::string("AllowPrivate").compare(enumName) == 0){ return Mber::PermissionFlags_AllowPrivate; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::ProfileAddressType& val) {
      return ProfileAddressTypeToString(val);
    }
    Mber::ProfileAddressType jsonToProfileAddressType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Shipping").compare(enumName) == 0){ return Mber::ProfileAddressType_Shipping; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::ProfileGroupStatus& val) {
      return ProfileGroupStatusToString(val);
    }
    Mber::ProfileGroupStatus jsonToProfileGroupStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Active").compare(enumName) == 0){ return Mber::ProfileGroupStatus_Active; }
      if(std::string("Disabled").compare(enumName) == 0){ return Mber::ProfileGroupStatus_Disabled; }
      if(std::string("System").compare(enumName) == 0){ return Mber::ProfileGroupStatus_System; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::ProfileStatus& val) {
      return ProfileStatusToString(val);
    }
    Mber::ProfileStatus jsonToProfileStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Activated").compare(enumName) == 0){ return Mber::ProfileStatus_Activated; }
      if(std::string("Disabled").compare(enumName) == 0){ return Mber::ProfileStatus_Disabled; }
      if(std::string("Deleted").compare(enumName) == 0){ return Mber::ProfileStatus_Deleted; }
      if(std::string("EmailValidationPending").compare(enumName) == 0){ return Mber::ProfileStatus_EmailValidationPending; }
      if(std::string("PasswordReset").compare(enumName) == 0){ return Mber::ProfileStatus_PasswordReset; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::Region& val) {
      return RegionToString(val);
    }
    Mber::Region jsonToRegion(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Global").compare(enumName) == 0){ return Mber::Region_Global; }
      if(std::string("China").compare(enumName) == 0){ return Mber::Region_China; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::RoleStatus& val) {
      return RoleStatusToString(val);
    }
    Mber::RoleStatus jsonToRoleStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Disabled").compare(enumName) == 0){ return Mber::RoleStatus_Disabled; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::SteamUserStatus& val) {
      return SteamUserStatusToString(val);
    }
    Mber::SteamUserStatus jsonToSteamUserStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Active").compare(enumName) == 0){ return Mber::SteamUserStatus_Active; }
      if(std::string("UnlinkPending").compare(enumName) == 0){ return Mber::SteamUserStatus_UnlinkPending; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::DefinitionStatus& val) {
      return DefinitionStatusToString(val);
    }
    Mber::DefinitionStatus jsonToDefinitionStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Enabled").compare(enumName) == 0){ return Mber::DefinitionStatus_Enabled; }
      if(std::string("SelfGrant").compare(enumName) == 0){ return Mber::DefinitionStatus_SelfGrant; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::EntitlementPropertyAvailability& val) {
      return EntitlementPropertyAvailabilityToString(val);
    }
    Mber::EntitlementPropertyAvailability jsonToEntitlementPropertyAvailability(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Unavailable").compare(enumName) == 0){ return Mber::EntitlementPropertyAvailability_Unavailable; }
      if(std::string("Optional").compare(enumName) == 0){ return Mber::EntitlementPropertyAvailability_Optional; }
      if(std::string("Required").compare(enumName) == 0){ return Mber::EntitlementPropertyAvailability_Required; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::EntitlementState& val) {
      return EntitlementStateToString(val);
    }
    Mber::EntitlementState jsonToEntitlementState(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Granted").compare(enumName) == 0){ return Mber::EntitlementState_Granted; }
      if(std::string("Claimed").compare(enumName) == 0){ return Mber::EntitlementState_Claimed; }
      if(std::string("Revoked").compare(enumName) == 0){ return Mber::EntitlementState_Revoked; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::EntitlementType& val) {
      return EntitlementTypeToString(val);
    }
    Mber::EntitlementType jsonToEntitlementType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Entitlement").compare(enumName) == 0){ return Mber::EntitlementType_Entitlement; }
      if(std::string("Achievement").compare(enumName) == 0){ return Mber::EntitlementType_Achievement; }
      if(std::string("DigitalGood").compare(enumName) == 0){ return Mber::EntitlementType_DigitalGood; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::KeyFormat& val) {
      return KeyFormatToString(val);
    }
    Mber::KeyFormat jsonToKeyFormat(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Print").compare(enumName) == 0){ return Mber::KeyFormat_Print; }
      if(std::string("URL").compare(enumName) == 0){ return Mber::KeyFormat_URL; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::CDNType& val) {
      return CDNTypeToString(val);
    }
    Mber::CDNType jsonToCDNType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Highwinds").compare(enumName) == 0){ return Mber::CDNType_Highwinds; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::DataStorageLocation& val) {
      return DataStorageLocationToString(val);
    }
    Mber::DataStorageLocation jsonToDataStorageLocation(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Cassandra").compare(enumName) == 0){ return Mber::DataStorageLocation_Cassandra; }
      if(std::string("S3").compare(enumName) == 0){ return Mber::DataStorageLocation_S3; }
      if(std::string("CDN").compare(enumName) == 0){ return Mber::DataStorageLocation_CDN; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::DocumentStatus& val) {
      return DocumentStatusToString(val);
    }
    Mber::DocumentStatus jsonToDocumentStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Incomplete").compare(enumName) == 0){ return Mber::DocumentStatus_Incomplete; }
      if(std::string("Invalid").compare(enumName) == 0){ return Mber::DocumentStatus_Invalid; }
      if(std::string("NotIndexed").compare(enumName) == 0){ return Mber::DocumentStatus_NotIndexed; }
      if(std::string("SyncPending").compare(enumName) == 0){ return Mber::DocumentStatus_SyncPending; }
      if(std::string("SyncFailed").compare(enumName) == 0){ return Mber::DocumentStatus_SyncFailed; }
      if(std::string("SyncComplete").compare(enumName) == 0){ return Mber::DocumentStatus_SyncComplete; }
      if(std::string("SyncEnabled").compare(enumName) == 0){ return Mber::DocumentStatus_SyncEnabled; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::TemplateFieldType& val) {
      return TemplateFieldTypeToString(val);
    }
    Mber::TemplateFieldType jsonToTemplateFieldType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Number").compare(enumName) == 0){ return Mber::TemplateFieldType_Number; }
      if(std::string("String").compare(enumName) == 0){ return Mber::TemplateFieldType_String; }
      if(std::string("Boolean").compare(enumName) == 0){ return Mber::TemplateFieldType_Boolean; }
      if(std::string("Object").compare(enumName) == 0){ return Mber::TemplateFieldType_Object; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::AppCountType& val) {
      return AppCountTypeToString(val);
    }
    Mber::AppCountType jsonToAppCountType(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("SELFONLY").compare(enumName) == 0){ return Mber::AppCountType_SELFONLY; }
      if(std::string("INCLUSIVE").compare(enumName) == 0){ return Mber::AppCountType_INCLUSIVE; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::ProfileHistoryFilter& val) {
      return ProfileHistoryFilterToString(val);
    }
    Mber::ProfileHistoryFilter jsonToProfileHistoryFilter(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Profile").compare(enumName) == 0){ return Mber::ProfileHistoryFilter_Profile; }
      if(std::string("VirtualPurchase").compare(enumName) == 0){ return Mber::ProfileHistoryFilter_VirtualPurchase; }
      if(std::string("InvoicePurchase").compare(enumName) == 0){ return Mber::ProfileHistoryFilter_InvoicePurchase; }
      if(std::string("PasswordReset").compare(enumName) == 0){ return Mber::ProfileHistoryFilter_PasswordReset; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::TimeUnit& val) {
      return TimeUnitToString(val);
    }
    Mber::TimeUnit jsonToTimeUnit(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("SECONDS").compare(enumName) == 0){ return Mber::TimeUnit_SECONDS; }
      if(std::string("MINUTES").compare(enumName) == 0){ return Mber::TimeUnit_MINUTES; }
      if(std::string("HOURS").compare(enumName) == 0){ return Mber::TimeUnit_HOURS; }
      if(std::string("DAYS").compare(enumName) == 0){ return Mber::TimeUnit_DAYS; }
      if(std::string("MONTHS").compare(enumName) == 0){ return Mber::TimeUnit_MONTHS; }
      if(std::string("YEARS").compare(enumName) == 0){ return Mber::TimeUnit_YEARS; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::AffiliateStatus& val) {
      return AffiliateStatusToString(val);
    }
    Mber::AffiliateStatus jsonToAffiliateStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Activated").compare(enumName) == 0){ return Mber::AffiliateStatus_Activated; }
      if(std::string("Deleted").compare(enumName) == 0){ return Mber::AffiliateStatus_Deleted; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::CurrencyCode& val) {
      return CurrencyCodeToString(val);
    }
    Mber::CurrencyCode jsonToCurrencyCode(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("AED").compare(enumName) == 0){ return Mber::CurrencyCode_AED; }
      if(std::string("AFN").compare(enumName) == 0){ return Mber::CurrencyCode_AFN; }
      if(std::string("ALL").compare(enumName) == 0){ return Mber::CurrencyCode_ALL; }
      if(std::string("AMD").compare(enumName) == 0){ return Mber::CurrencyCode_AMD; }
      if(std::string("ANG").compare(enumName) == 0){ return Mber::CurrencyCode_ANG; }
      if(std::string("AOA").compare(enumName) == 0){ return Mber::CurrencyCode_AOA; }
      if(std::string("ARS").compare(enumName) == 0){ return Mber::CurrencyCode_ARS; }
      if(std::string("AUD").compare(enumName) == 0){ return Mber::CurrencyCode_AUD; }
      if(std::string("AWG").compare(enumName) == 0){ return Mber::CurrencyCode_AWG; }
      if(std::string("AZN").compare(enumName) == 0){ return Mber::CurrencyCode_AZN; }
      if(std::string("BAM").compare(enumName) == 0){ return Mber::CurrencyCode_BAM; }
      if(std::string("BBD").compare(enumName) == 0){ return Mber::CurrencyCode_BBD; }
      if(std::string("BDT").compare(enumName) == 0){ return Mber::CurrencyCode_BDT; }
      if(std::string("BGN").compare(enumName) == 0){ return Mber::CurrencyCode_BGN; }
      if(std::string("BHD").compare(enumName) == 0){ return Mber::CurrencyCode_BHD; }
      if(std::string("BIF").compare(enumName) == 0){ return Mber::CurrencyCode_BIF; }
      if(std::string("BMD").compare(enumName) == 0){ return Mber::CurrencyCode_BMD; }
      if(std::string("BND").compare(enumName) == 0){ return Mber::CurrencyCode_BND; }
      if(std::string("BOB").compare(enumName) == 0){ return Mber::CurrencyCode_BOB; }
      if(std::string("BRL").compare(enumName) == 0){ return Mber::CurrencyCode_BRL; }
      if(std::string("BSD").compare(enumName) == 0){ return Mber::CurrencyCode_BSD; }
      if(std::string("BTN").compare(enumName) == 0){ return Mber::CurrencyCode_BTN; }
      if(std::string("BWP").compare(enumName) == 0){ return Mber::CurrencyCode_BWP; }
      if(std::string("BYR").compare(enumName) == 0){ return Mber::CurrencyCode_BYR; }
      if(std::string("BZD").compare(enumName) == 0){ return Mber::CurrencyCode_BZD; }
      if(std::string("CAD").compare(enumName) == 0){ return Mber::CurrencyCode_CAD; }
      if(std::string("CDF").compare(enumName) == 0){ return Mber::CurrencyCode_CDF; }
      if(std::string("CHF").compare(enumName) == 0){ return Mber::CurrencyCode_CHF; }
      if(std::string("CLP").compare(enumName) == 0){ return Mber::CurrencyCode_CLP; }
      if(std::string("CNY").compare(enumName) == 0){ return Mber::CurrencyCode_CNY; }
      if(std::string("COP").compare(enumName) == 0){ return Mber::CurrencyCode_COP; }
      if(std::string("CRC").compare(enumName) == 0){ return Mber::CurrencyCode_CRC; }
      if(std::string("CUC").compare(enumName) == 0){ return Mber::CurrencyCode_CUC; }
      if(std::string("CUP").compare(enumName) == 0){ return Mber::CurrencyCode_CUP; }
      if(std::string("CVE").compare(enumName) == 0){ return Mber::CurrencyCode_CVE; }
      if(std::string("CZK").compare(enumName) == 0){ return Mber::CurrencyCode_CZK; }
      if(std::string("DJF").compare(enumName) == 0){ return Mber::CurrencyCode_DJF; }
      if(std::string("DKK").compare(enumName) == 0){ return Mber::CurrencyCode_DKK; }
      if(std::string("DOP").compare(enumName) == 0){ return Mber::CurrencyCode_DOP; }
      if(std::string("DZD").compare(enumName) == 0){ return Mber::CurrencyCode_DZD; }
      if(std::string("EGP").compare(enumName) == 0){ return Mber::CurrencyCode_EGP; }
      if(std::string("ERN").compare(enumName) == 0){ return Mber::CurrencyCode_ERN; }
      if(std::string("ETB").compare(enumName) == 0){ return Mber::CurrencyCode_ETB; }
      if(std::string("EUR").compare(enumName) == 0){ return Mber::CurrencyCode_EUR; }
      if(std::string("FJD").compare(enumName) == 0){ return Mber::CurrencyCode_FJD; }
      if(std::string("FKP").compare(enumName) == 0){ return Mber::CurrencyCode_FKP; }
      if(std::string("GBP").compare(enumName) == 0){ return Mber::CurrencyCode_GBP; }
      if(std::string("GEL").compare(enumName) == 0){ return Mber::CurrencyCode_GEL; }
      if(std::string("GGP").compare(enumName) == 0){ return Mber::CurrencyCode_GGP; }
      if(std::string("GHS").compare(enumName) == 0){ return Mber::CurrencyCode_GHS; }
      if(std::string("GIP").compare(enumName) == 0){ return Mber::CurrencyCode_GIP; }
      if(std::string("GMD").compare(enumName) == 0){ return Mber::CurrencyCode_GMD; }
      if(std::string("GNF").compare(enumName) == 0){ return Mber::CurrencyCode_GNF; }
      if(std::string("GTQ").compare(enumName) == 0){ return Mber::CurrencyCode_GTQ; }
      if(std::string("GYD").compare(enumName) == 0){ return Mber::CurrencyCode_GYD; }
      if(std::string("HKD").compare(enumName) == 0){ return Mber::CurrencyCode_HKD; }
      if(std::string("HNL").compare(enumName) == 0){ return Mber::CurrencyCode_HNL; }
      if(std::string("HRK").compare(enumName) == 0){ return Mber::CurrencyCode_HRK; }
      if(std::string("HTG").compare(enumName) == 0){ return Mber::CurrencyCode_HTG; }
      if(std::string("HUF").compare(enumName) == 0){ return Mber::CurrencyCode_HUF; }
      if(std::string("IDR").compare(enumName) == 0){ return Mber::CurrencyCode_IDR; }
      if(std::string("ILS").compare(enumName) == 0){ return Mber::CurrencyCode_ILS; }
      if(std::string("IMP").compare(enumName) == 0){ return Mber::CurrencyCode_IMP; }
      if(std::string("INR").compare(enumName) == 0){ return Mber::CurrencyCode_INR; }
      if(std::string("IQD").compare(enumName) == 0){ return Mber::CurrencyCode_IQD; }
      if(std::string("IRR").compare(enumName) == 0){ return Mber::CurrencyCode_IRR; }
      if(std::string("ISK").compare(enumName) == 0){ return Mber::CurrencyCode_ISK; }
      if(std::string("JEP").compare(enumName) == 0){ return Mber::CurrencyCode_JEP; }
      if(std::string("JMD").compare(enumName) == 0){ return Mber::CurrencyCode_JMD; }
      if(std::string("JOD").compare(enumName) == 0){ return Mber::CurrencyCode_JOD; }
      if(std::string("JPY").compare(enumName) == 0){ return Mber::CurrencyCode_JPY; }
      if(std::string("KES").compare(enumName) == 0){ return Mber::CurrencyCode_KES; }
      if(std::string("KGS").compare(enumName) == 0){ return Mber::CurrencyCode_KGS; }
      if(std::string("KHR").compare(enumName) == 0){ return Mber::CurrencyCode_KHR; }
      if(std::string("KMF").compare(enumName) == 0){ return Mber::CurrencyCode_KMF; }
      if(std::string("KPW").compare(enumName) == 0){ return Mber::CurrencyCode_KPW; }
      if(std::string("KRW").compare(enumName) == 0){ return Mber::CurrencyCode_KRW; }
      if(std::string("KWD").compare(enumName) == 0){ return Mber::CurrencyCode_KWD; }
      if(std::string("KYD").compare(enumName) == 0){ return Mber::CurrencyCode_KYD; }
      if(std::string("KZT").compare(enumName) == 0){ return Mber::CurrencyCode_KZT; }
      if(std::string("LAK").compare(enumName) == 0){ return Mber::CurrencyCode_LAK; }
      if(std::string("LBP").compare(enumName) == 0){ return Mber::CurrencyCode_LBP; }
      if(std::string("LKR").compare(enumName) == 0){ return Mber::CurrencyCode_LKR; }
      if(std::string("LRD").compare(enumName) == 0){ return Mber::CurrencyCode_LRD; }
      if(std::string("LSL").compare(enumName) == 0){ return Mber::CurrencyCode_LSL; }
      if(std::string("LTL").compare(enumName) == 0){ return Mber::CurrencyCode_LTL; }
      if(std::string("LVL").compare(enumName) == 0){ return Mber::CurrencyCode_LVL; }
      if(std::string("LYD").compare(enumName) == 0){ return Mber::CurrencyCode_LYD; }
      if(std::string("MAD").compare(enumName) == 0){ return Mber::CurrencyCode_MAD; }
      if(std::string("MDL").compare(enumName) == 0){ return Mber::CurrencyCode_MDL; }
      if(std::string("MGA").compare(enumName) == 0){ return Mber::CurrencyCode_MGA; }
      if(std::string("MKD").compare(enumName) == 0){ return Mber::CurrencyCode_MKD; }
      if(std::string("MMK").compare(enumName) == 0){ return Mber::CurrencyCode_MMK; }
      if(std::string("MNT").compare(enumName) == 0){ return Mber::CurrencyCode_MNT; }
      if(std::string("MOP").compare(enumName) == 0){ return Mber::CurrencyCode_MOP; }
      if(std::string("MRO").compare(enumName) == 0){ return Mber::CurrencyCode_MRO; }
      if(std::string("MUR").compare(enumName) == 0){ return Mber::CurrencyCode_MUR; }
      if(std::string("MVR").compare(enumName) == 0){ return Mber::CurrencyCode_MVR; }
      if(std::string("MWK").compare(enumName) == 0){ return Mber::CurrencyCode_MWK; }
      if(std::string("MXN").compare(enumName) == 0){ return Mber::CurrencyCode_MXN; }
      if(std::string("MYR").compare(enumName) == 0){ return Mber::CurrencyCode_MYR; }
      if(std::string("MZN").compare(enumName) == 0){ return Mber::CurrencyCode_MZN; }
      if(std::string("NAD").compare(enumName) == 0){ return Mber::CurrencyCode_NAD; }
      if(std::string("NGN").compare(enumName) == 0){ return Mber::CurrencyCode_NGN; }
      if(std::string("NIO").compare(enumName) == 0){ return Mber::CurrencyCode_NIO; }
      if(std::string("NOK").compare(enumName) == 0){ return Mber::CurrencyCode_NOK; }
      if(std::string("NPR").compare(enumName) == 0){ return Mber::CurrencyCode_NPR; }
      if(std::string("NZD").compare(enumName) == 0){ return Mber::CurrencyCode_NZD; }
      if(std::string("OMR").compare(enumName) == 0){ return Mber::CurrencyCode_OMR; }
      if(std::string("PAB").compare(enumName) == 0){ return Mber::CurrencyCode_PAB; }
      if(std::string("PEN").compare(enumName) == 0){ return Mber::CurrencyCode_PEN; }
      if(std::string("PGK").compare(enumName) == 0){ return Mber::CurrencyCode_PGK; }
      if(std::string("PHP").compare(enumName) == 0){ return Mber::CurrencyCode_PHP; }
      if(std::string("PKR").compare(enumName) == 0){ return Mber::CurrencyCode_PKR; }
      if(std::string("PLN").compare(enumName) == 0){ return Mber::CurrencyCode_PLN; }
      if(std::string("PYG").compare(enumName) == 0){ return Mber::CurrencyCode_PYG; }
      if(std::string("QAR").compare(enumName) == 0){ return Mber::CurrencyCode_QAR; }
      if(std::string("RON").compare(enumName) == 0){ return Mber::CurrencyCode_RON; }
      if(std::string("RSD").compare(enumName) == 0){ return Mber::CurrencyCode_RSD; }
      if(std::string("RUB").compare(enumName) == 0){ return Mber::CurrencyCode_RUB; }
      if(std::string("RWF").compare(enumName) == 0){ return Mber::CurrencyCode_RWF; }
      if(std::string("SAR").compare(enumName) == 0){ return Mber::CurrencyCode_SAR; }
      if(std::string("SBD").compare(enumName) == 0){ return Mber::CurrencyCode_SBD; }
      if(std::string("SCR").compare(enumName) == 0){ return Mber::CurrencyCode_SCR; }
      if(std::string("SDG").compare(enumName) == 0){ return Mber::CurrencyCode_SDG; }
      if(std::string("SEK").compare(enumName) == 0){ return Mber::CurrencyCode_SEK; }
      if(std::string("SGD").compare(enumName) == 0){ return Mber::CurrencyCode_SGD; }
      if(std::string("SHP").compare(enumName) == 0){ return Mber::CurrencyCode_SHP; }
      if(std::string("SLL").compare(enumName) == 0){ return Mber::CurrencyCode_SLL; }
      if(std::string("SOS").compare(enumName) == 0){ return Mber::CurrencyCode_SOS; }
      if(std::string("SRD").compare(enumName) == 0){ return Mber::CurrencyCode_SRD; }
      if(std::string("STD").compare(enumName) == 0){ return Mber::CurrencyCode_STD; }
      if(std::string("SVC").compare(enumName) == 0){ return Mber::CurrencyCode_SVC; }
      if(std::string("SYP").compare(enumName) == 0){ return Mber::CurrencyCode_SYP; }
      if(std::string("SZL").compare(enumName) == 0){ return Mber::CurrencyCode_SZL; }
      if(std::string("THB").compare(enumName) == 0){ return Mber::CurrencyCode_THB; }
      if(std::string("TJS").compare(enumName) == 0){ return Mber::CurrencyCode_TJS; }
      if(std::string("TMT").compare(enumName) == 0){ return Mber::CurrencyCode_TMT; }
      if(std::string("TND").compare(enumName) == 0){ return Mber::CurrencyCode_TND; }
      if(std::string("TOP").compare(enumName) == 0){ return Mber::CurrencyCode_TOP; }
      if(std::string("TRY").compare(enumName) == 0){ return Mber::CurrencyCode_TRY; }
      if(std::string("TTD").compare(enumName) == 0){ return Mber::CurrencyCode_TTD; }
      if(std::string("TVD").compare(enumName) == 0){ return Mber::CurrencyCode_TVD; }
      if(std::string("TWD").compare(enumName) == 0){ return Mber::CurrencyCode_TWD; }
      if(std::string("TZS").compare(enumName) == 0){ return Mber::CurrencyCode_TZS; }
      if(std::string("UAH").compare(enumName) == 0){ return Mber::CurrencyCode_UAH; }
      if(std::string("UGX").compare(enumName) == 0){ return Mber::CurrencyCode_UGX; }
      if(std::string("USD").compare(enumName) == 0){ return Mber::CurrencyCode_USD; }
      if(std::string("UYU").compare(enumName) == 0){ return Mber::CurrencyCode_UYU; }
      if(std::string("UZS").compare(enumName) == 0){ return Mber::CurrencyCode_UZS; }
      if(std::string("VEF").compare(enumName) == 0){ return Mber::CurrencyCode_VEF; }
      if(std::string("VND").compare(enumName) == 0){ return Mber::CurrencyCode_VND; }
      if(std::string("VUV").compare(enumName) == 0){ return Mber::CurrencyCode_VUV; }
      if(std::string("WST").compare(enumName) == 0){ return Mber::CurrencyCode_WST; }
      if(std::string("XAF").compare(enumName) == 0){ return Mber::CurrencyCode_XAF; }
      if(std::string("XCD").compare(enumName) == 0){ return Mber::CurrencyCode_XCD; }
      if(std::string("XDR").compare(enumName) == 0){ return Mber::CurrencyCode_XDR; }
      if(std::string("XOF").compare(enumName) == 0){ return Mber::CurrencyCode_XOF; }
      if(std::string("XPF").compare(enumName) == 0){ return Mber::CurrencyCode_XPF; }
      if(std::string("YER").compare(enumName) == 0){ return Mber::CurrencyCode_YER; }
      if(std::string("ZAR").compare(enumName) == 0){ return Mber::CurrencyCode_ZAR; }
      if(std::string("ZMW").compare(enumName) == 0){ return Mber::CurrencyCode_ZMW; }
      if(std::string("ZWD").compare(enumName) == 0){ return Mber::CurrencyCode_ZWD; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::DeductionRulePriority& val) {
      return DeductionRulePriorityToString(val);
    }
    Mber::DeductionRulePriority jsonToDeductionRulePriority(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Most").compare(enumName) == 0){ return Mber::DeductionRulePriority_Most; }
      if(std::string("Least").compare(enumName) == 0){ return Mber::DeductionRulePriority_Least; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::DeductionRuleProperty& val) {
      return DeductionRulePropertyToString(val);
    }
    Mber::DeductionRuleProperty jsonToDeductionRuleProperty(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Recent").compare(enumName) == 0){ return Mber::DeductionRuleProperty_Recent; }
      if(std::string("Expensive").compare(enumName) == 0){ return Mber::DeductionRuleProperty_Expensive; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::InvoiceItemStatus& val) {
      return InvoiceItemStatusToString(val);
    }
    Mber::InvoiceItemStatus jsonToInvoiceItemStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Waiting").compare(enumName) == 0){ return Mber::InvoiceItemStatus_Waiting; }
      if(std::string("Processing").compare(enumName) == 0){ return Mber::InvoiceItemStatus_Processing; }
      if(std::string("Failed").compare(enumName) == 0){ return Mber::InvoiceItemStatus_Failed; }
      if(std::string("Completed").compare(enumName) == 0){ return Mber::InvoiceItemStatus_Completed; }
      if(std::string("Refunded").compare(enumName) == 0){ return Mber::InvoiceItemStatus_Refunded; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::InvoiceSource& val) {
      return InvoiceSourceToString(val);
    }
    Mber::InvoiceSource jsonToInvoiceSource(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("OnMber").compare(enumName) == 0){ return Mber::InvoiceSource_OnMber; }
      if(std::string("OnSteam").compare(enumName) == 0){ return Mber::InvoiceSource_OnSteam; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::InvoiceStatus& val) {
      return InvoiceStatusToString(val);
    }
    Mber::InvoiceStatus jsonToInvoiceStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Open").compare(enumName) == 0){ return Mber::InvoiceStatus_Open; }
      if(std::string("Collecting").compare(enumName) == 0){ return Mber::InvoiceStatus_Collecting; }
      if(std::string("Fulfilling").compare(enumName) == 0){ return Mber::InvoiceStatus_Fulfilling; }
      if(std::string("Failed").compare(enumName) == 0){ return Mber::InvoiceStatus_Failed; }
      if(std::string("Completed").compare(enumName) == 0){ return Mber::InvoiceStatus_Completed; }
      if(std::string("Refunded").compare(enumName) == 0){ return Mber::InvoiceStatus_Refunded; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::RealMoneyTransactionProvider& val) {
      return RealMoneyTransactionProviderToString(val);
    }
    Mber::RealMoneyTransactionProvider jsonToRealMoneyTransactionProvider(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("AmazonFPS").compare(enumName) == 0){ return Mber::RealMoneyTransactionProvider_AmazonFPS; }
      if(std::string("Adyen").compare(enumName) == 0){ return Mber::RealMoneyTransactionProvider_Adyen; }
      if(std::string("Steam").compare(enumName) == 0){ return Mber::RealMoneyTransactionProvider_Steam; }
      if(std::string("BoaCompra").compare(enumName) == 0){ return Mber::RealMoneyTransactionProvider_BoaCompra; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::VirtualCurrencyStatus& val) {
      return VirtualCurrencyStatusToString(val);
    }
    Mber::VirtualCurrencyStatus jsonToVirtualCurrencyStatus(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Deleted").compare(enumName) == 0){ return Mber::VirtualCurrencyStatus_Deleted; }
      if(std::string("DisableSpending").compare(enumName) == 0){ return Mber::VirtualCurrencyStatus_DisableSpending; }
      if(std::string("DisableEarning").compare(enumName) == 0){ return Mber::VirtualCurrencyStatus_DisableEarning; }
      throw std::string("Unexpected enum value");
    };
    std::string toJson(const Mber::ServerState& val) {
      return ServerStateToString(val);
    }
    Mber::ServerState jsonToServerState(Var &json){
      std::string enumName = json.convert<std::string>();
      if(std::string("Unknown").compare(enumName) == 0){ return Mber::ServerState_Unknown; }
      if(std::string("Online").compare(enumName) == 0){ return Mber::ServerState_Online; }
      throw std::string("Unexpected enum value");
    };
    
    // Struct conversions
    Mber::CallingContext jsonToCallingContext(Var &json);
    Object CallingContextToJson(Mber::CallingContext &value);
    Mber::CustomCountField jsonToCustomCountField(Var &json);
    Object CustomCountFieldToJson(Mber::CustomCountField &value);
    Mber::EntityID jsonToEntityID(Var &json);
    Object EntityIDToJson(Mber::EntityID &value);
    Mber::EntityPointer jsonToEntityPointer(Var &json);
    Object EntityPointerToJson(Mber::EntityPointer &value);
    Mber::ErrorResult jsonToErrorResult(Var &json);
    Object ErrorResultToJson(Mber::ErrorResult &value);
    Mber::EventCluster jsonToEventCluster(Var &json);
    Object EventClusterToJson(Mber::EventCluster &value);
    Mber::EventEnvelope jsonToEventEnvelope(Var &json);
    Object EventEnvelopeToJson(Mber::EventEnvelope &value);
    Mber::Metric jsonToMetric(Var &json);
    Object MetricToJson(Mber::Metric &value);
    Mber::Permission jsonToPermission(Var &json);
    Object PermissionToJson(Mber::Permission &value);
    Mber::ProcessEvent jsonToProcessEvent(Var &json);
    Object ProcessEventToJson(Mber::ProcessEvent &value);
    Mber::ProcessList jsonToProcessList(Var &json);
    Object ProcessListToJson(Mber::ProcessList &value);
    Mber::Property jsonToProperty(Var &json);
    Object PropertyToJson(Mber::Property &value);
    Mber::Token jsonToToken(Var &json);
    Object TokenToJson(Mber::Token &value);
    Mber::Count jsonToCount(Var &json);
    Object CountToJson(Mber::Count &value);
    Mber::FuzzyValue jsonToFuzzyValue(Var &json);
    Object FuzzyValueToJson(Mber::FuzzyValue &value);
    Mber::PrefixValue jsonToPrefixValue(Var &json);
    Object PrefixValueToJson(Mber::PrefixValue &value);
    Mber::Query jsonToQuery(Var &json);
    Object QueryToJson(Mber::Query &value);
    Mber::QueryValue jsonToQueryValue(Var &json);
    Object QueryValueToJson(Mber::QueryValue &value);
    Mber::ReplicationOperation jsonToReplicationOperation(Var &json);
    Object ReplicationOperationToJson(Mber::ReplicationOperation &value);
    Mber::SchemaVersion jsonToSchemaVersion(Var &json);
    Object SchemaVersionToJson(Mber::SchemaVersion &value);
    Mber::Account jsonToAccount(Var &json);
    Object AccountToJson(Mber::Account &value);
    Mber::AnonymousUpgrade jsonToAnonymousUpgrade(Var &json);
    Object AnonymousUpgradeToJson(Mber::AnonymousUpgrade &value);
    Mber::Application jsonToApplication(Var &json);
    Object ApplicationToJson(Mber::Application &value);
    Mber::ApplicationShardAssignment jsonToApplicationShardAssignment(Var &json);
    Object ApplicationShardAssignmentToJson(Mber::ApplicationShardAssignment &value);
    Mber::AutomaticRoleAssignment jsonToAutomaticRoleAssignment(Var &json);
    Object AutomaticRoleAssignmentToJson(Mber::AutomaticRoleAssignment &value);
    Mber::Build jsonToBuild(Var &json);
    Object BuildToJson(Mber::Build &value);
    Mber::ForgotPassword jsonToForgotPassword(Var &json);
    Object ForgotPasswordToJson(Mber::ForgotPassword &value);
    Mber::ForgotUsername jsonToForgotUsername(Var &json);
    Object ForgotUsernameToJson(Mber::ForgotUsername &value);
    Mber::IPFilter jsonToIPFilter(Var &json);
    Object IPFilterToJson(Mber::IPFilter &value);
    Mber::Login jsonToLogin(Var &json);
    Object LoginToJson(Mber::Login &value);
    Mber::PasswordReset jsonToPasswordReset(Var &json);
    Object PasswordResetToJson(Mber::PasswordReset &value);
    Mber::Persona jsonToPersona(Var &json);
    Object PersonaToJson(Mber::Persona &value);
    Mber::Profile jsonToProfile(Var &json);
    Object ProfileToJson(Mber::Profile &value);
    Mber::ProfileAddress jsonToProfileAddress(Var &json);
    Object ProfileAddressToJson(Mber::ProfileAddress &value);
    Mber::ProfileGroup jsonToProfileGroup(Var &json);
    Object ProfileGroupToJson(Mber::ProfileGroup &value);
    Mber::ProfileReindex jsonToProfileReindex(Var &json);
    Object ProfileReindexToJson(Mber::ProfileReindex &value);
    Mber::Role jsonToRole(Var &json);
    Object RoleToJson(Mber::Role &value);
    Mber::RoleAssignment jsonToRoleAssignment(Var &json);
    Object RoleAssignmentToJson(Mber::RoleAssignment &value);
    Mber::SteamApplication jsonToSteamApplication(Var &json);
    Object SteamApplicationToJson(Mber::SteamApplication &value);
    Mber::SteamSyncEvent jsonToSteamSyncEvent(Var &json);
    Object SteamSyncEventToJson(Mber::SteamSyncEvent &value);
    Mber::AchievementDefinition jsonToAchievementDefinition(Var &json);
    Object AchievementDefinitionToJson(Mber::AchievementDefinition &value);
    Mber::AchievementInstance jsonToAchievementInstance(Var &json);
    Object AchievementInstanceToJson(Mber::AchievementInstance &value);
    Mber::AchievementPropertyDefinition jsonToAchievementPropertyDefinition(Var &json);
    Object AchievementPropertyDefinitionToJson(Mber::AchievementPropertyDefinition &value);
    Mber::Campaign jsonToCampaign(Var &json);
    Object CampaignToJson(Mber::Campaign &value);
    Mber::Definition jsonToDefinition(Var &json);
    Object DefinitionToJson(Mber::Definition &value);
    Mber::DigitalGoodDefinition jsonToDigitalGoodDefinition(Var &json);
    Object DigitalGoodDefinitionToJson(Mber::DigitalGoodDefinition &value);
    Mber::DigitalGoodInstance jsonToDigitalGoodInstance(Var &json);
    Object DigitalGoodInstanceToJson(Mber::DigitalGoodInstance &value);
    Mber::DigitalGoodPropertyDefinition jsonToDigitalGoodPropertyDefinition(Var &json);
    Object DigitalGoodPropertyDefinitionToJson(Mber::DigitalGoodPropertyDefinition &value);
    Mber::EarnedAchievements jsonToEarnedAchievements(Var &json);
    Object EarnedAchievementsToJson(Mber::EarnedAchievements &value);
    Mber::EntitlementInstance jsonToEntitlementInstance(Var &json);
    Object EntitlementInstanceToJson(Mber::EntitlementInstance &value);
    Mber::EntitlementPropertyDefinition jsonToEntitlementPropertyDefinition(Var &json);
    Object EntitlementPropertyDefinitionToJson(Mber::EntitlementPropertyDefinition &value);
    Mber::Keys jsonToKeys(Var &json);
    Object KeysToJson(Mber::Keys &value);
    Mber::RedemptionEvent jsonToRedemptionEvent(Var &json);
    Object RedemptionEventToJson(Mber::RedemptionEvent &value);
    Mber::Reward jsonToReward(Var &json);
    Object RewardToJson(Mber::Reward &value);
    Mber::CDNConfig jsonToCDNConfig(Var &json);
    Object CDNConfigToJson(Mber::CDNConfig &value);
    Mber::CDNSyncEvent jsonToCDNSyncEvent(Var &json);
    Object CDNSyncEventToJson(Mber::CDNSyncEvent &value);
    Mber::DataEvent jsonToDataEvent(Var &json);
    Object DataEventToJson(Mber::DataEvent &value);
    Mber::Directory jsonToDirectory(Var &json);
    Object DirectoryToJson(Mber::Directory &value);
    Mber::Document jsonToDocument(Var &json);
    Object DocumentToJson(Mber::Document &value);
    Mber::DocumentHistoryConfiguration jsonToDocumentHistoryConfiguration(Var &json);
    Object DocumentHistoryConfigurationToJson(Mber::DocumentHistoryConfiguration &value);
    Mber::DocumentReindex jsonToDocumentReindex(Var &json);
    Object DocumentReindexToJson(Mber::DocumentReindex &value);
    Mber::DocumentTemplate jsonToDocumentTemplate(Var &json);
    Object DocumentTemplateToJson(Mber::DocumentTemplate &value);
    Mber::DocumentVersion jsonToDocumentVersion(Var &json);
    Object DocumentVersionToJson(Mber::DocumentVersion &value);
    Mber::S3BucketConfig jsonToS3BucketConfig(Var &json);
    Object S3BucketConfigToJson(Mber::S3BucketConfig &value);
    Mber::TemplateField jsonToTemplateField(Var &json);
    Object TemplateFieldToJson(Mber::TemplateField &value);
    Mber::Provider jsonToProvider(Var &json);
    Object ProviderToJson(Mber::Provider &value);
    Mber::EventPointer jsonToEventPointer(Var &json);
    Object EventPointerToJson(Mber::EventPointer &value);
    Mber::ReconciledEvent jsonToReconciledEvent(Var &json);
    Object ReconciledEventToJson(Mber::ReconciledEvent &value);
    Mber::AvailableEvent jsonToAvailableEvent(Var &json);
    Object AvailableEventToJson(Mber::AvailableEvent &value);
    Mber::AdyenCallback jsonToAdyenCallback(Var &json);
    Object AdyenCallbackToJson(Mber::AdyenCallback &value);
    Mber::Affiliate jsonToAffiliate(Var &json);
    Object AffiliateToJson(Mber::Affiliate &value);
    Mber::BoaCompraCallback jsonToBoaCompraCallback(Var &json);
    Object BoaCompraCallbackToJson(Mber::BoaCompraCallback &value);
    Mber::Catalog jsonToCatalog(Var &json);
    Object CatalogToJson(Mber::Catalog &value);
    Mber::DeductionRule jsonToDeductionRule(Var &json);
    Object DeductionRuleToJson(Mber::DeductionRule &value);
    Mber::EntityTotal jsonToEntityTotal(Var &json);
    Object EntityTotalToJson(Mber::EntityTotal &value);
    Mber::Invoice jsonToInvoice(Var &json);
    Object InvoiceToJson(Mber::Invoice &value);
    Mber::InvoiceActualItem jsonToInvoiceActualItem(Var &json);
    Object InvoiceActualItemToJson(Mber::InvoiceActualItem &value);
    Mber::InvoiceExpectedItem jsonToInvoiceExpectedItem(Var &json);
    Object InvoiceExpectedItemToJson(Mber::InvoiceExpectedItem &value);
    Mber::InvoicePurchase jsonToInvoicePurchase(Var &json);
    Object InvoicePurchaseToJson(Mber::InvoicePurchase &value);
    Mber::InvoiceStatusSummary jsonToInvoiceStatusSummary(Var &json);
    Object InvoiceStatusSummaryToJson(Mber::InvoiceStatusSummary &value);
    Mber::MerchantReference jsonToMerchantReference(Var &json);
    Object MerchantReferenceToJson(Mber::MerchantReference &value);
    Mber::Offer jsonToOffer(Var &json);
    Object OfferToJson(Mber::Offer &value);
    Mber::OfferItem jsonToOfferItem(Var &json);
    Object OfferItemToJson(Mber::OfferItem &value);
    Mber::OfferPurchase jsonToOfferPurchase(Var &json);
    Object OfferPurchaseToJson(Mber::OfferPurchase &value);
    Mber::PaymentProvider jsonToPaymentProvider(Var &json);
    Object PaymentProviderToJson(Mber::PaymentProvider &value);
    Mber::RealCurrency jsonToRealCurrency(Var &json);
    Object RealCurrencyToJson(Mber::RealCurrency &value);
    Mber::RealMoneyInput jsonToRealMoneyInput(Var &json);
    Object RealMoneyInputToJson(Mber::RealMoneyInput &value);
    Mber::Referral jsonToReferral(Var &json);
    Object ReferralToJson(Mber::Referral &value);
    Mber::ReferralCount jsonToReferralCount(Var &json);
    Object ReferralCountToJson(Mber::ReferralCount &value);
    Mber::ReferralEntityTotals jsonToReferralEntityTotals(Var &json);
    Object ReferralEntityTotalsToJson(Mber::ReferralEntityTotals &value);
    Mber::Store jsonToStore(Var &json);
    Object StoreToJson(Mber::Store &value);
    Mber::VirtualCurrency jsonToVirtualCurrency(Var &json);
    Object VirtualCurrencyToJson(Mber::VirtualCurrency &value);
    Mber::VirtualCurrencyChange jsonToVirtualCurrencyChange(Var &json);
    Object VirtualCurrencyChangeToJson(Mber::VirtualCurrencyChange &value);
    Mber::VirtualPurchase jsonToVirtualPurchase(Var &json);
    Object VirtualPurchaseToJson(Mber::VirtualPurchase &value);
    Mber::Wallet jsonToWallet(Var &json);
    Object WalletToJson(Mber::Wallet &value);
    Mber::WalletLot jsonToWalletLot(Var &json);
    Object WalletLotToJson(Mber::WalletLot &value);
    Mber::WalletTotal jsonToWalletTotal(Var &json);
    Object WalletTotalToJson(Mber::WalletTotal &value);
    Mber::Heartbeat jsonToHeartbeat(Var &json);
    Object HeartbeatToJson(Mber::Heartbeat &value);
    Mber::Lobby jsonToLobby(Var &json);
    Object LobbyToJson(Mber::Lobby &value);
    Mber::Server jsonToServer(Var &json);
    Object ServerToJson(Mber::Server &value);
    Mber::DocumentMessage jsonToDocumentMessage(Var &json);
    Object DocumentMessageToJson(Mber::DocumentMessage &value);
    Mber::EmailConfig jsonToEmailConfig(Var &json);
    Object EmailConfigToJson(Mber::EmailConfig &value);
    Mber::EmailMessage jsonToEmailMessage(Var &json);
    Object EmailMessageToJson(Mber::EmailMessage &value);
    Mber::ReplacementProperty jsonToReplacementProperty(Var &json);
    Object ReplacementPropertyToJson(Mber::ReplacementProperty &value);
    Mber::StringMessage jsonToStringMessage(Var &json);
    Object StringMessageToJson(Mber::StringMessage &value);
    Mber::Group jsonToGroup(Var &json);
    Object GroupToJson(Mber::Group &value);
    Mber::CallingContext jsonToCallingContext(Var &json){
        Mber::CallingContext result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("correlationId");
        if( !next.isEmpty() ){
            result.correlationId = next.convert<std::string>();
        }
        next = obj->get("transactionId");
        if( !next.isEmpty() ){
            result.transactionId = next.convert<std::string>();
        }
        return result;
    };
    Object CallingContextToJson(Mber::CallingContext &value){
        Object result;        
        
        result.set("correlationId", toJson(value.correlationId));
        
        result.set("transactionId", toJson(value.transactionId));
        
        return result;
    };
    Mber::CustomCountField jsonToCustomCountField(Var &json){
        Mber::CustomCountField result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("count");
        if( !next.isEmpty() ){
            result.count = next;
        }
        next = obj->get("time");
        if( !next.isEmpty() ){
            // TODO: double-check type conversion here (uint64_t/UInt64/etc.)
            result.time = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.time = (UInt64)next;
        }
        return result;
    };
    Object CustomCountFieldToJson(Mber::CustomCountField &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("count", toJson(value.count));
        
        if( !value.time.isNull() ){
            result.set("time", toJson(*value.time));
        }
        
        return result;
    };
    Mber::EntityID jsonToEntityID(Var &json){
        Mber::EntityID result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = Mber::MberPtr<std::string>(new std::string);
            *result.id = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = Mber::MberPtr<std::string>(new std::string);
            *result.name = next.convert<std::string>();
        }
        return result;
    };
    Object EntityIDToJson(Mber::EntityID &value){
        Object result;        
        
        if( !value.id.isNull() ){
            result.set("id", toJson(*value.id));
        }
        
        if( !value.name.isNull() ){
            result.set("name", toJson(*value.name));
        }
        
        return result;
    };
    Mber::EntityPointer jsonToEntityPointer(Var &json){
        Mber::EntityPointer result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("entityId");
        if( !next.isEmpty() ){
            result.entityId = next.convert<std::string>();
        }
        next = obj->get("entityType");
        if( !next.isEmpty() ){
            result.entityType = jsonToEntityType(next);
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = Mber::MberPtr<std::string>(new std::string);
            *result.name = next.convert<std::string>();
        }
        return result;
    };
    Object EntityPointerToJson(Mber::EntityPointer &value){
        Object result;        
        
        result.set("entityId", toJson(value.entityId));
        
        result.set("entityType", toJson(value.entityType));
        
        if( !value.name.isNull() ){
            result.set("name", toJson(*value.name));
        }
        
        return result;
    };
    Mber::ErrorResult jsonToErrorResult(Var &json){
        Mber::ErrorResult result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("message");
        if( !next.isEmpty() ){
            result.message = next.convert<std::string>();
        }
        next = obj->get("fields");
        if( !next.isEmpty() ){
            result.fields = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.fields->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object ErrorResultToJson(Mber::ErrorResult &value){
        Object result;        
        
        result.set("message", toJson(value.message));
        
        if( !value.fields.isNull() ){
            result.set("fields", toJson(*value.fields));
        }
        
        return result;
    };
    Mber::EventCluster jsonToEventCluster(Var &json){
        Mber::EventCluster result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("eventName");
        if( !next.isEmpty() ){
            result.eventName = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = Mber::MberPtr<std::string>(new std::string);
            *result.applicationId = next.convert<std::string>();
        }
        next = obj->get("totals");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.totals.push_back(jsonToCount(next));
            }
        }
        next = obj->get("events");
        if( !next.isEmpty() ){
            result.events = Mber::MberPtr<std::list<Mber::EventEnvelope>>(new std::list<Mber::EventEnvelope>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.events->push_back(jsonToEventEnvelope(next));
            }
        }
        next = obj->get("counts");
        if( !next.isEmpty() ){
            result.counts = Mber::MberPtr<std::list<Mber::CustomCountField>>(new std::list<Mber::CustomCountField>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.counts->push_back(jsonToCustomCountField(next));
            }
        }
        return result;
    };
    Object EventClusterToJson(Mber::EventCluster &value){
        Object result;        
        
        result.set("eventName", toJson(value.eventName));
        
        if( !value.applicationId.isNull() ){
            result.set("applicationId", toJson(*value.applicationId));
        }
        
        for (std::list<Mber::Count>::const_iterator iterator = value.totals.begin(), end = value.totals.end(); iterator != end; ++iterator) {
            Mber::Count next = *iterator;
            result.set("totals", CountToJson(next));
        }
        
        if( !value.events.isNull() ){
            for (std::list<Mber::EventEnvelope>::const_iterator iterator = value.events->begin(), end = value.events->end(); iterator != end; ++iterator) {
                Mber::EventEnvelope next = *iterator;
                result.set("events", EventEnvelopeToJson(next));
            }
        }
        
        if( !value.counts.isNull() ){
            for (std::list<Mber::CustomCountField>::const_iterator iterator = value.counts->begin(), end = value.counts->end(); iterator != end; ++iterator) {
                Mber::CustomCountField next = *iterator;
                result.set("counts", CustomCountFieldToJson(next));
            }
        }
        
        return result;
    };
    Mber::EventEnvelope jsonToEventEnvelope(Var &json){
        Mber::EventEnvelope result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("callingContext");
        if( !next.isEmpty() ){
            result.callingContext = jsonToCallingContext(next);
        }
        next = obj->get("eventId");
        if( !next.isEmpty() ){
            result.eventId = next.convert<std::string>();
        }
        next = obj->get("eventType");
        if( !next.isEmpty() ){
            result.eventType = jsonToEventType(next);
        }
        next = obj->get("created");
        if( !next.isEmpty() ){
            result.created = (UInt64)next;
        }
        next = obj->get("decoderClass");
        if( !next.isEmpty() ){
            result.decoderClass = next.convert<std::string>();
        }
        next = obj->get("payload");
        if( !next.isEmpty() ){
            result.payload = next.convert<std::string>();
        }
        next = obj->get("version");
        if( !next.isEmpty() ){
            result.version = Mber::MberPtr<std::string>(new std::string);
            *result.version = next.convert<std::string>();
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::Property>>(new std::list<Mber::Property>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToProperty(next));
            }
        }
        return result;
    };
    Object EventEnvelopeToJson(Mber::EventEnvelope &value){
        Object result;        
        
        result.set("callingContext", CallingContextToJson(value.callingContext));
        
        result.set("eventId", toJson(value.eventId));
        
        result.set("eventType", toJson(value.eventType));
        
        result.set("created", toJson(value.created));
        
        result.set("decoderClass", toJson(value.decoderClass));
        
        result.set("payload", toJson(value.payload));
        
        if( !value.version.isNull() ){
            result.set("version", toJson(*value.version));
        }
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::Property>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::Property next = *iterator;
                result.set("properties", PropertyToJson(next));
            }
        }
        
        return result;
    };
    Mber::Metric jsonToMetric(Var &json){
        Mber::Metric result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("objectName");
        if( !next.isEmpty() ){
            result.objectName = next.convert<std::string>();
        }
        next = obj->get("metricType");
        if( !next.isEmpty() ){
            result.metricType = jsonToMetricType(next);
        }
        next = obj->get("metricValue");
        if( !next.isEmpty() ){
            result.metricValue = Mber::MberPtr<std::string>(new std::string);
            *result.metricValue = next.convert<std::string>();
        }
        next = obj->get("metricEventName");
        if( !next.isEmpty() ){
            result.metricEventName = next.convert<std::string>();
        }
        next = obj->get("metricCount");
        if( !next.isEmpty() ){
            result.metricCount = next;
        }
        return result;
    };
    Object MetricToJson(Mber::Metric &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("objectName", toJson(value.objectName));
        
        result.set("metricType", toJson(value.metricType));
        
        if( !value.metricValue.isNull() ){
            result.set("metricValue", toJson(*value.metricValue));
        }
        
        result.set("metricEventName", toJson(value.metricEventName));
        
        result.set("metricCount", toJson(value.metricCount));
        
        return result;
    };
    Mber::Permission jsonToPermission(Var &json){
        Mber::Permission result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("entityType");
        if( !next.isEmpty() ){
            result.entityType = jsonToEntityType(next);
        }
        next = obj->get("permissions");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.permissions.push_back(jsonToPermissionType(next));
            }
        }
        next = obj->get("selfOnly");
        if( !next.isEmpty() ){
            result.selfOnly = Mber::MberPtr<bool>(new bool);
            *result.selfOnly = next;
        }
        next = obj->get("allowPrivate");
        if( !next.isEmpty() ){
            result.allowPrivate = Mber::MberPtr<bool>(new bool);
            *result.allowPrivate = next;
        }
        return result;
    };
    Object PermissionToJson(Mber::Permission &value){
        Object result;        
        
        result.set("entityType", toJson(value.entityType));
        
        result.set("permissions", toJson(value.permissions));
        
        if( !value.selfOnly.isNull() ){
            result.set("selfOnly", toJson(*value.selfOnly));
        }
        
        if( !value.allowPrivate.isNull() ){
            result.set("allowPrivate", toJson(*value.allowPrivate));
        }
        
        return result;
    };
    Mber::ProcessEvent jsonToProcessEvent(Var &json){
        Mber::ProcessEvent result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("group");
        if( !next.isEmpty() ){
            result.group = next.convert<std::string>();
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::Property>>(new std::list<Mber::Property>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToProperty(next));
            }
        }
        next = obj->get("infinite");
        if( !next.isEmpty() ){
            result.infinite = Mber::MberPtr<bool>(new bool);
            *result.infinite = next;
        }
        return result;
    };
    Object ProcessEventToJson(Mber::ProcessEvent &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("group", toJson(value.group));
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::Property>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::Property next = *iterator;
                result.set("properties", PropertyToJson(next));
            }
        }
        
        if( !value.infinite.isNull() ){
            result.set("infinite", toJson(*value.infinite));
        }
        
        return result;
    };
    Mber::ProcessList jsonToProcessList(Var &json){
        Mber::ProcessList result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("processesAdded");
        if( !next.isEmpty() ){
            result.processesAdded = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.processesAdded->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("processesRemoved");
        if( !next.isEmpty() ){
            result.processesRemoved = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.processesRemoved->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("serverId");
        if( !next.isEmpty() ){
            result.serverId = Mber::MberPtr<std::string>(new std::string);
            *result.serverId = next.convert<std::string>();
        }
        return result;
    };
    Object ProcessListToJson(Mber::ProcessList &value){
        Object result;        
        
        if( !value.processesAdded.isNull() ){
            result.set("processesAdded", toJson(*value.processesAdded));
        }
        
        if( !value.processesRemoved.isNull() ){
            result.set("processesRemoved", toJson(*value.processesRemoved));
        }
        
        if( !value.serverId.isNull() ){
            result.set("serverId", toJson(*value.serverId));
        }
        
        return result;
    };
    Mber::Property jsonToProperty(Var &json){
        Mber::Property result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("key");
        if( !next.isEmpty() ){
            result.key = next.convert<std::string>();
        }
        next = obj->get("value");
        if( !next.isEmpty() ){
            result.value = next.convert<std::string>();
        }
        return result;
    };
    Object PropertyToJson(Mber::Property &value){
        Object result;        
        
        result.set("key", toJson(value.key));
        
        result.set("value", toJson(value.value));
        
        return result;
    };
    Mber::Token jsonToToken(Var &json){
        Mber::Token result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("tokenType");
        if( !next.isEmpty() ){
            result.tokenType = jsonToTokenType(next);
        }
        next = obj->get("expires");
        if( !next.isEmpty() ){
            result.expires = (UInt64)next;
        }
        next = obj->get("clientRedirectUri");
        if( !next.isEmpty() ){
            result.clientRedirectUri = Mber::MberPtr<std::string>(new std::string);
            *result.clientRedirectUri = next.convert<std::string>();
        }
        next = obj->get("accountId");
        if( !next.isEmpty() ){
            result.accountId = Mber::MberPtr<std::string>(new std::string);
            *result.accountId = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = Mber::MberPtr<std::string>(new std::string);
            *result.profileId = next.convert<std::string>();
        }
        next = obj->get("permissions");
        if( !next.isEmpty() ){
            result.permissions = Mber::MberPtr<std::list<Mber::Permission>>(new std::list<Mber::Permission>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.permissions->push_back(jsonToPermission(next));
            }
        }
        next = obj->get("shard");
        if( !next.isEmpty() ){
            result.shard = next;
        }
        next = obj->get("masterShard");
        if( !next.isEmpty() ){
            result.masterShard = next;
        }
        next = obj->get("email");
        if( !next.isEmpty() ){
            result.email = Mber::MberPtr<std::string>(new std::string);
            *result.email = next.convert<std::string>();
        }
        next = obj->get("displayname");
        if( !next.isEmpty() ){
            result.displayname = Mber::MberPtr<std::string>(new std::string);
            *result.displayname = next.convert<std::string>();
        }
        next = obj->get("clientType");
        if( !next.isEmpty() ){
            result.clientType = Mber::MberPtr<std::string>(new std::string);
            *result.clientType = next.convert<std::string>();
        }
        next = obj->get("clientProfile");
        if( !next.isEmpty() ){
            result.clientProfile = Mber::MberPtr<std::string>(new std::string);
            *result.clientProfile = next.convert<std::string>();
        }
        next = obj->get("userSource");
        if( !next.isEmpty() ){
            result.userSource = next.convert<std::string>();
        }
        next = obj->get("grantType");
        if( !next.isEmpty() ){
            result.grantType = Mber::MberPtr<std::string>(new std::string);
            *result.grantType = next.convert<std::string>();
        }
        next = obj->get("createdFrom");
        if( !next.isEmpty() ){
            result.createdFrom = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.createdFrom->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("refreshToken");
        if( !next.isEmpty() ){
            result.refreshToken = Mber::MberPtr<std::string>(new std::string);
            *result.refreshToken = next.convert<std::string>();
        }
        next = obj->get("created");
        if( !next.isEmpty() ){
            result.created = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.created = (UInt64)next;
        }
        next = obj->get("steamId");
        if( !next.isEmpty() ){
            result.steamId = Mber::MberPtr<std::string>(new std::string);
            *result.steamId = next.convert<std::string>();
        }
        next = obj->get("ip");
        if( !next.isEmpty() ){
            result.ip = Mber::MberPtr<std::string>(new std::string);
            *result.ip = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = jsonToEntityID(next);
        }
        return result;
    };
    Object TokenToJson(Mber::Token &value){
        Object result;        
        
        result.set("id", toJson(value.id));
        
        result.set("tokenType", toJson(value.tokenType));
        
        result.set("expires", toJson(value.expires));
        
        if( !value.clientRedirectUri.isNull() ){
            result.set("clientRedirectUri", toJson(*value.clientRedirectUri));
        }
        
        if( !value.accountId.isNull() ){
            result.set("accountId", toJson(*value.accountId));
        }
        
        if( !value.profileId.isNull() ){
            result.set("profileId", toJson(*value.profileId));
        }
        
        if( !value.permissions.isNull() ){
            for (std::list<Mber::Permission>::const_iterator iterator = value.permissions->begin(), end = value.permissions->end(); iterator != end; ++iterator) {
                Mber::Permission next = *iterator;
                result.set("permissions", PermissionToJson(next));
            }
        }
        
        result.set("shard", toJson(value.shard));
        
        result.set("masterShard", toJson(value.masterShard));
        
        if( !value.email.isNull() ){
            result.set("email", toJson(*value.email));
        }
        
        if( !value.displayname.isNull() ){
            result.set("displayname", toJson(*value.displayname));
        }
        
        if( !value.clientType.isNull() ){
            result.set("clientType", toJson(*value.clientType));
        }
        
        if( !value.clientProfile.isNull() ){
            result.set("clientProfile", toJson(*value.clientProfile));
        }
        
        result.set("userSource", toJson(value.userSource));
        
        if( !value.grantType.isNull() ){
            result.set("grantType", toJson(*value.grantType));
        }
        
        if( !value.createdFrom.isNull() ){
            result.set("createdFrom", toJson(*value.createdFrom));
        }
        
        if( !value.refreshToken.isNull() ){
            result.set("refreshToken", toJson(*value.refreshToken));
        }
        
        if( !value.created.isNull() ){
            result.set("created", toJson(*value.created));
        }
        
        if( !value.steamId.isNull() ){
            result.set("steamId", toJson(*value.steamId));
        }
        
        if( !value.ip.isNull() ){
            result.set("ip", toJson(*value.ip));
        }
        
        result.set("applicationId", EntityIDToJson(value.applicationId));
        
        return result;
    };
    Mber::Count jsonToCount(Var &json){
        Mber::Count result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("time");
        if( !next.isEmpty() ){
            result.time = (UInt64)next;
        }
        next = obj->get("count");
        if( !next.isEmpty() ){
            result.count = next;
        }
        return result;
    };
    Object CountToJson(Mber::Count &value){
        Object result;        
        
        result.set("time", toJson(value.time));
        
        result.set("count", toJson(value.count));
        
        return result;
    };
    Mber::FuzzyValue jsonToFuzzyValue(Var &json){
        Mber::FuzzyValue result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("value");
        if( !next.isEmpty() ){
            result.value = next.convert<std::string>();
        }
        next = obj->get("minSimilarity");
        if( !next.isEmpty() ){
            result.minSimilarity = Mber::MberPtr<double>(new double);
            *result.minSimilarity = next;
        }
        return result;
    };
    Object FuzzyValueToJson(Mber::FuzzyValue &value){
        Object result;        
        
        result.set("value", toJson(value.value));
        
        if( !value.minSimilarity.isNull() ){
            result.set("minSimilarity", toJson(*value.minSimilarity));
        }
        
        return result;
    };
    Mber::PrefixValue jsonToPrefixValue(Var &json){
        Mber::PrefixValue result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("value");
        if( !next.isEmpty() ){
            result.value = next.convert<std::string>();
        }
        return result;
    };
    Object PrefixValueToJson(Mber::PrefixValue &value){
        Object result;        
        
        result.set("value", toJson(value.value));
        
        return result;
    };
    Mber::Query jsonToQuery(Var &json){
        Mber::Query result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("field");
        if( !next.isEmpty() ){
            result.field = next.convert<std::string>();
        }
        next = obj->get("from");
        if( !next.isEmpty() ){
            result.from = Mber::MberPtr<double>(new double);
            *result.from = next;
        }
        next = obj->get("to");
        if( !next.isEmpty() ){
            result.to = Mber::MberPtr<double>(new double);
            *result.to = next;
        }
        next = obj->get("in");
        if( !next.isEmpty() ){
            result.in = Mber::MberPtr<std::list<Mber::QueryValue>>(new std::list<Mber::QueryValue>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.in->push_back(jsonToQueryValue(next));
            }
        }
        next = obj->get("and");
        if( !next.isEmpty() ){
            result.thisAnd = Mber::MberPtr<std::list<Mber::Query>>(new std::list<Mber::Query>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.thisAnd->push_back(jsonToQuery(next));
            }
        }
        next = obj->get("or");
        if( !next.isEmpty() ){
            result.thisOr = Mber::MberPtr<std::list<Mber::Query>>(new std::list<Mber::Query>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.thisOr->push_back(jsonToQuery(next));
            }
        }
        next = obj->get("prefix");
        if( !next.isEmpty() ){
            result.prefix = Mber::MberPtr<Mber::PrefixValue>(new Mber::PrefixValue);
            *result.prefix = jsonToPrefixValue(next);
        }
        next = obj->get("like");
        if( !next.isEmpty() ){
            result.like = Mber::MberPtr<Mber::FuzzyValue>(new Mber::FuzzyValue);
            *result.like = jsonToFuzzyValue(next);
        }
        return result;
    };
    Object QueryToJson(Mber::Query &value){
        Object result;        
        
        result.set("field", toJson(value.field));
        
        if( !value.from.isNull() ){
            result.set("from", toJson(*value.from));
        }
        
        if( !value.to.isNull() ){
            result.set("to", toJson(*value.to));
        }
        
        if( !value.in.isNull() ){
            for (std::list<Mber::QueryValue>::const_iterator iterator = value.in->begin(), end = value.in->end(); iterator != end; ++iterator) {
                Mber::QueryValue next = *iterator;
                result.set("in", QueryValueToJson(next));
            }
        }
        
        if( !value.thisAnd.isNull() ){
            for (std::list<Mber::Query>::const_iterator iterator = value.thisAnd->begin(), end = value.thisAnd->end(); iterator != end; ++iterator) {
                Mber::Query next = *iterator;
                result.set("and", QueryToJson(next));
            }
        }
        
        if( !value.thisOr.isNull() ){
            for (std::list<Mber::Query>::const_iterator iterator = value.thisOr->begin(), end = value.thisOr->end(); iterator != end; ++iterator) {
                Mber::Query next = *iterator;
                result.set("or", QueryToJson(next));
            }
        }
        
        if( !value.prefix.isNull() ){
            result.set("prefix", PrefixValueToJson(*value.prefix));
        }
        
        if( !value.like.isNull() ){
            result.set("like", FuzzyValueToJson(*value.like));
        }
        
        return result;
    };
    Mber::QueryValue jsonToQueryValue(Var &json){
        Mber::QueryValue result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("stringValue");
        if( !next.isEmpty() ){
            result.stringValue = Mber::MberPtr<std::string>(new std::string);
            *result.stringValue = next.convert<std::string>();
        }
        next = obj->get("booleanValue");
        if( !next.isEmpty() ){
            result.booleanValue = Mber::MberPtr<bool>(new bool);
            *result.booleanValue = next;
        }
        next = obj->get("numberValue");
        if( !next.isEmpty() ){
            result.numberValue = Mber::MberPtr<double>(new double);
            *result.numberValue = next;
        }
        return result;
    };
    Object QueryValueToJson(Mber::QueryValue &value){
        Object result;        
        
        if( !value.stringValue.isNull() ){
            result.set("stringValue", toJson(*value.stringValue));
        }
        
        if( !value.booleanValue.isNull() ){
            result.set("booleanValue", toJson(*value.booleanValue));
        }
        
        if( !value.numberValue.isNull() ){
            result.set("numberValue", toJson(*value.numberValue));
        }
        
        return result;
    };
    Mber::ReplicationOperation jsonToReplicationOperation(Var &json){
        Mber::ReplicationOperation result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("masterShardId");
        if( !next.isEmpty() ){
            result.masterShardId = next;
        }
        next = obj->get("schema");
        if( !next.isEmpty() ){
            result.schema = next.convert<std::string>();
        }
        next = obj->get("sql");
        if( !next.isEmpty() ){
            result.sql = next.convert<std::string>();
        }
        return result;
    };
    Object ReplicationOperationToJson(Mber::ReplicationOperation &value){
        Object result;        
        
        result.set("id", toJson(value.id));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("masterShardId", toJson(value.masterShardId));
        
        result.set("schema", toJson(value.schema));
        
        result.set("sql", toJson(value.sql));
        
        return result;
    };
    Mber::SchemaVersion jsonToSchemaVersion(Var &json){
        Mber::SchemaVersion result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("version");
        if( !next.isEmpty() ){
            result.version = next.convert<std::string>();
        }
        next = obj->get("comment");
        if( !next.isEmpty() ){
            result.comment = next.convert<std::string>();
        }
        next = obj->get("created");
        if( !next.isEmpty() ){
            result.created = (UInt64)next;
        }
        next = obj->get("updated");
        if( !next.isEmpty() ){
            result.updated = (UInt64)next;
        }
        next = obj->get("shard");
        if( !next.isEmpty() ){
            result.shard = next;
        }
        return result;
    };
    Object SchemaVersionToJson(Mber::SchemaVersion &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("version", toJson(value.version));
        
        result.set("comment", toJson(value.comment));
        
        result.set("created", toJson(value.created));
        
        result.set("updated", toJson(value.updated));
        
        result.set("shard", toJson(value.shard));
        
        return result;
    };
    Mber::Account jsonToAccount(Var &json){
        Mber::Account result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("accountId");
        if( !next.isEmpty() ){
            result.accountId = next.convert<std::string>();
        }
        next = obj->get("masterProfileId");
        if( !next.isEmpty() ){
            result.masterProfileId = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.status.push_back(jsonToAccountStatus(next));
            }
        }
        next = obj->get("email");
        if( !next.isEmpty() ){
            result.email = Mber::MberPtr<std::string>(new std::string);
            *result.email = next.convert<std::string>();
        }
        next = obj->get("password");
        if( !next.isEmpty() ){
            result.password = Mber::MberPtr<std::string>(new std::string);
            *result.password = next.convert<std::string>();
        }
        next = obj->get("dateOfBirth");
        if( !next.isEmpty() ){
            result.dateOfBirth = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.dateOfBirth = (UInt64)next;
        }
        next = obj->get("region");
        if( !next.isEmpty() ){
            result.region = Mber::MberPtr<Mber::Region>(new Mber::Region);
            *result.region = jsonToRegion(next);
        }
        next = obj->get("username");
        if( !next.isEmpty() ){
            result.username = Mber::MberPtr<std::string>(new std::string);
            *result.username = next.convert<std::string>();
        }
        next = obj->get("displayname");
        if( !next.isEmpty() ){
            result.displayname = Mber::MberPtr<std::string>(new std::string);
            *result.displayname = next.convert<std::string>();
        }
        next = obj->get("sourceApplication");
        if( !next.isEmpty() ){
            result.sourceApplication = Mber::MberPtr<std::string>(new std::string);
            *result.sourceApplication = next.convert<std::string>();
        }
        next = obj->get("sourceReferredUrl");
        if( !next.isEmpty() ){
            result.sourceReferredUrl = Mber::MberPtr<std::string>(new std::string);
            *result.sourceReferredUrl = next.convert<std::string>();
        }
        next = obj->get("forcePasswordReset");
        if( !next.isEmpty() ){
            result.forcePasswordReset = Mber::MberPtr<bool>(new bool);
            *result.forcePasswordReset = next;
        }
        next = obj->get("steamId");
        if( !next.isEmpty() ){
            result.steamId = Mber::MberPtr<long>(new long);
            *result.steamId = next;
        }
        next = obj->get("referrer");
        if( !next.isEmpty() ){
            result.referrer = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.referrer = jsonToEntityPointer(next);
        }
        return result;
    };
    Object AccountToJson(Mber::Account &value){
        Object result;        
        
        result.set("accountId", toJson(value.accountId));
        
        result.set("masterProfileId", toJson(value.masterProfileId));
        
        result.set("status", toJson(value.status));
        
        if( !value.email.isNull() ){
            result.set("email", toJson(*value.email));
        }
        
        if( !value.password.isNull() ){
            result.set("password", toJson(*value.password));
        }
        
        if( !value.dateOfBirth.isNull() ){
            result.set("dateOfBirth", toJson(*value.dateOfBirth));
        }
        
        if( !value.region.isNull() ){
            result.set("region", toJson(*value.region));
        }
        
        if( !value.username.isNull() ){
            result.set("username", toJson(*value.username));
        }
        
        if( !value.displayname.isNull() ){
            result.set("displayname", toJson(*value.displayname));
        }
        
        if( !value.sourceApplication.isNull() ){
            result.set("sourceApplication", toJson(*value.sourceApplication));
        }
        
        if( !value.sourceReferredUrl.isNull() ){
            result.set("sourceReferredUrl", toJson(*value.sourceReferredUrl));
        }
        
        if( !value.forcePasswordReset.isNull() ){
            result.set("forcePasswordReset", toJson(*value.forcePasswordReset));
        }
        
        if( !value.steamId.isNull() ){
            result.set("steamId", toJson(*value.steamId));
        }
        
        if( !value.referrer.isNull() ){
            result.set("referrer", EntityPointerToJson(*value.referrer));
        }
        
        return result;
    };
    Mber::AnonymousUpgrade jsonToAnonymousUpgrade(Var &json){
        Mber::AnonymousUpgrade result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("displayName");
        if( !next.isEmpty() ){
            result.displayName = next.convert<std::string>();
        }
        next = obj->get("email");
        if( !next.isEmpty() ){
            result.email = next.convert<std::string>();
        }
        next = obj->get("readToken");
        if( !next.isEmpty() ){
            result.readToken = next.convert<std::string>();
        }
        next = obj->get("updateToken");
        if( !next.isEmpty() ){
            result.updateToken = next.convert<std::string>();
        }
        next = obj->get("applicationContext");
        if( !next.isEmpty() ){
            result.applicationContext = next.convert<std::string>();
        }
        return result;
    };
    Object AnonymousUpgradeToJson(Mber::AnonymousUpgrade &value){
        Object result;        
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("displayName", toJson(value.displayName));
        
        result.set("email", toJson(value.email));
        
        result.set("readToken", toJson(value.readToken));
        
        result.set("updateToken", toJson(value.updateToken));
        
        result.set("applicationContext", toJson(value.applicationContext));
        
        return result;
    };
    Mber::Application jsonToApplication(Var &json){
        Mber::Application result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("alias");
        if( !next.isEmpty() ){
            result.alias = Mber::MberPtr<std::string>(new std::string);
            *result.alias = next.convert<std::string>();
        }
        next = obj->get("parent");
        if( !next.isEmpty() ){
            result.parent = Mber::MberPtr<std::string>(new std::string);
            *result.parent = next.convert<std::string>();
        }
        next = obj->get("redirectUri");
        if( !next.isEmpty() ){
            result.redirectUri = Mber::MberPtr<std::string>(new std::string);
            *result.redirectUri = next.convert<std::string>();
        }
        next = obj->get("version");
        if( !next.isEmpty() ){
            result.version = Mber::MberPtr<std::string>(new std::string);
            *result.version = next.convert<std::string>();
        }
        next = obj->get("creator");
        if( !next.isEmpty() ){
            result.creator = Mber::MberPtr<std::string>(new std::string);
            *result.creator = next.convert<std::string>();
        }
        next = obj->get("applications");
        if( !next.isEmpty() ){
            result.applications = Mber::MberPtr<std::list<Mber::Application>>(new std::list<Mber::Application>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.applications->push_back(jsonToApplication(next));
            }
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = Mber::MberPtr<Mber::ApplicationStatus>(new Mber::ApplicationStatus);
            *result.status = jsonToApplicationStatus(next);
        }
        next = obj->get("maxPersonas");
        if( !next.isEmpty() ){
            result.maxPersonas = next;
        }
        next = obj->get("uniquePersonas");
        if( !next.isEmpty() ){
            result.uniquePersonas = next;
        }
        return result;
    };
    Object ApplicationToJson(Mber::Application &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("name", toJson(value.name));
        
        if( !value.alias.isNull() ){
            result.set("alias", toJson(*value.alias));
        }
        
        if( !value.parent.isNull() ){
            result.set("parent", toJson(*value.parent));
        }
        
        if( !value.redirectUri.isNull() ){
            result.set("redirectUri", toJson(*value.redirectUri));
        }
        
        if( !value.version.isNull() ){
            result.set("version", toJson(*value.version));
        }
        
        if( !value.creator.isNull() ){
            result.set("creator", toJson(*value.creator));
        }
        
        if( !value.applications.isNull() ){
            for (std::list<Mber::Application>::const_iterator iterator = value.applications->begin(), end = value.applications->end(); iterator != end; ++iterator) {
                Mber::Application next = *iterator;
                result.set("applications", ApplicationToJson(next));
            }
        }
        
        if( !value.status.isNull() ){
            result.set("status", toJson(*value.status));
        }
        
        result.set("maxPersonas", toJson(value.maxPersonas));
        
        result.set("uniquePersonas", toJson(value.uniquePersonas));
        
        return result;
    };
    Mber::ApplicationShardAssignment jsonToApplicationShardAssignment(Var &json){
        Mber::ApplicationShardAssignment result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("shard");
        if( !next.isEmpty() ){
            result.shard = next;
        }
        next = obj->get("processedCount");
        if( !next.isEmpty() ){
            result.processedCount = Mber::MberPtr<int>(new int);
            *result.processedCount = next;
        }
        return result;
    };
    Object ApplicationShardAssignmentToJson(Mber::ApplicationShardAssignment &value){
        Object result;        
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("shard", toJson(value.shard));
        
        if( !value.processedCount.isNull() ){
            result.set("processedCount", toJson(*value.processedCount));
        }
        
        return result;
    };
    Mber::AutomaticRoleAssignment jsonToAutomaticRoleAssignment(Var &json){
        Mber::AutomaticRoleAssignment result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("entityType");
        if( !next.isEmpty() ){
            result.entityType = jsonToEntityType(next);
        }
        next = obj->get("role");
        if( !next.isEmpty() ){
            result.role = next.convert<std::string>();
        }
        return result;
    };
    Object AutomaticRoleAssignmentToJson(Mber::AutomaticRoleAssignment &value){
        Object result;        
        
        result.set("entityType", toJson(value.entityType));
        
        result.set("role", toJson(value.role));
        
        return result;
    };
    Mber::Build jsonToBuild(Var &json){
        Mber::Build result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("number");
        if( !next.isEmpty() ){
            result.number = next.convert<std::string>();
        }
        next = obj->get("commit");
        if( !next.isEmpty() ){
            result.commit = next.convert<std::string>();
        }
        next = obj->get("schemas");
        if( !next.isEmpty() ){
            result.schemas = Mber::MberPtr<std::list<Mber::SchemaVersion>>(new std::list<Mber::SchemaVersion>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.schemas->push_back(jsonToSchemaVersion(next));
            }
        }
        return result;
    };
    Object BuildToJson(Mber::Build &value){
        Object result;        
        
        result.set("number", toJson(value.number));
        
        result.set("commit", toJson(value.commit));
        
        if( !value.schemas.isNull() ){
            for (std::list<Mber::SchemaVersion>::const_iterator iterator = value.schemas->begin(), end = value.schemas->end(); iterator != end; ++iterator) {
                Mber::SchemaVersion next = *iterator;
                result.set("schemas", SchemaVersionToJson(next));
            }
        }
        
        return result;
    };
    Mber::ForgotPassword jsonToForgotPassword(Var &json){
        Mber::ForgotPassword result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("username");
        if( !next.isEmpty() ){
            result.username = next.convert<std::string>();
        }
        next = obj->get("displayname");
        if( !next.isEmpty() ){
            result.displayname = next.convert<std::string>();
        }
        next = obj->get("email");
        if( !next.isEmpty() ){
            result.email = next.convert<std::string>();
        }
        next = obj->get("tokenId");
        if( !next.isEmpty() ){
            result.tokenId = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = jsonToEntityID(next);
        }
        return result;
    };
    Object ForgotPasswordToJson(Mber::ForgotPassword &value){
        Object result;        
        
        result.set("username", toJson(value.username));
        
        result.set("displayname", toJson(value.displayname));
        
        result.set("email", toJson(value.email));
        
        result.set("tokenId", toJson(value.tokenId));
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("applicationId", EntityIDToJson(value.applicationId));
        
        return result;
    };
    Mber::ForgotUsername jsonToForgotUsername(Var &json){
        Mber::ForgotUsername result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("email");
        if( !next.isEmpty() ){
            result.email = next.convert<std::string>();
        }
        next = obj->get("username");
        if( !next.isEmpty() ){
            result.username = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("displayname");
        if( !next.isEmpty() ){
            result.displayname = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        return result;
    };
    Object ForgotUsernameToJson(Mber::ForgotUsername &value){
        Object result;        
        
        result.set("email", toJson(value.email));
        
        result.set("username", toJson(value.username));
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("displayname", toJson(value.displayname));
        
        result.set("applicationId", toJson(value.applicationId));
        
        return result;
    };
    Mber::IPFilter jsonToIPFilter(Var &json){
        Mber::IPFilter result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("ipAddresses");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.ipAddresses.push_back(next.convert<std::string>());
            }
        }
        next = obj->get("role");
        if( !next.isEmpty() ){
            result.role = jsonToEntityID(next);
        }
        return result;
    };
    Object IPFilterToJson(Mber::IPFilter &value){
        Object result;        
        
        result.set("ipAddresses", toJson(value.ipAddresses));
        
        result.set("role", EntityIDToJson(value.role));
        
        return result;
    };
    Mber::Login jsonToLogin(Var &json){
        Mber::Login result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = jsonToStatus(next);
        }
        next = obj->get("token");
        if( !next.isEmpty() ){
            result.token = Mber::MberPtr<Mber::Token>(new Mber::Token);
            *result.token = jsonToToken(next);
        }
        next = obj->get("requested_scope");
        if( !next.isEmpty() ){
            result.requested_scope = Mber::MberPtr<std::string>(new std::string);
            *result.requested_scope = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = Mber::MberPtr<std::string>(new std::string);
            *result.applicationId = next.convert<std::string>();
        }
        next = obj->get("username");
        if( !next.isEmpty() ){
            result.username = Mber::MberPtr<std::string>(new std::string);
            *result.username = next.convert<std::string>();
        }
        next = obj->get("redirect_uri");
        if( !next.isEmpty() ){
            result.redirect_uri = Mber::MberPtr<std::string>(new std::string);
            *result.redirect_uri = next.convert<std::string>();
        }
        next = obj->get("userSource");
        if( !next.isEmpty() ){
            result.userSource = Mber::MberPtr<std::string>(new std::string);
            *result.userSource = next.convert<std::string>();
        }
        return result;
    };
    Object LoginToJson(Mber::Login &value){
        Object result;        
        
        result.set("status", toJson(value.status));
        
        if( !value.token.isNull() ){
            result.set("token", TokenToJson(*value.token));
        }
        
        if( !value.requested_scope.isNull() ){
            result.set("requested_scope", toJson(*value.requested_scope));
        }
        
        if( !value.applicationId.isNull() ){
            result.set("applicationId", toJson(*value.applicationId));
        }
        
        if( !value.username.isNull() ){
            result.set("username", toJson(*value.username));
        }
        
        if( !value.redirect_uri.isNull() ){
            result.set("redirect_uri", toJson(*value.redirect_uri));
        }
        
        if( !value.userSource.isNull() ){
            result.set("userSource", toJson(*value.userSource));
        }
        
        return result;
    };
    Mber::PasswordReset jsonToPasswordReset(Var &json){
        Mber::PasswordReset result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("tokenId");
        if( !next.isEmpty() ){
            result.tokenId = next.convert<std::string>();
        }
        next = obj->get("applicationContext");
        if( !next.isEmpty() ){
            result.applicationContext = next.convert<std::string>();
        }
        return result;
    };
    Object PasswordResetToJson(Mber::PasswordReset &value){
        Object result;        
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("tokenId", toJson(value.tokenId));
        
        result.set("applicationContext", toJson(value.applicationContext));
        
        return result;
    };
    Mber::Persona jsonToPersona(Var &json){
        Mber::Persona result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("personaId");
        if( !next.isEmpty() ){
            result.personaId = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("displayname");
        if( !next.isEmpty() ){
            result.displayname = next.convert<std::string>();
        }
        return result;
    };
    Object PersonaToJson(Mber::Persona &value){
        Object result;        
        
        result.set("personaId", toJson(value.personaId));
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("displayname", toJson(value.displayname));
        
        return result;
    };
    Mber::Profile jsonToProfile(Var &json){
        Mber::Profile result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("accountId");
        if( !next.isEmpty() ){
            result.accountId = next.convert<std::string>();
        }
        next = obj->get("region");
        if( !next.isEmpty() ){
            result.region = Mber::MberPtr<Mber::Region>(new Mber::Region);
            *result.region = jsonToRegion(next);
        }
        next = obj->get("username");
        if( !next.isEmpty() ){
            result.username = Mber::MberPtr<std::string>(new std::string);
            *result.username = next.convert<std::string>();
        }
        next = obj->get("displayname");
        if( !next.isEmpty() ){
            result.displayname = next.convert<std::string>();
        }
        next = obj->get("email");
        if( !next.isEmpty() ){
            result.email = Mber::MberPtr<std::string>(new std::string);
            *result.email = next.convert<std::string>();
        }
        next = obj->get("unvalidated_email");
        if( !next.isEmpty() ){
            result.unvalidated_email = Mber::MberPtr<std::string>(new std::string);
            *result.unvalidated_email = next.convert<std::string>();
        }
        next = obj->get("dateOfBirth");
        if( !next.isEmpty() ){
            result.dateOfBirth = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.dateOfBirth = (UInt64)next;
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = Mber::MberPtr<std::list<Mber::ProfileStatus>>(new std::list<Mber::ProfileStatus>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.status->push_back(jsonToProfileStatus(next));
            }
        }
        next = obj->get("sourceApplication");
        if( !next.isEmpty() ){
            result.sourceApplication = Mber::MberPtr<std::string>(new std::string);
            *result.sourceApplication = next.convert<std::string>();
        }
        next = obj->get("sourceReferredUrl");
        if( !next.isEmpty() ){
            result.sourceReferredUrl = Mber::MberPtr<std::string>(new std::string);
            *result.sourceReferredUrl = next.convert<std::string>();
        }
        next = obj->get("steamId");
        if( !next.isEmpty() ){
            result.steamId = Mber::MberPtr<std::string>(new std::string);
            *result.steamId = next.convert<std::string>();
        }
        next = obj->get("referrer");
        if( !next.isEmpty() ){
            result.referrer = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.referrer = jsonToEntityPointer(next);
        }
        return result;
    };
    Object ProfileToJson(Mber::Profile &value){
        Object result;        
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("accountId", toJson(value.accountId));
        
        if( !value.region.isNull() ){
            result.set("region", toJson(*value.region));
        }
        
        if( !value.username.isNull() ){
            result.set("username", toJson(*value.username));
        }
        
        result.set("displayname", toJson(value.displayname));
        
        if( !value.email.isNull() ){
            result.set("email", toJson(*value.email));
        }
        
        if( !value.unvalidated_email.isNull() ){
            result.set("unvalidated_email", toJson(*value.unvalidated_email));
        }
        
        if( !value.dateOfBirth.isNull() ){
            result.set("dateOfBirth", toJson(*value.dateOfBirth));
        }
        
        if( !value.status.isNull() ){
            result.set("status", toJson(*value.status));
        }
        
        if( !value.sourceApplication.isNull() ){
            result.set("sourceApplication", toJson(*value.sourceApplication));
        }
        
        if( !value.sourceReferredUrl.isNull() ){
            result.set("sourceReferredUrl", toJson(*value.sourceReferredUrl));
        }
        
        if( !value.steamId.isNull() ){
            result.set("steamId", toJson(*value.steamId));
        }
        
        if( !value.referrer.isNull() ){
            result.set("referrer", EntityPointerToJson(*value.referrer));
        }
        
        return result;
    };
    Mber::ProfileAddress jsonToProfileAddress(Var &json){
        Mber::ProfileAddress result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("addressType");
        if( !next.isEmpty() ){
            result.addressType = jsonToProfileAddressType(next);
        }
        next = obj->get("houseNumberOrName");
        if( !next.isEmpty() ){
            result.houseNumberOrName = Mber::MberPtr<std::string>(new std::string);
            *result.houseNumberOrName = next.convert<std::string>();
        }
        next = obj->get("street");
        if( !next.isEmpty() ){
            result.street = Mber::MberPtr<std::string>(new std::string);
            *result.street = next.convert<std::string>();
        }
        next = obj->get("city");
        if( !next.isEmpty() ){
            result.city = Mber::MberPtr<std::string>(new std::string);
            *result.city = next.convert<std::string>();
        }
        next = obj->get("postalCode");
        if( !next.isEmpty() ){
            result.postalCode = Mber::MberPtr<std::string>(new std::string);
            *result.postalCode = next.convert<std::string>();
        }
        next = obj->get("stateOrProvince");
        if( !next.isEmpty() ){
            result.stateOrProvince = Mber::MberPtr<std::string>(new std::string);
            *result.stateOrProvince = next.convert<std::string>();
        }
        next = obj->get("country");
        if( !next.isEmpty() ){
            result.country = Mber::MberPtr<std::string>(new std::string);
            *result.country = next.convert<std::string>();
        }
        return result;
    };
    Object ProfileAddressToJson(Mber::ProfileAddress &value){
        Object result;        
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("addressType", toJson(value.addressType));
        
        if( !value.houseNumberOrName.isNull() ){
            result.set("houseNumberOrName", toJson(*value.houseNumberOrName));
        }
        
        if( !value.street.isNull() ){
            result.set("street", toJson(*value.street));
        }
        
        if( !value.city.isNull() ){
            result.set("city", toJson(*value.city));
        }
        
        if( !value.postalCode.isNull() ){
            result.set("postalCode", toJson(*value.postalCode));
        }
        
        if( !value.stateOrProvince.isNull() ){
            result.set("stateOrProvince", toJson(*value.stateOrProvince));
        }
        
        if( !value.country.isNull() ){
            result.set("country", toJson(*value.country));
        }
        
        return result;
    };
    Mber::ProfileGroup jsonToProfileGroup(Var &json){
        Mber::ProfileGroup result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("alias");
        if( !next.isEmpty() ){
            result.alias = Mber::MberPtr<std::string>(new std::string);
            *result.alias = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("members");
        if( !next.isEmpty() ){
            result.members = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.members->push_back(jsonToEntityPointer(next));
            }
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.status.push_back(jsonToProfileGroupStatus(next));
            }
        }
        next = obj->get("size");
        if( !next.isEmpty() ){
            result.size = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.size = (UInt64)next;
        }
        return result;
    };
    Object ProfileGroupToJson(Mber::ProfileGroup &value){
        Object result;        
        
        result.set("id", toJson(value.id));
        
        result.set("name", toJson(value.name));
        
        if( !value.alias.isNull() ){
            result.set("alias", toJson(*value.alias));
        }
        
        result.set("applicationId", toJson(value.applicationId));
        
        if( !value.members.isNull() ){
            for (std::list<Mber::EntityPointer>::const_iterator iterator = value.members->begin(), end = value.members->end(); iterator != end; ++iterator) {
                Mber::EntityPointer next = *iterator;
                result.set("members", EntityPointerToJson(next));
            }
        }
        
        result.set("status", toJson(value.status));
        
        if( !value.size.isNull() ){
            result.set("size", toJson(*value.size));
        }
        
        return result;
    };
    Mber::ProfileReindex jsonToProfileReindex(Var &json){
        Mber::ProfileReindex result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("deleteIndex");
        if( !next.isEmpty() ){
            result.deleteIndex = Mber::MberPtr<bool>(new bool);
            *result.deleteIndex = next;
        }
        return result;
    };
    Object ProfileReindexToJson(Mber::ProfileReindex &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        if( !value.deleteIndex.isNull() ){
            result.set("deleteIndex", toJson(*value.deleteIndex));
        }
        
        return result;
    };
    Mber::Role jsonToRole(Var &json){
        Mber::Role result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("parent");
        if( !next.isEmpty() ){
            result.parent = jsonToEntityPointer(next);
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("active");
        if( !next.isEmpty() ){
            result.active = next;
        }
        next = obj->get("automatic");
        if( !next.isEmpty() ){
            result.automatic = next;
        }
        next = obj->get("cascading");
        if( !next.isEmpty() ){
            result.cascading = next;
        }
        next = obj->get("permissions");
        if( !next.isEmpty() ){
            result.permissions = Mber::MberPtr<std::list<Mber::Permission>>(new std::list<Mber::Permission>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.permissions->push_back(jsonToPermission(next));
            }
        }
        next = obj->get("automaticAssignments");
        if( !next.isEmpty() ){
            result.automaticAssignments = Mber::MberPtr<std::list<Mber::AutomaticRoleAssignment>>(new std::list<Mber::AutomaticRoleAssignment>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.automaticAssignments->push_back(jsonToAutomaticRoleAssignment(next));
            }
        }
        next = obj->get("negative");
        if( !next.isEmpty() ){
            result.negative = next;
        }
        return result;
    };
    Object RoleToJson(Mber::Role &value){
        Object result;        
        
        result.set("id", toJson(value.id));
        
        result.set("parent", EntityPointerToJson(value.parent));
        
        result.set("name", toJson(value.name));
        
        result.set("active", toJson(value.active));
        
        result.set("automatic", toJson(value.automatic));
        
        result.set("cascading", toJson(value.cascading));
        
        if( !value.permissions.isNull() ){
            for (std::list<Mber::Permission>::const_iterator iterator = value.permissions->begin(), end = value.permissions->end(); iterator != end; ++iterator) {
                Mber::Permission next = *iterator;
                result.set("permissions", PermissionToJson(next));
            }
        }
        
        if( !value.automaticAssignments.isNull() ){
            for (std::list<Mber::AutomaticRoleAssignment>::const_iterator iterator = value.automaticAssignments->begin(), end = value.automaticAssignments->end(); iterator != end; ++iterator) {
                Mber::AutomaticRoleAssignment next = *iterator;
                result.set("automaticAssignments", AutomaticRoleAssignmentToJson(next));
            }
        }
        
        result.set("negative", toJson(value.negative));
        
        return result;
    };
    Mber::RoleAssignment jsonToRoleAssignment(Var &json){
        Mber::RoleAssignment result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("roleId");
        if( !next.isEmpty() ){
            result.roleId = next.convert<std::string>();
        }
        next = obj->get("context");
        if( !next.isEmpty() ){
            result.context = jsonToEntityPointer(next);
        }
        next = obj->get("recipient");
        if( !next.isEmpty() ){
            result.recipient = jsonToEntityPointer(next);
        }
        return result;
    };
    Object RoleAssignmentToJson(Mber::RoleAssignment &value){
        Object result;        
        
        result.set("roleId", toJson(value.roleId));
        
        result.set("context", EntityPointerToJson(value.context));
        
        result.set("recipient", EntityPointerToJson(value.recipient));
        
        return result;
    };
    Mber::SteamApplication jsonToSteamApplication(Var &json){
        Mber::SteamApplication result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("steamApplicationId");
        if( !next.isEmpty() ){
            result.steamApplicationId = next;
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("webAPIKey");
        if( !next.isEmpty() ){
            result.webAPIKey = next.convert<std::string>();
        }
        next = obj->get("packageId");
        if( !next.isEmpty() ){
            result.packageId = Mber::MberPtr<int>(new int);
            *result.packageId = next;
        }
        return result;
    };
    Object SteamApplicationToJson(Mber::SteamApplication &value){
        Object result;        
        
        result.set("id", toJson(value.id));
        
        result.set("steamApplicationId", toJson(value.steamApplicationId));
        
        result.set("name", toJson(value.name));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("webAPIKey", toJson(value.webAPIKey));
        
        if( !value.packageId.isNull() ){
            result.set("packageId", toJson(*value.packageId));
        }
        
        return result;
    };
    Mber::SteamSyncEvent jsonToSteamSyncEvent(Var &json){
        Mber::SteamSyncEvent result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = Mber::MberPtr<std::string>(new std::string);
            *result.profileId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = Mber::MberPtr<std::string>(new std::string);
            *result.applicationId = next.convert<std::string>();
        }
        next = obj->get("steamId");
        if( !next.isEmpty() ){
            result.steamId = Mber::MberPtr<long>(new long);
            *result.steamId = next;
        }
        next = obj->get("previousSteamId");
        if( !next.isEmpty() ){
            result.previousSteamId = Mber::MberPtr<long>(new long);
            *result.previousSteamId = next;
        }
        return result;
    };
    Object SteamSyncEventToJson(Mber::SteamSyncEvent &value){
        Object result;        
        
        if( !value.profileId.isNull() ){
            result.set("profileId", toJson(*value.profileId));
        }
        
        if( !value.applicationId.isNull() ){
            result.set("applicationId", toJson(*value.applicationId));
        }
        
        if( !value.steamId.isNull() ){
            result.set("steamId", toJson(*value.steamId));
        }
        
        if( !value.previousSteamId.isNull() ){
            result.set("previousSteamId", toJson(*value.previousSteamId));
        }
        
        return result;
    };
    Mber::AchievementDefinition jsonToAchievementDefinition(Var &json){
        Mber::AchievementDefinition result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("definitionId");
        if( !next.isEmpty() ){
            result.definitionId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.status.push_back(jsonToDefinitionStatus(next));
            }
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = next.convert<std::string>();
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::AchievementPropertyDefinition>>(new std::list<Mber::AchievementPropertyDefinition>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToAchievementPropertyDefinition(next));
            }
        }
        next = obj->get("categories");
        if( !next.isEmpty() ){
            result.categories = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.categories->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object AchievementDefinitionToJson(Mber::AchievementDefinition &value){
        Object result;        
        
        result.set("definitionId", toJson(value.definitionId));
        
        result.set("name", toJson(value.name));
        
        result.set("status", toJson(value.status));
        
        result.set("scope", toJson(value.scope));
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::AchievementPropertyDefinition>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::AchievementPropertyDefinition next = *iterator;
                result.set("properties", AchievementPropertyDefinitionToJson(next));
            }
        }
        
        if( !value.categories.isNull() ){
            result.set("categories", toJson(*value.categories));
        }
        
        return result;
    };
    Mber::AchievementInstance jsonToAchievementInstance(Var &json){
        Mber::AchievementInstance result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("definitionId");
        if( !next.isEmpty() ){
            result.definitionId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = Mber::MberPtr<std::string>(new std::string);
            *result.name = next.convert<std::string>();
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = Mber::MberPtr<std::string>(new std::string);
            *result.scope = next.convert<std::string>();
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::Property>>(new std::list<Mber::Property>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToProperty(next));
            }
        }
        next = obj->get("categories");
        if( !next.isEmpty() ){
            result.categories = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.categories->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object AchievementInstanceToJson(Mber::AchievementInstance &value){
        Object result;        
        
        result.set("id", toJson(value.id));
        
        result.set("definitionId", toJson(value.definitionId));
        
        if( !value.name.isNull() ){
            result.set("name", toJson(*value.name));
        }
        
        if( !value.scope.isNull() ){
            result.set("scope", toJson(*value.scope));
        }
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::Property>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::Property next = *iterator;
                result.set("properties", PropertyToJson(next));
            }
        }
        
        if( !value.categories.isNull() ){
            result.set("categories", toJson(*value.categories));
        }
        
        return result;
    };
    Mber::AchievementPropertyDefinition jsonToAchievementPropertyDefinition(Var &json){
        Mber::AchievementPropertyDefinition result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("onEarn");
        if( !next.isEmpty() ){
            result.onEarn = jsonToEntitlementPropertyAvailability(next);
        }
        next = obj->get("defaultValue");
        if( !next.isEmpty() ){
            result.defaultValue = Mber::MberPtr<std::string>(new std::string);
            *result.defaultValue = next.convert<std::string>();
        }
        return result;
    };
    Object AchievementPropertyDefinitionToJson(Mber::AchievementPropertyDefinition &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("onEarn", toJson(value.onEarn));
        
        if( !value.defaultValue.isNull() ){
            result.set("defaultValue", toJson(*value.defaultValue));
        }
        
        return result;
    };
    Mber::Campaign jsonToCampaign(Var &json){
        Mber::Campaign result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("campaignId");
        if( !next.isEmpty() ){
            result.campaignId = jsonToEntityID(next);
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = jsonToEntityID(next);
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("digitalGood");
        if( !next.isEmpty() ){
            result.digitalGood = jsonToEntityID(next);
        }
        next = obj->get("description");
        if( !next.isEmpty() ){
            result.description = Mber::MberPtr<std::string>(new std::string);
            *result.description = next.convert<std::string>();
        }
        next = obj->get("url");
        if( !next.isEmpty() ){
            result.url = Mber::MberPtr<std::string>(new std::string);
            *result.url = next.convert<std::string>();
        }
        next = obj->get("invalidWords");
        if( !next.isEmpty() ){
            result.invalidWords = Mber::MberPtr<Mber::EntityID>(new Mber::EntityID);
            *result.invalidWords = jsonToEntityID(next);
        }
        return result;
    };
    Object CampaignToJson(Mber::Campaign &value){
        Object result;        
        
        result.set("campaignId", EntityIDToJson(value.campaignId));
        
        result.set("applicationId", EntityIDToJson(value.applicationId));
        
        result.set("name", toJson(value.name));
        
        result.set("digitalGood", EntityIDToJson(value.digitalGood));
        
        if( !value.description.isNull() ){
            result.set("description", toJson(*value.description));
        }
        
        if( !value.url.isNull() ){
            result.set("url", toJson(*value.url));
        }
        
        if( !value.invalidWords.isNull() ){
            result.set("invalidWords", EntityIDToJson(*value.invalidWords));
        }
        
        return result;
    };
    Mber::Definition jsonToDefinition(Var &json){
        Mber::Definition result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("definitionId");
        if( !next.isEmpty() ){
            result.definitionId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.status.push_back(jsonToDefinitionStatus(next));
            }
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = next.convert<std::string>();
        }
        next = obj->get("autoClaim");
        if( !next.isEmpty() ){
            result.autoClaim = next;
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::EntitlementPropertyDefinition>>(new std::list<Mber::EntitlementPropertyDefinition>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToEntitlementPropertyDefinition(next));
            }
        }
        next = obj->get("truncated");
        if( !next.isEmpty() ){
            result.truncated = Mber::MberPtr<bool>(new bool);
            *result.truncated = next;
        }
        next = obj->get("setStatuses");
        if( !next.isEmpty() ){
            result.setStatuses = Mber::MberPtr<std::list<Mber::DefinitionStatus>>(new std::list<Mber::DefinitionStatus>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.setStatuses->push_back(jsonToDefinitionStatus(next));
            }
        }
        next = obj->get("unsetStatuses");
        if( !next.isEmpty() ){
            result.unsetStatuses = Mber::MberPtr<std::list<Mber::DefinitionStatus>>(new std::list<Mber::DefinitionStatus>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.unsetStatuses->push_back(jsonToDefinitionStatus(next));
            }
        }
        next = obj->get("redeemableFor");
        if( !next.isEmpty() ){
            result.redeemableFor = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.redeemableFor->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("ttl");
        if( !next.isEmpty() ){
            result.ttl = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.ttl = (UInt64)next;
        }
        next = obj->get("selfGrantCount");
        if( !next.isEmpty() ){
            result.selfGrantCount = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.selfGrantCount = (UInt64)next;
        }
        next = obj->get("emailOnGrant");
        if( !next.isEmpty() ){
            result.emailOnGrant = Mber::MberPtr<bool>(new bool);
            *result.emailOnGrant = next;
        }
        next = obj->get("emailOnClaim");
        if( !next.isEmpty() ){
            result.emailOnClaim = Mber::MberPtr<bool>(new bool);
            *result.emailOnClaim = next;
        }
        next = obj->get("redemptionRewards");
        if( !next.isEmpty() ){
            result.redemptionRewards = Mber::MberPtr<std::list<Mber::Reward>>(new std::list<Mber::Reward>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.redemptionRewards->push_back(jsonToReward(next));
            }
        }
        next = obj->get("categories");
        if( !next.isEmpty() ){
            result.categories = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.categories->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object DefinitionToJson(Mber::Definition &value){
        Object result;        
        
        result.set("definitionId", toJson(value.definitionId));
        
        result.set("name", toJson(value.name));
        
        result.set("status", toJson(value.status));
        
        result.set("scope", toJson(value.scope));
        
        result.set("autoClaim", toJson(value.autoClaim));
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::EntitlementPropertyDefinition>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::EntitlementPropertyDefinition next = *iterator;
                result.set("properties", EntitlementPropertyDefinitionToJson(next));
            }
        }
        
        if( !value.truncated.isNull() ){
            result.set("truncated", toJson(*value.truncated));
        }
        
        if( !value.setStatuses.isNull() ){
            result.set("setStatuses", toJson(*value.setStatuses));
        }
        
        if( !value.unsetStatuses.isNull() ){
            result.set("unsetStatuses", toJson(*value.unsetStatuses));
        }
        
        if( !value.redeemableFor.isNull() ){
            result.set("redeemableFor", toJson(*value.redeemableFor));
        }
        
        if( !value.ttl.isNull() ){
            result.set("ttl", toJson(*value.ttl));
        }
        
        if( !value.selfGrantCount.isNull() ){
            result.set("selfGrantCount", toJson(*value.selfGrantCount));
        }
        
        if( !value.emailOnGrant.isNull() ){
            result.set("emailOnGrant", toJson(*value.emailOnGrant));
        }
        
        if( !value.emailOnClaim.isNull() ){
            result.set("emailOnClaim", toJson(*value.emailOnClaim));
        }
        
        if( !value.redemptionRewards.isNull() ){
            for (std::list<Mber::Reward>::const_iterator iterator = value.redemptionRewards->begin(), end = value.redemptionRewards->end(); iterator != end; ++iterator) {
                Mber::Reward next = *iterator;
                result.set("redemptionRewards", RewardToJson(next));
            }
        }
        
        if( !value.categories.isNull() ){
            result.set("categories", toJson(*value.categories));
        }
        
        return result;
    };
    Mber::DigitalGoodDefinition jsonToDigitalGoodDefinition(Var &json){
        Mber::DigitalGoodDefinition result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("definitionId");
        if( !next.isEmpty() ){
            result.definitionId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.status.push_back(jsonToDefinitionStatus(next));
            }
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = next.convert<std::string>();
        }
        next = obj->get("documentId");
        if( !next.isEmpty() ){
            result.documentId = Mber::MberPtr<std::string>(new std::string);
            *result.documentId = next.convert<std::string>();
        }
        next = obj->get("autoClaim");
        if( !next.isEmpty() ){
            result.autoClaim = next;
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::DigitalGoodPropertyDefinition>>(new std::list<Mber::DigitalGoodPropertyDefinition>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToDigitalGoodPropertyDefinition(next));
            }
        }
        next = obj->get("redeemableFor");
        if( !next.isEmpty() ){
            result.redeemableFor = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.redeemableFor->push_back(jsonToEntityPointer(next));
            }
        }
        next = obj->get("ttl");
        if( !next.isEmpty() ){
            result.ttl = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.ttl = (UInt64)next;
        }
        next = obj->get("selfGrantCount");
        if( !next.isEmpty() ){
            result.selfGrantCount = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.selfGrantCount = (UInt64)next;
        }
        next = obj->get("emailOnGrant");
        if( !next.isEmpty() ){
            result.emailOnGrant = Mber::MberPtr<bool>(new bool);
            *result.emailOnGrant = next;
        }
        next = obj->get("emailOnClaim");
        if( !next.isEmpty() ){
            result.emailOnClaim = Mber::MberPtr<bool>(new bool);
            *result.emailOnClaim = next;
        }
        next = obj->get("redemptionRewards");
        if( !next.isEmpty() ){
            result.redemptionRewards = Mber::MberPtr<std::list<Mber::Reward>>(new std::list<Mber::Reward>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.redemptionRewards->push_back(jsonToReward(next));
            }
        }
        next = obj->get("categories");
        if( !next.isEmpty() ){
            result.categories = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.categories->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object DigitalGoodDefinitionToJson(Mber::DigitalGoodDefinition &value){
        Object result;        
        
        result.set("definitionId", toJson(value.definitionId));
        
        result.set("name", toJson(value.name));
        
        result.set("status", toJson(value.status));
        
        result.set("scope", toJson(value.scope));
        
        if( !value.documentId.isNull() ){
            result.set("documentId", toJson(*value.documentId));
        }
        
        result.set("autoClaim", toJson(value.autoClaim));
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::DigitalGoodPropertyDefinition>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::DigitalGoodPropertyDefinition next = *iterator;
                result.set("properties", DigitalGoodPropertyDefinitionToJson(next));
            }
        }
        
        if( !value.redeemableFor.isNull() ){
            for (std::list<Mber::EntityPointer>::const_iterator iterator = value.redeemableFor->begin(), end = value.redeemableFor->end(); iterator != end; ++iterator) {
                Mber::EntityPointer next = *iterator;
                result.set("redeemableFor", EntityPointerToJson(next));
            }
        }
        
        if( !value.ttl.isNull() ){
            result.set("ttl", toJson(*value.ttl));
        }
        
        if( !value.selfGrantCount.isNull() ){
            result.set("selfGrantCount", toJson(*value.selfGrantCount));
        }
        
        if( !value.emailOnGrant.isNull() ){
            result.set("emailOnGrant", toJson(*value.emailOnGrant));
        }
        
        if( !value.emailOnClaim.isNull() ){
            result.set("emailOnClaim", toJson(*value.emailOnClaim));
        }
        
        if( !value.redemptionRewards.isNull() ){
            for (std::list<Mber::Reward>::const_iterator iterator = value.redemptionRewards->begin(), end = value.redemptionRewards->end(); iterator != end; ++iterator) {
                Mber::Reward next = *iterator;
                result.set("redemptionRewards", RewardToJson(next));
            }
        }
        
        if( !value.categories.isNull() ){
            result.set("categories", toJson(*value.categories));
        }
        
        return result;
    };
    Mber::DigitalGoodInstance jsonToDigitalGoodInstance(Var &json){
        Mber::DigitalGoodInstance result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("definitionId");
        if( !next.isEmpty() ){
            result.definitionId = next.convert<std::string>();
        }
        next = obj->get("state");
        if( !next.isEmpty() ){
            result.state = jsonToEntitlementState(next);
        }
        next = obj->get("documentId");
        if( !next.isEmpty() ){
            result.documentId = Mber::MberPtr<std::string>(new std::string);
            *result.documentId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = Mber::MberPtr<std::string>(new std::string);
            *result.name = next.convert<std::string>();
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = Mber::MberPtr<std::string>(new std::string);
            *result.scope = next.convert<std::string>();
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::Property>>(new std::list<Mber::Property>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToProperty(next));
            }
        }
        next = obj->get("grantedBy");
        if( !next.isEmpty() ){
            result.grantedBy = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.grantedBy = jsonToEntityPointer(next);
        }
        next = obj->get("claimedBy");
        if( !next.isEmpty() ){
            result.claimedBy = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.claimedBy = jsonToEntityPointer(next);
        }
        next = obj->get("revokedBy");
        if( !next.isEmpty() ){
            result.revokedBy = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.revokedBy = jsonToEntityPointer(next);
        }
        next = obj->get("redeemedFrom");
        if( !next.isEmpty() ){
            result.redeemedFrom = Mber::MberPtr<std::string>(new std::string);
            *result.redeemedFrom = next.convert<std::string>();
        }
        next = obj->get("expiresOn");
        if( !next.isEmpty() ){
            result.expiresOn = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.expiresOn = (UInt64)next;
        }
        next = obj->get("selfGranted");
        if( !next.isEmpty() ){
            result.selfGranted = Mber::MberPtr<bool>(new bool);
            *result.selfGranted = next;
        }
        next = obj->get("entity");
        if( !next.isEmpty() ){
            result.entity = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.entity = jsonToEntityPointer(next);
        }
        next = obj->get("emailOnGrant");
        if( !next.isEmpty() ){
            result.emailOnGrant = Mber::MberPtr<bool>(new bool);
            *result.emailOnGrant = next;
        }
        next = obj->get("emailOnClaim");
        if( !next.isEmpty() ){
            result.emailOnClaim = Mber::MberPtr<bool>(new bool);
            *result.emailOnClaim = next;
        }
        next = obj->get("categories");
        if( !next.isEmpty() ){
            result.categories = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.categories->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object DigitalGoodInstanceToJson(Mber::DigitalGoodInstance &value){
        Object result;        
        
        result.set("id", toJson(value.id));
        
        result.set("definitionId", toJson(value.definitionId));
        
        result.set("state", toJson(value.state));
        
        if( !value.documentId.isNull() ){
            result.set("documentId", toJson(*value.documentId));
        }
        
        if( !value.name.isNull() ){
            result.set("name", toJson(*value.name));
        }
        
        if( !value.scope.isNull() ){
            result.set("scope", toJson(*value.scope));
        }
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::Property>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::Property next = *iterator;
                result.set("properties", PropertyToJson(next));
            }
        }
        
        if( !value.grantedBy.isNull() ){
            result.set("grantedBy", EntityPointerToJson(*value.grantedBy));
        }
        
        if( !value.claimedBy.isNull() ){
            result.set("claimedBy", EntityPointerToJson(*value.claimedBy));
        }
        
        if( !value.revokedBy.isNull() ){
            result.set("revokedBy", EntityPointerToJson(*value.revokedBy));
        }
        
        if( !value.redeemedFrom.isNull() ){
            result.set("redeemedFrom", toJson(*value.redeemedFrom));
        }
        
        if( !value.expiresOn.isNull() ){
            result.set("expiresOn", toJson(*value.expiresOn));
        }
        
        if( !value.selfGranted.isNull() ){
            result.set("selfGranted", toJson(*value.selfGranted));
        }
        
        if( !value.entity.isNull() ){
            result.set("entity", EntityPointerToJson(*value.entity));
        }
        
        if( !value.emailOnGrant.isNull() ){
            result.set("emailOnGrant", toJson(*value.emailOnGrant));
        }
        
        if( !value.emailOnClaim.isNull() ){
            result.set("emailOnClaim", toJson(*value.emailOnClaim));
        }
        
        if( !value.categories.isNull() ){
            result.set("categories", toJson(*value.categories));
        }
        
        return result;
    };
    Mber::DigitalGoodPropertyDefinition jsonToDigitalGoodPropertyDefinition(Var &json){
        Mber::DigitalGoodPropertyDefinition result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("onGrant");
        if( !next.isEmpty() ){
            result.onGrant = jsonToEntitlementPropertyAvailability(next);
        }
        next = obj->get("onClaim");
        if( !next.isEmpty() ){
            result.onClaim = jsonToEntitlementPropertyAvailability(next);
        }
        next = obj->get("defaultValue");
        if( !next.isEmpty() ){
            result.defaultValue = Mber::MberPtr<std::string>(new std::string);
            *result.defaultValue = next.convert<std::string>();
        }
        return result;
    };
    Object DigitalGoodPropertyDefinitionToJson(Mber::DigitalGoodPropertyDefinition &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("onGrant", toJson(value.onGrant));
        
        result.set("onClaim", toJson(value.onClaim));
        
        if( !value.defaultValue.isNull() ){
            result.set("defaultValue", toJson(*value.defaultValue));
        }
        
        return result;
    };
    Mber::EarnedAchievements jsonToEarnedAchievements(Var &json){
        Mber::EarnedAchievements result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("entity");
        if( !next.isEmpty() ){
            result.entity = jsonToEntityPointer(next);
        }
        next = obj->get("achievements");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.achievements.push_back(jsonToAchievementInstance(next));
            }
        }
        return result;
    };
    Object EarnedAchievementsToJson(Mber::EarnedAchievements &value){
        Object result;        
        
        result.set("entity", EntityPointerToJson(value.entity));
        
        for (std::list<Mber::AchievementInstance>::const_iterator iterator = value.achievements.begin(), end = value.achievements.end(); iterator != end; ++iterator) {
            Mber::AchievementInstance next = *iterator;
            result.set("achievements", AchievementInstanceToJson(next));
        }
        
        return result;
    };
    Mber::EntitlementInstance jsonToEntitlementInstance(Var &json){
        Mber::EntitlementInstance result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("definitionId");
        if( !next.isEmpty() ){
            result.definitionId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = Mber::MberPtr<std::string>(new std::string);
            *result.name = next.convert<std::string>();
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = Mber::MberPtr<std::string>(new std::string);
            *result.scope = next.convert<std::string>();
        }
        next = obj->get("entity");
        if( !next.isEmpty() ){
            result.entity = jsonToEntityPointer(next);
        }
        next = obj->get("state");
        if( !next.isEmpty() ){
            result.state = jsonToEntitlementState(next);
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::Property>>(new std::list<Mber::Property>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToProperty(next));
            }
        }
        next = obj->get("grantedBy");
        if( !next.isEmpty() ){
            result.grantedBy = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.grantedBy = jsonToEntityPointer(next);
        }
        next = obj->get("claimedBy");
        if( !next.isEmpty() ){
            result.claimedBy = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.claimedBy = jsonToEntityPointer(next);
        }
        next = obj->get("revokedBy");
        if( !next.isEmpty() ){
            result.revokedBy = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.revokedBy = jsonToEntityPointer(next);
        }
        next = obj->get("redeemedFrom");
        if( !next.isEmpty() ){
            result.redeemedFrom = Mber::MberPtr<std::string>(new std::string);
            *result.redeemedFrom = next.convert<std::string>();
        }
        next = obj->get("expiresOn");
        if( !next.isEmpty() ){
            result.expiresOn = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.expiresOn = (UInt64)next;
        }
        next = obj->get("selfGranted");
        if( !next.isEmpty() ){
            result.selfGranted = Mber::MberPtr<bool>(new bool);
            *result.selfGranted = next;
        }
        next = obj->get("categories");
        if( !next.isEmpty() ){
            result.categories = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.categories->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object EntitlementInstanceToJson(Mber::EntitlementInstance &value){
        Object result;        
        
        result.set("id", toJson(value.id));
        
        result.set("definitionId", toJson(value.definitionId));
        
        if( !value.name.isNull() ){
            result.set("name", toJson(*value.name));
        }
        
        if( !value.scope.isNull() ){
            result.set("scope", toJson(*value.scope));
        }
        
        result.set("entity", EntityPointerToJson(value.entity));
        
        result.set("state", toJson(value.state));
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::Property>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::Property next = *iterator;
                result.set("properties", PropertyToJson(next));
            }
        }
        
        if( !value.grantedBy.isNull() ){
            result.set("grantedBy", EntityPointerToJson(*value.grantedBy));
        }
        
        if( !value.claimedBy.isNull() ){
            result.set("claimedBy", EntityPointerToJson(*value.claimedBy));
        }
        
        if( !value.revokedBy.isNull() ){
            result.set("revokedBy", EntityPointerToJson(*value.revokedBy));
        }
        
        if( !value.redeemedFrom.isNull() ){
            result.set("redeemedFrom", toJson(*value.redeemedFrom));
        }
        
        if( !value.expiresOn.isNull() ){
            result.set("expiresOn", toJson(*value.expiresOn));
        }
        
        if( !value.selfGranted.isNull() ){
            result.set("selfGranted", toJson(*value.selfGranted));
        }
        
        if( !value.categories.isNull() ){
            result.set("categories", toJson(*value.categories));
        }
        
        return result;
    };
    Mber::EntitlementPropertyDefinition jsonToEntitlementPropertyDefinition(Var &json){
        Mber::EntitlementPropertyDefinition result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("onGrant");
        if( !next.isEmpty() ){
            result.onGrant = jsonToEntitlementPropertyAvailability(next);
        }
        next = obj->get("onClaim");
        if( !next.isEmpty() ){
            result.onClaim = jsonToEntitlementPropertyAvailability(next);
        }
        next = obj->get("defaultValue");
        if( !next.isEmpty() ){
            result.defaultValue = Mber::MberPtr<std::string>(new std::string);
            *result.defaultValue = next.convert<std::string>();
        }
        return result;
    };
    Object EntitlementPropertyDefinitionToJson(Mber::EntitlementPropertyDefinition &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("onGrant", toJson(value.onGrant));
        
        result.set("onClaim", toJson(value.onClaim));
        
        if( !value.defaultValue.isNull() ){
            result.set("defaultValue", toJson(*value.defaultValue));
        }
        
        return result;
    };
    Mber::Keys jsonToKeys(Var &json){
        Mber::Keys result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("campaignId");
        if( !next.isEmpty() ){
            result.campaignId = jsonToEntityID(next);
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = jsonToEntityID(next);
        }
        next = obj->get("numberOfKeys");
        if( !next.isEmpty() ){
            result.numberOfKeys = next;
        }
        next = obj->get("outputDocument");
        if( !next.isEmpty() ){
            result.outputDocument = jsonToEntityID(next);
        }
        next = obj->get("keyFormat");
        if( !next.isEmpty() ){
            result.keyFormat = jsonToKeyFormat(next);
        }
        return result;
    };
    Object KeysToJson(Mber::Keys &value){
        Object result;        
        
        result.set("campaignId", EntityIDToJson(value.campaignId));
        
        result.set("applicationId", EntityIDToJson(value.applicationId));
        
        result.set("numberOfKeys", toJson(value.numberOfKeys));
        
        result.set("outputDocument", EntityIDToJson(value.outputDocument));
        
        result.set("keyFormat", toJson(value.keyFormat));
        
        return result;
    };
    Mber::RedemptionEvent jsonToRedemptionEvent(Var &json){
        Mber::RedemptionEvent result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("instanceId");
        if( !next.isEmpty() ){
            result.instanceId = next.convert<std::string>();
        }
        next = obj->get("definitionId");
        if( !next.isEmpty() ){
            result.definitionId = next.convert<std::string>();
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = next.convert<std::string>();
        }
        next = obj->get("claimedBy");
        if( !next.isEmpty() ){
            result.claimedBy = jsonToEntityPointer(next);
        }
        next = obj->get("owner");
        if( !next.isEmpty() ){
            result.owner = jsonToEntityPointer(next);
        }
        next = obj->get("redemptionRewards");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.redemptionRewards.push_back(jsonToReward(next));
            }
        }
        next = obj->get("grantedBy");
        if( !next.isEmpty() ){
            result.grantedBy = jsonToEntityPointer(next);
        }
        return result;
    };
    Object RedemptionEventToJson(Mber::RedemptionEvent &value){
        Object result;        
        
        result.set("instanceId", toJson(value.instanceId));
        
        result.set("definitionId", toJson(value.definitionId));
        
        result.set("scope", toJson(value.scope));
        
        result.set("claimedBy", EntityPointerToJson(value.claimedBy));
        
        result.set("owner", EntityPointerToJson(value.owner));
        
        for (std::list<Mber::Reward>::const_iterator iterator = value.redemptionRewards.begin(), end = value.redemptionRewards.end(); iterator != end; ++iterator) {
            Mber::Reward next = *iterator;
            result.set("redemptionRewards", RewardToJson(next));
        }
        
        result.set("grantedBy", EntityPointerToJson(value.grantedBy));
        
        return result;
    };
    Mber::Reward jsonToReward(Var &json){
        Mber::Reward result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("item");
        if( !next.isEmpty() ){
            result.item = jsonToEntityPointer(next);
        }
        next = obj->get("amount");
        if( !next.isEmpty() ){
            result.amount = next;
        }
        return result;
    };
    Object RewardToJson(Mber::Reward &value){
        Object result;        
        
        result.set("item", EntityPointerToJson(value.item));
        
        result.set("amount", toJson(value.amount));
        
        return result;
    };
    Mber::CDNConfig jsonToCDNConfig(Var &json){
        Mber::CDNConfig result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("cdnType");
        if( !next.isEmpty() ){
            result.cdnType = jsonToCDNType(next);
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("defaultPath");
        if( !next.isEmpty() ){
            result.defaultPath = Mber::MberPtr<std::string>(new std::string);
            *result.defaultPath = next.convert<std::string>();
        }
        next = obj->get("username");
        if( !next.isEmpty() ){
            result.username = Mber::MberPtr<std::string>(new std::string);
            *result.username = next.convert<std::string>();
        }
        next = obj->get("account");
        if( !next.isEmpty() ){
            result.account = Mber::MberPtr<std::string>(new std::string);
            *result.account = next.convert<std::string>();
        }
        next = obj->get("cdnHost");
        if( !next.isEmpty() ){
            result.cdnHost = Mber::MberPtr<std::string>(new std::string);
            *result.cdnHost = next.convert<std::string>();
        }
        next = obj->get("baseContainer");
        if( !next.isEmpty() ){
            result.baseContainer = Mber::MberPtr<std::string>(new std::string);
            *result.baseContainer = next.convert<std::string>();
        }
        return result;
    };
    Object CDNConfigToJson(Mber::CDNConfig &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("id", toJson(value.id));
        
        result.set("cdnType", toJson(value.cdnType));
        
        result.set("name", toJson(value.name));
        
        if( !value.defaultPath.isNull() ){
            result.set("defaultPath", toJson(*value.defaultPath));
        }
        
        if( !value.username.isNull() ){
            result.set("username", toJson(*value.username));
        }
        
        if( !value.account.isNull() ){
            result.set("account", toJson(*value.account));
        }
        
        if( !value.cdnHost.isNull() ){
            result.set("cdnHost", toJson(*value.cdnHost));
        }
        
        if( !value.baseContainer.isNull() ){
            result.set("baseContainer", toJson(*value.baseContainer));
        }
        
        return result;
    };
    Mber::CDNSyncEvent jsonToCDNSyncEvent(Var &json){
        Mber::CDNSyncEvent result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("entity");
        if( !next.isEmpty() ){
            result.entity = jsonToEntityPointer(next);
        }
        next = obj->get("version");
        if( !next.isEmpty() ){
            result.version = Mber::MberPtr<int>(new int);
            *result.version = next;
        }
        next = obj->get("cdnConfig");
        if( !next.isEmpty() ){
            result.cdnConfig = Mber::MberPtr<Mber::CDNConfig>(new Mber::CDNConfig);
            *result.cdnConfig = jsonToCDNConfig(next);
        }
        return result;
    };
    Object CDNSyncEventToJson(Mber::CDNSyncEvent &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("entity", EntityPointerToJson(value.entity));
        
        if( !value.version.isNull() ){
            result.set("version", toJson(*value.version));
        }
        
        if( !value.cdnConfig.isNull() ){
            result.set("cdnConfig", CDNConfigToJson(*value.cdnConfig));
        }
        
        return result;
    };
    Mber::DataEvent jsonToDataEvent(Var &json){
        Mber::DataEvent result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("oldSize");
        if( !next.isEmpty() ){
            result.oldSize = next;
        }
        next = obj->get("newSize");
        if( !next.isEmpty() ){
            result.newSize = next;
        }
        next = obj->get("sizeChange");
        if( !next.isEmpty() ){
            result.sizeChange = next;
        }
        return result;
    };
    Object DataEventToJson(Mber::DataEvent &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("oldSize", toJson(value.oldSize));
        
        result.set("newSize", toJson(value.newSize));
        
        result.set("sizeChange", toJson(value.sizeChange));
        
        return result;
    };
    Mber::Directory jsonToDirectory(Var &json){
        Mber::Directory result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("alias");
        if( !next.isEmpty() ){
            result.alias = Mber::MberPtr<std::string>(new std::string);
            *result.alias = next.convert<std::string>();
        }
        next = obj->get("directoryId");
        if( !next.isEmpty() ){
            result.directoryId = next.convert<std::string>();
        }
        next = obj->get("parentId");
        if( !next.isEmpty() ){
            result.parentId = Mber::MberPtr<std::string>(new std::string);
            *result.parentId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("isLink");
        if( !next.isEmpty() ){
            result.isLink = Mber::MberPtr<bool>(new bool);
            *result.isLink = next;
        }
        next = obj->get("directories");
        if( !next.isEmpty() ){
            result.directories = Mber::MberPtr<std::list<Mber::Directory>>(new std::list<Mber::Directory>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.directories->push_back(jsonToDirectory(next));
            }
        }
        next = obj->get("documents");
        if( !next.isEmpty() ){
            result.documents = Mber::MberPtr<std::list<Mber::Document>>(new std::list<Mber::Document>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.documents->push_back(jsonToDocument(next));
            }
        }
        return result;
    };
    Object DirectoryToJson(Mber::Directory &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        if( !value.alias.isNull() ){
            result.set("alias", toJson(*value.alias));
        }
        
        result.set("directoryId", toJson(value.directoryId));
        
        if( !value.parentId.isNull() ){
            result.set("parentId", toJson(*value.parentId));
        }
        
        result.set("applicationId", toJson(value.applicationId));
        
        if( !value.isLink.isNull() ){
            result.set("isLink", toJson(*value.isLink));
        }
        
        if( !value.directories.isNull() ){
            for (std::list<Mber::Directory>::const_iterator iterator = value.directories->begin(), end = value.directories->end(); iterator != end; ++iterator) {
                Mber::Directory next = *iterator;
                result.set("directories", DirectoryToJson(next));
            }
        }
        
        if( !value.documents.isNull() ){
            for (std::list<Mber::Document>::const_iterator iterator = value.documents->begin(), end = value.documents->end(); iterator != end; ++iterator) {
                Mber::Document next = *iterator;
                result.set("documents", DocumentToJson(next));
            }
        }
        
        return result;
    };
    Mber::Document jsonToDocument(Var &json){
        Mber::Document result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = Mber::MberPtr<std::string>(new std::string);
            *result.name = next.convert<std::string>();
        }
        next = obj->get("alias");
        if( !next.isEmpty() ){
            result.alias = Mber::MberPtr<std::string>(new std::string);
            *result.alias = next.convert<std::string>();
        }
        next = obj->get("documentId");
        if( !next.isEmpty() ){
            result.documentId = next.convert<std::string>();
        }
        next = obj->get("version");
        if( !next.isEmpty() ){
            result.version = Mber::MberPtr<int>(new int);
            *result.version = next;
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = Mber::MberPtr<std::string>(new std::string);
            *result.scope = next.convert<std::string>();
        }
        next = obj->get("tags");
        if( !next.isEmpty() ){
            result.tags = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.tags->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            result.properties = Mber::MberPtr<std::list<Mber::Property>>(new std::list<Mber::Property>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties->push_back(jsonToProperty(next));
            }
        }
        next = obj->get("documentTemplate");
        if( !next.isEmpty() ){
            result.documentTemplate = Mber::MberPtr<std::string>(new std::string);
            *result.documentTemplate = next.convert<std::string>();
        }
        next = obj->get("content");
        if( !next.isEmpty() ){
            result.content = Mber::MberPtr<std::string>(new std::string);
            *result.content = next.convert<std::string>();
        }
        next = obj->get("directoryId");
        if( !next.isEmpty() ){
            result.directoryId = Mber::MberPtr<std::string>(new std::string);
            *result.directoryId = next.convert<std::string>();
        }
        next = obj->get("isLink");
        if( !next.isEmpty() ){
            result.isLink = Mber::MberPtr<bool>(new bool);
            *result.isLink = next;
        }
        next = obj->get("size");
        if( !next.isEmpty() ){
            result.size = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.size = (UInt64)next;
        }
        next = obj->get("canDownload");
        if( !next.isEmpty() ){
            result.canDownload = Mber::MberPtr<bool>(new bool);
            *result.canDownload = next;
        }
        next = obj->get("canEdit");
        if( !next.isEmpty() ){
            result.canEdit = Mber::MberPtr<bool>(new bool);
            *result.canEdit = next;
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = Mber::MberPtr<std::list<Mber::DocumentStatus>>(new std::list<Mber::DocumentStatus>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.status->push_back(jsonToDocumentStatus(next));
            }
        }
        next = obj->get("maxVersionsToKeep");
        if( !next.isEmpty() ){
            result.maxVersionsToKeep = Mber::MberPtr<int>(new int);
            *result.maxVersionsToKeep = next;
        }
        next = obj->get("maxTimeToKeep");
        if( !next.isEmpty() ){
            result.maxTimeToKeep = Mber::MberPtr<int>(new int);
            *result.maxTimeToKeep = next;
        }
        next = obj->get("keepAllVersions");
        if( !next.isEmpty() ){
            result.keepAllVersions = Mber::MberPtr<bool>(new bool);
            *result.keepAllVersions = next;
        }
        return result;
    };
    Object DocumentToJson(Mber::Document &value){
        Object result;        
        
        if( !value.name.isNull() ){
            result.set("name", toJson(*value.name));
        }
        
        if( !value.alias.isNull() ){
            result.set("alias", toJson(*value.alias));
        }
        
        result.set("documentId", toJson(value.documentId));
        
        if( !value.version.isNull() ){
            result.set("version", toJson(*value.version));
        }
        
        if( !value.scope.isNull() ){
            result.set("scope", toJson(*value.scope));
        }
        
        if( !value.tags.isNull() ){
            result.set("tags", toJson(*value.tags));
        }
        
        if( !value.properties.isNull() ){
            for (std::list<Mber::Property>::const_iterator iterator = value.properties->begin(), end = value.properties->end(); iterator != end; ++iterator) {
                Mber::Property next = *iterator;
                result.set("properties", PropertyToJson(next));
            }
        }
        
        if( !value.documentTemplate.isNull() ){
            result.set("documentTemplate", toJson(*value.documentTemplate));
        }
        
        if( !value.content.isNull() ){
            result.set("content", toJson(*value.content));
        }
        
        if( !value.directoryId.isNull() ){
            result.set("directoryId", toJson(*value.directoryId));
        }
        
        if( !value.isLink.isNull() ){
            result.set("isLink", toJson(*value.isLink));
        }
        
        if( !value.size.isNull() ){
            result.set("size", toJson(*value.size));
        }
        
        if( !value.canDownload.isNull() ){
            result.set("canDownload", toJson(*value.canDownload));
        }
        
        if( !value.canEdit.isNull() ){
            result.set("canEdit", toJson(*value.canEdit));
        }
        
        if( !value.status.isNull() ){
            result.set("status", toJson(*value.status));
        }
        
        if( !value.maxVersionsToKeep.isNull() ){
            result.set("maxVersionsToKeep", toJson(*value.maxVersionsToKeep));
        }
        
        if( !value.maxTimeToKeep.isNull() ){
            result.set("maxTimeToKeep", toJson(*value.maxTimeToKeep));
        }
        
        if( !value.keepAllVersions.isNull() ){
            result.set("keepAllVersions", toJson(*value.keepAllVersions));
        }
        
        return result;
    };
    Mber::DocumentHistoryConfiguration jsonToDocumentHistoryConfiguration(Var &json){
        Mber::DocumentHistoryConfiguration result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("maxVersionsToKeep");
        if( !next.isEmpty() ){
            result.maxVersionsToKeep = Mber::MberPtr<int>(new int);
            *result.maxVersionsToKeep = next;
        }
        next = obj->get("maxTimeToKeep");
        if( !next.isEmpty() ){
            result.maxTimeToKeep = Mber::MberPtr<int>(new int);
            *result.maxTimeToKeep = next;
        }
        next = obj->get("keepAllVersions");
        if( !next.isEmpty() ){
            result.keepAllVersions = next;
        }
        return result;
    };
    Object DocumentHistoryConfigurationToJson(Mber::DocumentHistoryConfiguration &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        if( !value.maxVersionsToKeep.isNull() ){
            result.set("maxVersionsToKeep", toJson(*value.maxVersionsToKeep));
        }
        
        if( !value.maxTimeToKeep.isNull() ){
            result.set("maxTimeToKeep", toJson(*value.maxTimeToKeep));
        }
        
        result.set("keepAllVersions", toJson(value.keepAllVersions));
        
        return result;
    };
    Mber::DocumentReindex jsonToDocumentReindex(Var &json){
        Mber::DocumentReindex result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = jsonToEntityID(next);
        }
        next = obj->get("templateId");
        if( !next.isEmpty() ){
            result.templateId = Mber::MberPtr<std::string>(new std::string);
            *result.templateId = next.convert<std::string>();
        }
        next = obj->get("deleteIndex");
        if( !next.isEmpty() ){
            result.deleteIndex = Mber::MberPtr<bool>(new bool);
            *result.deleteIndex = next;
        }
        return result;
    };
    Object DocumentReindexToJson(Mber::DocumentReindex &value){
        Object result;        
        
        result.set("applicationId", EntityIDToJson(value.applicationId));
        
        if( !value.templateId.isNull() ){
            result.set("templateId", toJson(*value.templateId));
        }
        
        if( !value.deleteIndex.isNull() ){
            result.set("deleteIndex", toJson(*value.deleteIndex));
        }
        
        return result;
    };
    Mber::DocumentTemplate jsonToDocumentTemplate(Var &json){
        Mber::DocumentTemplate result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("documentTemplateId");
        if( !next.isEmpty() ){
            result.documentTemplateId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("template");
        if( !next.isEmpty() ){
            result.templateId = Mber::MberPtr<std::string>(new std::string);
            *result.templateId = next.convert<std::string>();
        }
        next = obj->get("application");
        if( !next.isEmpty() ){
            result.application = Mber::MberPtr<std::string>(new std::string);
            *result.application = next.convert<std::string>();
        }
        next = obj->get("size");
        if( !next.isEmpty() ){
            result.size = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.size = (UInt64)next;
        }
        next = obj->get("version");
        if( !next.isEmpty() ){
            result.version = Mber::MberPtr<int>(new int);
            *result.version = next;
        }
        next = obj->get("maxVersionsToKeep");
        if( !next.isEmpty() ){
            result.maxVersionsToKeep = Mber::MberPtr<int>(new int);
            *result.maxVersionsToKeep = next;
        }
        next = obj->get("maxTimeToKeep");
        if( !next.isEmpty() ){
            result.maxTimeToKeep = Mber::MberPtr<int>(new int);
            *result.maxTimeToKeep = next;
        }
        return result;
    };
    Object DocumentTemplateToJson(Mber::DocumentTemplate &value){
        Object result;        
        
        result.set("documentTemplateId", toJson(value.documentTemplateId));
        
        result.set("name", toJson(value.name));
        
        if( !value.templateId.isNull() ){
            result.set("template", toJson(*value.templateId));
        }
        
        if( !value.application.isNull() ){
            result.set("application", toJson(*value.application));
        }
        
        if( !value.size.isNull() ){
            result.set("size", toJson(*value.size));
        }
        
        if( !value.version.isNull() ){
            result.set("version", toJson(*value.version));
        }
        
        if( !value.maxVersionsToKeep.isNull() ){
            result.set("maxVersionsToKeep", toJson(*value.maxVersionsToKeep));
        }
        
        if( !value.maxTimeToKeep.isNull() ){
            result.set("maxTimeToKeep", toJson(*value.maxTimeToKeep));
        }
        
        return result;
    };
    Mber::DocumentVersion jsonToDocumentVersion(Var &json){
        Mber::DocumentVersion result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("documentId");
        if( !next.isEmpty() ){
            result.documentId = next.convert<std::string>();
        }
        next = obj->get("version");
        if( !next.isEmpty() ){
            result.version = next;
        }
        next = obj->get("created");
        if( !next.isEmpty() ){
            result.created = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.created = (UInt64)next;
        }
        return result;
    };
    Object DocumentVersionToJson(Mber::DocumentVersion &value){
        Object result;        
        
        result.set("documentId", toJson(value.documentId));
        
        result.set("version", toJson(value.version));
        
        if( !value.created.isNull() ){
            result.set("created", toJson(*value.created));
        }
        
        return result;
    };
    Mber::S3BucketConfig jsonToS3BucketConfig(Var &json){
        Mber::S3BucketConfig result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("bucketConfigId");
        if( !next.isEmpty() ){
            result.bucketConfigId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("accessKey");
        if( !next.isEmpty() ){
            result.accessKey = next.convert<std::string>();
        }
        next = obj->get("urlTtl");
        if( !next.isEmpty() ){
            result.urlTtl = next;
        }
        return result;
    };
    Object S3BucketConfigToJson(Mber::S3BucketConfig &value){
        Object result;        
        
        result.set("bucketConfigId", toJson(value.bucketConfigId));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("name", toJson(value.name));
        
        result.set("accessKey", toJson(value.accessKey));
        
        result.set("urlTtl", toJson(value.urlTtl));
        
        return result;
    };
    Mber::TemplateField jsonToTemplateField(Var &json){
        Mber::TemplateField result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("fieldType");
        if( !next.isEmpty() ){
            result.fieldType = jsonToTemplateFieldType(next);
        }
        next = obj->get("reference");
        if( !next.isEmpty() ){
            result.reference = Mber::MberPtr<std::string>(new std::string);
            *result.reference = next.convert<std::string>();
        }
        next = obj->get("template");
        if( !next.isEmpty() ){
            result.templateId = Mber::MberPtr<std::string>(new std::string);
            *result.templateId = next.convert<std::string>();
        }
        next = obj->get("optional");
        if( !next.isEmpty() ){
            result.optional = Mber::MberPtr<bool>(new bool);
            *result.optional = next;
        }
        next = obj->get("list");
        if( !next.isEmpty() ){
            result.list = Mber::MberPtr<bool>(new bool);
            *result.list = next;
        }
        return result;
    };
    Object TemplateFieldToJson(Mber::TemplateField &value){
        Object result;        
        
        result.set("fieldType", toJson(value.fieldType));
        
        if( !value.reference.isNull() ){
            result.set("reference", toJson(*value.reference));
        }
        
        if( !value.templateId.isNull() ){
            result.set("template", toJson(*value.templateId));
        }
        
        if( !value.optional.isNull() ){
            result.set("optional", toJson(*value.optional));
        }
        
        if( !value.list.isNull() ){
            result.set("list", toJson(*value.list));
        }
        
        return result;
    };
    Mber::Provider jsonToProvider(Var &json){
        Mber::Provider result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("domain");
        if( !next.isEmpty() ){
            result.domain = next.convert<std::string>();
        }
        next = obj->get("identity");
        if( !next.isEmpty() ){
            result.identity = next.convert<std::string>();
        }
        return result;
    };
    Object ProviderToJson(Mber::Provider &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("domain", toJson(value.domain));
        
        result.set("identity", toJson(value.identity));
        
        return result;
    };
    Mber::EventPointer jsonToEventPointer(Var &json){
        Mber::EventPointer result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("typeId");
        if( !next.isEmpty() ){
            result.typeId = next;
        }
        next = obj->get("id");
        if( !next.isEmpty() ){
            result.id = next.convert<std::string>();
        }
        next = obj->get("created");
        if( !next.isEmpty() ){
            result.created = (UInt64)next;
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = Mber::MberPtr<std::string>(new std::string);
            *result.applicationId = next.convert<std::string>();
        }
        return result;
    };
    Object EventPointerToJson(Mber::EventPointer &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("typeId", toJson(value.typeId));
        
        result.set("id", toJson(value.id));
        
        result.set("created", toJson(value.created));
        
        if( !value.applicationId.isNull() ){
            result.set("applicationId", toJson(*value.applicationId));
        }
        
        return result;
    };
    Mber::ReconciledEvent jsonToReconciledEvent(Var &json){
        Mber::ReconciledEvent result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("eventType");
        if( !next.isEmpty() ){
            result.eventType = jsonToEventType(next);
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("scope");
        if( !next.isEmpty() ){
            result.scope = jsonToAppCountType(next);
        }
        next = obj->get("lastReconciled");
        if( !next.isEmpty() ){
            result.lastReconciled = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.lastReconciled = (UInt64)next;
        }
        return result;
    };
    Object ReconciledEventToJson(Mber::ReconciledEvent &value){
        Object result;        
        
        result.set("name", toJson(value.name));
        
        result.set("eventType", toJson(value.eventType));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("scope", toJson(value.scope));
        
        if( !value.lastReconciled.isNull() ){
            result.set("lastReconciled", toJson(*value.lastReconciled));
        }
        
        return result;
    };
    Mber::AvailableEvent jsonToAvailableEvent(Var &json){
        Mber::AvailableEvent result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("eventName");
        if( !next.isEmpty() ){
            result.eventName = next.convert<std::string>();
        }
        next = obj->get("types");
        if( !next.isEmpty() ){
            result.types = Mber::MberPtr<std::list<Mber::EventType>>(new std::list<Mber::EventType>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.types->push_back(jsonToEventType(next));
            }
        }
        return result;
    };
    Object AvailableEventToJson(Mber::AvailableEvent &value){
        Object result;        
        
        result.set("eventName", toJson(value.eventName));
        
        if( !value.types.isNull() ){
            result.set("types", toJson(*value.types));
        }
        
        return result;
    };
    Mber::AdyenCallback jsonToAdyenCallback(Var &json){
        Mber::AdyenCallback result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = Mber::MberPtr<std::string>(new std::string);
            *result.applicationId = next.convert<std::string>();
        }
        next = obj->get("invoiceId");
        if( !next.isEmpty() ){
            result.invoiceId = Mber::MberPtr<std::string>(new std::string);
            *result.invoiceId = next.convert<std::string>();
        }
        next = obj->get("providerId");
        if( !next.isEmpty() ){
            result.providerId = Mber::MberPtr<std::string>(new std::string);
            *result.providerId = next.convert<std::string>();
        }
        next = obj->get("merchantReference");
        if( !next.isEmpty() ){
            result.merchantReference = Mber::MberPtr<std::string>(new std::string);
            *result.merchantReference = next.convert<std::string>();
        }
        next = obj->get("live");
        if( !next.isEmpty() ){
            result.live = Mber::MberPtr<bool>(new bool);
            *result.live = next;
        }
        next = obj->get("eventCode");
        if( !next.isEmpty() ){
            result.eventCode = Mber::MberPtr<std::string>(new std::string);
            *result.eventCode = next.convert<std::string>();
        }
        next = obj->get("pspReference");
        if( !next.isEmpty() ){
            result.pspReference = Mber::MberPtr<std::string>(new std::string);
            *result.pspReference = next.convert<std::string>();
        }
        next = obj->get("originalReference");
        if( !next.isEmpty() ){
            result.originalReference = Mber::MberPtr<std::string>(new std::string);
            *result.originalReference = next.convert<std::string>();
        }
        next = obj->get("merchantAccountCode");
        if( !next.isEmpty() ){
            result.merchantAccountCode = Mber::MberPtr<std::string>(new std::string);
            *result.merchantAccountCode = next.convert<std::string>();
        }
        next = obj->get("eventDate");
        if( !next.isEmpty() ){
            result.eventDate = Mber::MberPtr<std::string>(new std::string);
            *result.eventDate = next.convert<std::string>();
        }
        next = obj->get("success");
        if( !next.isEmpty() ){
            result.success = Mber::MberPtr<bool>(new bool);
            *result.success = next;
        }
        next = obj->get("paymentMethod");
        if( !next.isEmpty() ){
            result.paymentMethod = Mber::MberPtr<std::string>(new std::string);
            *result.paymentMethod = next.convert<std::string>();
        }
        next = obj->get("operations");
        if( !next.isEmpty() ){
            result.operations = Mber::MberPtr<std::string>(new std::string);
            *result.operations = next.convert<std::string>();
        }
        next = obj->get("reason");
        if( !next.isEmpty() ){
            result.reason = Mber::MberPtr<std::string>(new std::string);
            *result.reason = next.convert<std::string>();
        }
        next = obj->get("value");
        if( !next.isEmpty() ){
            result.value = Mber::MberPtr<long>(new long);
            *result.value = next;
        }
        next = obj->get("currency");
        if( !next.isEmpty() ){
            result.currency = Mber::MberPtr<Mber::CurrencyCode>(new Mber::CurrencyCode);
            *result.currency = jsonToCurrencyCode(next);
        }
        return result;
    };
    Object AdyenCallbackToJson(Mber::AdyenCallback &value){
        Object result;        
        
        if( !value.applicationId.isNull() ){
            result.set("applicationId", toJson(*value.applicationId));
        }
        
        if( !value.invoiceId.isNull() ){
            result.set("invoiceId", toJson(*value.invoiceId));
        }
        
        if( !value.providerId.isNull() ){
            result.set("providerId", toJson(*value.providerId));
        }
        
        if( !value.merchantReference.isNull() ){
            result.set("merchantReference", toJson(*value.merchantReference));
        }
        
        if( !value.live.isNull() ){
            result.set("live", toJson(*value.live));
        }
        
        if( !value.eventCode.isNull() ){
            result.set("eventCode", toJson(*value.eventCode));
        }
        
        if( !value.pspReference.isNull() ){
            result.set("pspReference", toJson(*value.pspReference));
        }
        
        if( !value.originalReference.isNull() ){
            result.set("originalReference", toJson(*value.originalReference));
        }
        
        if( !value.merchantAccountCode.isNull() ){
            result.set("merchantAccountCode", toJson(*value.merchantAccountCode));
        }
        
        if( !value.eventDate.isNull() ){
            result.set("eventDate", toJson(*value.eventDate));
        }
        
        if( !value.success.isNull() ){
            result.set("success", toJson(*value.success));
        }
        
        if( !value.paymentMethod.isNull() ){
            result.set("paymentMethod", toJson(*value.paymentMethod));
        }
        
        if( !value.operations.isNull() ){
            result.set("operations", toJson(*value.operations));
        }
        
        if( !value.reason.isNull() ){
            result.set("reason", toJson(*value.reason));
        }
        
        if( !value.value.isNull() ){
            result.set("value", toJson(*value.value));
        }
        
        if( !value.currency.isNull() ){
            result.set("currency", toJson(*value.currency));
        }
        
        return result;
    };
    Mber::Affiliate jsonToAffiliate(Var &json){
        Mber::Affiliate result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("affiliateId");
        if( !next.isEmpty() ){
            result.affiliateId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = Mber::MberPtr<std::string>(new std::string);
            *result.profileId = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = Mber::MberPtr<std::list<Mber::AffiliateStatus>>(new std::list<Mber::AffiliateStatus>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.status->push_back(jsonToAffiliateStatus(next));
            }
        }
        return result;
    };
    Object AffiliateToJson(Mber::Affiliate &value){
        Object result;        
        
        result.set("affiliateId", toJson(value.affiliateId));
        
        result.set("name", toJson(value.name));
        
        result.set("applicationId", toJson(value.applicationId));
        
        if( !value.profileId.isNull() ){
            result.set("profileId", toJson(*value.profileId));
        }
        
        if( !value.status.isNull() ){
            result.set("status", toJson(*value.status));
        }
        
        return result;
    };
    Mber::BoaCompraCallback jsonToBoaCompraCallback(Var &json){
        Mber::BoaCompraCallback result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("storeId");
        if( !next.isEmpty() ){
            result.storeId = Mber::MberPtr<std::string>(new std::string);
            *result.storeId = next.convert<std::string>();
        }
        next = obj->get("transactionId");
        if( !next.isEmpty() ){
            result.transactionId = Mber::MberPtr<std::string>(new std::string);
            *result.transactionId = next.convert<std::string>();
        }
        next = obj->get("invoiceId");
        if( !next.isEmpty() ){
            result.invoiceId = Mber::MberPtr<std::string>(new std::string);
            *result.invoiceId = next.convert<std::string>();
        }
        next = obj->get("providerId");
        if( !next.isEmpty() ){
            result.providerId = Mber::MberPtr<std::string>(new std::string);
            *result.providerId = next.convert<std::string>();
        }
        next = obj->get("amount");
        if( !next.isEmpty() ){
            result.amount = Mber::MberPtr<long>(new long);
            *result.amount = next;
        }
        next = obj->get("currencyCode");
        if( !next.isEmpty() ){
            result.currencyCode = Mber::MberPtr<Mber::CurrencyCode>(new Mber::CurrencyCode);
            *result.currencyCode = jsonToCurrencyCode(next);
        }
        next = obj->get("paymentId");
        if( !next.isEmpty() ){
            result.paymentId = Mber::MberPtr<std::string>(new std::string);
            *result.paymentId = next.convert<std::string>();
        }
        next = obj->get("countryPayment");
        if( !next.isEmpty() ){
            result.countryPayment = Mber::MberPtr<std::string>(new std::string);
            *result.countryPayment = next.convert<std::string>();
        }
        next = obj->get("testMode");
        if( !next.isEmpty() ){
            result.testMode = Mber::MberPtr<std::string>(new std::string);
            *result.testMode = next.convert<std::string>();
        }
        return result;
    };
    Object BoaCompraCallbackToJson(Mber::BoaCompraCallback &value){
        Object result;        
        
        if( !value.storeId.isNull() ){
            result.set("storeId", toJson(*value.storeId));
        }
        
        if( !value.transactionId.isNull() ){
            result.set("transactionId", toJson(*value.transactionId));
        }
        
        if( !value.invoiceId.isNull() ){
            result.set("invoiceId", toJson(*value.invoiceId));
        }
        
        if( !value.providerId.isNull() ){
            result.set("providerId", toJson(*value.providerId));
        }
        
        if( !value.amount.isNull() ){
            result.set("amount", toJson(*value.amount));
        }
        
        if( !value.currencyCode.isNull() ){
            result.set("currencyCode", toJson(*value.currencyCode));
        }
        
        if( !value.paymentId.isNull() ){
            result.set("paymentId", toJson(*value.paymentId));
        }
        
        if( !value.countryPayment.isNull() ){
            result.set("countryPayment", toJson(*value.countryPayment));
        }
        
        if( !value.testMode.isNull() ){
            result.set("testMode", toJson(*value.testMode));
        }
        
        return result;
    };
    Mber::Catalog jsonToCatalog(Var &json){
        Mber::Catalog result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("addItems");
        if( !next.isEmpty() ){
            result.addItems = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.addItems->push_back(jsonToEntityPointer(next));
            }
        }
        next = obj->get("removeItems");
        if( !next.isEmpty() ){
            result.removeItems = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.removeItems->push_back(jsonToEntityPointer(next));
            }
        }
        return result;
    };
    Object CatalogToJson(Mber::Catalog &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        if( !value.addItems.isNull() ){
            for (std::list<Mber::EntityPointer>::const_iterator iterator = value.addItems->begin(), end = value.addItems->end(); iterator != end; ++iterator) {
                Mber::EntityPointer next = *iterator;
                result.set("addItems", EntityPointerToJson(next));
            }
        }
        
        if( !value.removeItems.isNull() ){
            for (std::list<Mber::EntityPointer>::const_iterator iterator = value.removeItems->begin(), end = value.removeItems->end(); iterator != end; ++iterator) {
                Mber::EntityPointer next = *iterator;
                result.set("removeItems", EntityPointerToJson(next));
            }
        }
        
        return result;
    };
    Mber::DeductionRule jsonToDeductionRule(Var &json){
        Mber::DeductionRule result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("priority");
        if( !next.isEmpty() ){
            result.priority = jsonToDeductionRulePriority(next);
        }
        next = obj->get("property");
        if( !next.isEmpty() ){
            result.property = jsonToDeductionRuleProperty(next);
        }
        return result;
    };
    Object DeductionRuleToJson(Mber::DeductionRule &value){
        Object result;        
        
        result.set("priority", toJson(value.priority));
        
        result.set("property", toJson(value.property));
        
        return result;
    };
    Mber::EntityTotal jsonToEntityTotal(Var &json){
        Mber::EntityTotal result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("total");
        if( !next.isEmpty() ){
            result.total = next;
        }
        next = obj->get("entity");
        if( !next.isEmpty() ){
            result.entity = jsonToEntityPointer(next);
        }
        return result;
    };
    Object EntityTotalToJson(Mber::EntityTotal &value){
        Object result;        
        
        result.set("total", toJson(value.total));
        
        result.set("entity", EntityPointerToJson(value.entity));
        
        return result;
    };
    Mber::Invoice jsonToInvoice(Var &json){
        Mber::Invoice result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("invoiceId");
        if( !next.isEmpty() ){
            result.invoiceId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = jsonToInvoiceStatus(next);
        }
        next = obj->get("storeId");
        if( !next.isEmpty() ){
            result.storeId = Mber::MberPtr<std::string>(new std::string);
            *result.storeId = next.convert<std::string>();
        }
        next = obj->get("paymentProviders");
        if( !next.isEmpty() ){
            result.paymentProviders = Mber::MberPtr<std::list<Mber::PaymentProvider>>(new std::list<Mber::PaymentProvider>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.paymentProviders->push_back(jsonToPaymentProvider(next));
            }
        }
        next = obj->get("offers");
        if( !next.isEmpty() ){
            result.offers = Mber::MberPtr<std::list<Mber::Offer>>(new std::list<Mber::Offer>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.offers->push_back(jsonToOffer(next));
            }
        }
        next = obj->get("expectedInputs");
        if( !next.isEmpty() ){
            result.expectedInputs = Mber::MberPtr<std::list<Mber::InvoiceExpectedItem>>(new std::list<Mber::InvoiceExpectedItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.expectedInputs->push_back(jsonToInvoiceExpectedItem(next));
            }
        }
        next = obj->get("expectedOutputs");
        if( !next.isEmpty() ){
            result.expectedOutputs = Mber::MberPtr<std::list<Mber::InvoiceExpectedItem>>(new std::list<Mber::InvoiceExpectedItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.expectedOutputs->push_back(jsonToInvoiceExpectedItem(next));
            }
        }
        next = obj->get("realMoneyTotal");
        if( !next.isEmpty() ){
            result.realMoneyTotal = Mber::MberPtr<double>(new double);
            *result.realMoneyTotal = next;
        }
        next = obj->get("createdTime");
        if( !next.isEmpty() ){
            result.createdTime = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.createdTime = (UInt64)next;
        }
        next = obj->get("updatedTime");
        if( !next.isEmpty() ){
            result.updatedTime = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.updatedTime = (UInt64)next;
        }
        return result;
    };
    Object InvoiceToJson(Mber::Invoice &value){
        Object result;        
        
        result.set("invoiceId", toJson(value.invoiceId));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("status", toJson(value.status));
        
        if( !value.storeId.isNull() ){
            result.set("storeId", toJson(*value.storeId));
        }
        
        if( !value.paymentProviders.isNull() ){
            for (std::list<Mber::PaymentProvider>::const_iterator iterator = value.paymentProviders->begin(), end = value.paymentProviders->end(); iterator != end; ++iterator) {
                Mber::PaymentProvider next = *iterator;
                result.set("paymentProviders", PaymentProviderToJson(next));
            }
        }
        
        if( !value.offers.isNull() ){
            for (std::list<Mber::Offer>::const_iterator iterator = value.offers->begin(), end = value.offers->end(); iterator != end; ++iterator) {
                Mber::Offer next = *iterator;
                result.set("offers", OfferToJson(next));
            }
        }
        
        if( !value.expectedInputs.isNull() ){
            for (std::list<Mber::InvoiceExpectedItem>::const_iterator iterator = value.expectedInputs->begin(), end = value.expectedInputs->end(); iterator != end; ++iterator) {
                Mber::InvoiceExpectedItem next = *iterator;
                result.set("expectedInputs", InvoiceExpectedItemToJson(next));
            }
        }
        
        if( !value.expectedOutputs.isNull() ){
            for (std::list<Mber::InvoiceExpectedItem>::const_iterator iterator = value.expectedOutputs->begin(), end = value.expectedOutputs->end(); iterator != end; ++iterator) {
                Mber::InvoiceExpectedItem next = *iterator;
                result.set("expectedOutputs", InvoiceExpectedItemToJson(next));
            }
        }
        
        if( !value.realMoneyTotal.isNull() ){
            result.set("realMoneyTotal", toJson(*value.realMoneyTotal));
        }
        
        if( !value.createdTime.isNull() ){
            result.set("createdTime", toJson(*value.createdTime));
        }
        
        if( !value.updatedTime.isNull() ){
            result.set("updatedTime", toJson(*value.updatedTime));
        }
        
        return result;
    };
    Mber::InvoiceActualItem jsonToInvoiceActualItem(Var &json){
        Mber::InvoiceActualItem result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("itemId");
        if( !next.isEmpty() ){
            result.itemId = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = jsonToInvoiceItemStatus(next);
        }
        next = obj->get("owner");
        if( !next.isEmpty() ){
            result.owner = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.owner = jsonToEntityPointer(next);
        }
        return result;
    };
    Object InvoiceActualItemToJson(Mber::InvoiceActualItem &value){
        Object result;        
        
        result.set("itemId", toJson(value.itemId));
        
        result.set("status", toJson(value.status));
        
        if( !value.owner.isNull() ){
            result.set("owner", EntityPointerToJson(*value.owner));
        }
        
        return result;
    };
    Mber::InvoiceExpectedItem jsonToInvoiceExpectedItem(Var &json){
        Mber::InvoiceExpectedItem result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("item");
        if( !next.isEmpty() ){
            result.item = jsonToEntityPointer(next);
        }
        next = obj->get("amount");
        if( !next.isEmpty() ){
            result.amount = next;
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = jsonToInvoiceItemStatus(next);
        }
        next = obj->get("actualItems");
        if( !next.isEmpty() ){
            result.actualItems = Mber::MberPtr<std::list<Mber::InvoiceActualItem>>(new std::list<Mber::InvoiceActualItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.actualItems->push_back(jsonToInvoiceActualItem(next));
            }
        }
        next = obj->get("associatedInput");
        if( !next.isEmpty() ){
            result.associatedInput = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.associatedInput = jsonToEntityPointer(next);
        }
        return result;
    };
    Object InvoiceExpectedItemToJson(Mber::InvoiceExpectedItem &value){
        Object result;        
        
        result.set("item", EntityPointerToJson(value.item));
        
        result.set("amount", toJson(value.amount));
        
        result.set("status", toJson(value.status));
        
        if( !value.actualItems.isNull() ){
            for (std::list<Mber::InvoiceActualItem>::const_iterator iterator = value.actualItems->begin(), end = value.actualItems->end(); iterator != end; ++iterator) {
                Mber::InvoiceActualItem next = *iterator;
                result.set("actualItems", InvoiceActualItemToJson(next));
            }
        }
        
        if( !value.associatedInput.isNull() ){
            result.set("associatedInput", EntityPointerToJson(*value.associatedInput));
        }
        
        return result;
    };
    Mber::InvoicePurchase jsonToInvoicePurchase(Var &json){
        Mber::InvoicePurchase result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("currencyCode");
        if( !next.isEmpty() ){
            result.currencyCode = Mber::MberPtr<Mber::CurrencyCode>(new Mber::CurrencyCode);
            *result.currencyCode = jsonToCurrencyCode(next);
        }
        next = obj->get("realMoneyInput");
        if( !next.isEmpty() ){
            result.realMoneyInput = Mber::MberPtr<Mber::RealMoneyInput>(new Mber::RealMoneyInput);
            *result.realMoneyInput = jsonToRealMoneyInput(next);
        }
        next = obj->get("providerType");
        if( !next.isEmpty() ){
            result.providerType = Mber::MberPtr<Mber::RealMoneyTransactionProvider>(new Mber::RealMoneyTransactionProvider);
            *result.providerType = jsonToRealMoneyTransactionProvider(next);
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("invoiceId");
        if( !next.isEmpty() ){
            result.invoiceId = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("storeId");
        if( !next.isEmpty() ){
            result.storeId = next.convert<std::string>();
        }
        next = obj->get("offers");
        if( !next.isEmpty() ){
            result.offers = Mber::MberPtr<std::list<Mber::Offer>>(new std::list<Mber::Offer>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.offers->push_back(jsonToOffer(next));
            }
        }
        next = obj->get("expectedInputs");
        if( !next.isEmpty() ){
            result.expectedInputs = Mber::MberPtr<std::list<Mber::InvoiceExpectedItem>>(new std::list<Mber::InvoiceExpectedItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.expectedInputs->push_back(jsonToInvoiceExpectedItem(next));
            }
        }
        next = obj->get("expectedOutputs");
        if( !next.isEmpty() ){
            result.expectedOutputs = Mber::MberPtr<std::list<Mber::InvoiceExpectedItem>>(new std::list<Mber::InvoiceExpectedItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.expectedOutputs->push_back(jsonToInvoiceExpectedItem(next));
            }
        }
        next = obj->get("invoiceSource");
        if( !next.isEmpty() ){
            result.invoiceSource = Mber::MberPtr<Mber::InvoiceSource>(new Mber::InvoiceSource);
            *result.invoiceSource = jsonToInvoiceSource(next);
        }
        return result;
    };
    Object InvoicePurchaseToJson(Mber::InvoicePurchase &value){
        Object result;        
        
        if( !value.currencyCode.isNull() ){
            result.set("currencyCode", toJson(*value.currencyCode));
        }
        
        if( !value.realMoneyInput.isNull() ){
            result.set("realMoneyInput", RealMoneyInputToJson(*value.realMoneyInput));
        }
        
        if( !value.providerType.isNull() ){
            result.set("providerType", toJson(*value.providerType));
        }
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("invoiceId", toJson(value.invoiceId));
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("storeId", toJson(value.storeId));
        
        if( !value.offers.isNull() ){
            for (std::list<Mber::Offer>::const_iterator iterator = value.offers->begin(), end = value.offers->end(); iterator != end; ++iterator) {
                Mber::Offer next = *iterator;
                result.set("offers", OfferToJson(next));
            }
        }
        
        if( !value.expectedInputs.isNull() ){
            for (std::list<Mber::InvoiceExpectedItem>::const_iterator iterator = value.expectedInputs->begin(), end = value.expectedInputs->end(); iterator != end; ++iterator) {
                Mber::InvoiceExpectedItem next = *iterator;
                result.set("expectedInputs", InvoiceExpectedItemToJson(next));
            }
        }
        
        if( !value.expectedOutputs.isNull() ){
            for (std::list<Mber::InvoiceExpectedItem>::const_iterator iterator = value.expectedOutputs->begin(), end = value.expectedOutputs->end(); iterator != end; ++iterator) {
                Mber::InvoiceExpectedItem next = *iterator;
                result.set("expectedOutputs", InvoiceExpectedItemToJson(next));
            }
        }
        
        if( !value.invoiceSource.isNull() ){
            result.set("invoiceSource", toJson(*value.invoiceSource));
        }
        
        return result;
    };
    Mber::InvoiceStatusSummary jsonToInvoiceStatusSummary(Var &json){
        Mber::InvoiceStatusSummary result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("invoiceId");
        if( !next.isEmpty() ){
            result.invoiceId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = jsonToInvoiceStatus(next);
        }
        next = obj->get("storeId");
        if( !next.isEmpty() ){
            result.storeId = Mber::MberPtr<std::string>(new std::string);
            *result.storeId = next.convert<std::string>();
        }
        return result;
    };
    Object InvoiceStatusSummaryToJson(Mber::InvoiceStatusSummary &value){
        Object result;        
        
        result.set("invoiceId", toJson(value.invoiceId));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("status", toJson(value.status));
        
        if( !value.storeId.isNull() ){
            result.set("storeId", toJson(*value.storeId));
        }
        
        return result;
    };
    Mber::MerchantReference jsonToMerchantReference(Var &json){
        Mber::MerchantReference result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("invoiceId");
        if( !next.isEmpty() ){
            result.invoiceId = next.convert<std::string>();
        }
        next = obj->get("providerId");
        if( !next.isEmpty() ){
            result.providerId = next.convert<std::string>();
        }
        return result;
    };
    Object MerchantReferenceToJson(Mber::MerchantReference &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("invoiceId", toJson(value.invoiceId));
        
        result.set("providerId", toJson(value.providerId));
        
        return result;
    };
    Mber::Offer jsonToOffer(Var &json){
        Mber::Offer result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("offerId");
        if( !next.isEmpty() ){
            result.offerId = next.convert<std::string>();
        }
        next = obj->get("application");
        if( !next.isEmpty() ){
            result.application = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("stock");
        if( !next.isEmpty() ){
            result.stock = Mber::MberPtr<int>(new int);
            *result.stock = next;
        }
        next = obj->get("inputs");
        if( !next.isEmpty() ){
            result.inputs = Mber::MberPtr<std::list<Mber::OfferItem>>(new std::list<Mber::OfferItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.inputs->push_back(jsonToOfferItem(next));
            }
        }
        next = obj->get("outputs");
        if( !next.isEmpty() ){
            result.outputs = Mber::MberPtr<std::list<Mber::OfferItem>>(new std::list<Mber::OfferItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.outputs->push_back(jsonToOfferItem(next));
            }
        }
        next = obj->get("categories");
        if( !next.isEmpty() ){
            result.categories = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.categories->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("rewards");
        if( !next.isEmpty() ){
            result.rewards = Mber::MberPtr<std::list<Mber::OfferItem>>(new std::list<Mber::OfferItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.rewards->push_back(jsonToOfferItem(next));
            }
        }
        return result;
    };
    Object OfferToJson(Mber::Offer &value){
        Object result;        
        
        result.set("offerId", toJson(value.offerId));
        
        result.set("application", toJson(value.application));
        
        result.set("name", toJson(value.name));
        
        if( !value.stock.isNull() ){
            result.set("stock", toJson(*value.stock));
        }
        
        if( !value.inputs.isNull() ){
            for (std::list<Mber::OfferItem>::const_iterator iterator = value.inputs->begin(), end = value.inputs->end(); iterator != end; ++iterator) {
                Mber::OfferItem next = *iterator;
                result.set("inputs", OfferItemToJson(next));
            }
        }
        
        if( !value.outputs.isNull() ){
            for (std::list<Mber::OfferItem>::const_iterator iterator = value.outputs->begin(), end = value.outputs->end(); iterator != end; ++iterator) {
                Mber::OfferItem next = *iterator;
                result.set("outputs", OfferItemToJson(next));
            }
        }
        
        if( !value.categories.isNull() ){
            result.set("categories", toJson(*value.categories));
        }
        
        if( !value.rewards.isNull() ){
            for (std::list<Mber::OfferItem>::const_iterator iterator = value.rewards->begin(), end = value.rewards->end(); iterator != end; ++iterator) {
                Mber::OfferItem next = *iterator;
                result.set("rewards", OfferItemToJson(next));
            }
        }
        
        return result;
    };
    Mber::OfferItem jsonToOfferItem(Var &json){
        Mber::OfferItem result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("item");
        if( !next.isEmpty() ){
            result.item = jsonToEntityPointer(next);
        }
        next = obj->get("amount");
        if( !next.isEmpty() ){
            result.amount = next;
        }
        next = obj->get("associatedInput");
        if( !next.isEmpty() ){
            result.associatedInput = Mber::MberPtr<Mber::EntityPointer>(new Mber::EntityPointer);
            *result.associatedInput = jsonToEntityPointer(next);
        }
        return result;
    };
    Object OfferItemToJson(Mber::OfferItem &value){
        Object result;        
        
        result.set("item", EntityPointerToJson(value.item));
        
        result.set("amount", toJson(value.amount));
        
        if( !value.associatedInput.isNull() ){
            result.set("associatedInput", EntityPointerToJson(*value.associatedInput));
        }
        
        return result;
    };
    Mber::OfferPurchase jsonToOfferPurchase(Var &json){
        Mber::OfferPurchase result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("offerId");
        if( !next.isEmpty() ){
            result.offerId = next.convert<std::string>();
        }
        next = obj->get("application");
        if( !next.isEmpty() ){
            result.application = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("inputs");
        if( !next.isEmpty() ){
            result.inputs = Mber::MberPtr<std::list<Mber::OfferItem>>(new std::list<Mber::OfferItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.inputs->push_back(jsonToOfferItem(next));
            }
        }
        next = obj->get("outputs");
        if( !next.isEmpty() ){
            result.outputs = Mber::MberPtr<std::list<Mber::OfferItem>>(new std::list<Mber::OfferItem>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.outputs->push_back(jsonToOfferItem(next));
            }
        }
        next = obj->get("invoiceId");
        if( !next.isEmpty() ){
            result.invoiceId = next.convert<std::string>();
        }
        return result;
    };
    Object OfferPurchaseToJson(Mber::OfferPurchase &value){
        Object result;        
        
        result.set("offerId", toJson(value.offerId));
        
        result.set("application", toJson(value.application));
        
        result.set("name", toJson(value.name));
        
        if( !value.inputs.isNull() ){
            for (std::list<Mber::OfferItem>::const_iterator iterator = value.inputs->begin(), end = value.inputs->end(); iterator != end; ++iterator) {
                Mber::OfferItem next = *iterator;
                result.set("inputs", OfferItemToJson(next));
            }
        }
        
        if( !value.outputs.isNull() ){
            for (std::list<Mber::OfferItem>::const_iterator iterator = value.outputs->begin(), end = value.outputs->end(); iterator != end; ++iterator) {
                Mber::OfferItem next = *iterator;
                result.set("outputs", OfferItemToJson(next));
            }
        }
        
        result.set("invoiceId", toJson(value.invoiceId));
        
        return result;
    };
    Mber::PaymentProvider jsonToPaymentProvider(Var &json){
        Mber::PaymentProvider result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("provider");
        if( !next.isEmpty() ){
            result.provider = jsonToRealMoneyTransactionProvider(next);
        }
        next = obj->get("providerUrl");
        if( !next.isEmpty() ){
            result.providerUrl = next.convert<std::string>();
        }
        next = obj->get("merchantId");
        if( !next.isEmpty() ){
            result.merchantId = Mber::MberPtr<std::string>(new std::string);
            *result.merchantId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = Mber::MberPtr<std::string>(new std::string);
            *result.applicationId = next.convert<std::string>();
        }
        next = obj->get("providerId");
        if( !next.isEmpty() ){
            result.providerId = Mber::MberPtr<std::string>(new std::string);
            *result.providerId = next.convert<std::string>();
        }
        next = obj->get("isActive");
        if( !next.isEmpty() ){
            result.isActive = next;
        }
        next = obj->get("paymentPageId");
        if( !next.isEmpty() ){
            result.paymentPageId = Mber::MberPtr<std::string>(new std::string);
            *result.paymentPageId = next.convert<std::string>();
        }
        next = obj->get("paymentPageUri");
        if( !next.isEmpty() ){
            result.paymentPageUri = Mber::MberPtr<std::string>(new std::string);
            *result.paymentPageUri = next.convert<std::string>();
        }
        next = obj->get("notificationUri");
        if( !next.isEmpty() ){
            result.notificationUri = Mber::MberPtr<std::string>(new std::string);
            *result.notificationUri = next.convert<std::string>();
        }
        next = obj->get("testMode");
        if( !next.isEmpty() ){
            result.testMode = Mber::MberPtr<bool>(new bool);
            *result.testMode = next;
        }
        return result;
    };
    Object PaymentProviderToJson(Mber::PaymentProvider &value){
        Object result;        
        
        result.set("provider", toJson(value.provider));
        
        result.set("providerUrl", toJson(value.providerUrl));
        
        if( !value.merchantId.isNull() ){
            result.set("merchantId", toJson(*value.merchantId));
        }
        
        if( !value.applicationId.isNull() ){
            result.set("applicationId", toJson(*value.applicationId));
        }
        
        if( !value.providerId.isNull() ){
            result.set("providerId", toJson(*value.providerId));
        }
        
        result.set("isActive", toJson(value.isActive));
        
        if( !value.paymentPageId.isNull() ){
            result.set("paymentPageId", toJson(*value.paymentPageId));
        }
        
        if( !value.paymentPageUri.isNull() ){
            result.set("paymentPageUri", toJson(*value.paymentPageUri));
        }
        
        if( !value.notificationUri.isNull() ){
            result.set("notificationUri", toJson(*value.notificationUri));
        }
        
        if( !value.testMode.isNull() ){
            result.set("testMode", toJson(*value.testMode));
        }
        
        return result;
    };
    Mber::RealCurrency jsonToRealCurrency(Var &json){
        Mber::RealCurrency result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("currencyId");
        if( !next.isEmpty() ){
            result.currencyId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = jsonToCurrencyCode(next);
        }
        next = obj->get("decsription");
        if( !next.isEmpty() ){
            result.decsription = next.convert<std::string>();
        }
        return result;
    };
    Object RealCurrencyToJson(Mber::RealCurrency &value){
        Object result;        
        
        result.set("currencyId", toJson(value.currencyId));
        
        result.set("name", toJson(value.name));
        
        result.set("decsription", toJson(value.decsription));
        
        return result;
    };
    Mber::RealMoneyInput jsonToRealMoneyInput(Var &json){
        Mber::RealMoneyInput result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("provider");
        if( !next.isEmpty() ){
            result.provider = next.convert<std::string>();
        }
        next = obj->get("providerToken");
        if( !next.isEmpty() ){
            result.providerToken = Mber::MberPtr<std::string>(new std::string);
            *result.providerToken = next.convert<std::string>();
        }
        next = obj->get("amount");
        if( !next.isEmpty() ){
            result.amount = next;
        }
        return result;
    };
    Object RealMoneyInputToJson(Mber::RealMoneyInput &value){
        Object result;        
        
        result.set("provider", toJson(value.provider));
        
        if( !value.providerToken.isNull() ){
            result.set("providerToken", toJson(*value.providerToken));
        }
        
        result.set("amount", toJson(value.amount));
        
        return result;
    };
    Mber::Referral jsonToReferral(Var &json){
        Mber::Referral result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("referrerId");
        if( !next.isEmpty() ){
            result.referrerId = jsonToEntityPointer(next);
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        return result;
    };
    Object ReferralToJson(Mber::Referral &value){
        Object result;        
        
        result.set("referrerId", EntityPointerToJson(value.referrerId));
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("applicationId", toJson(value.applicationId));
        
        return result;
    };
    Mber::ReferralCount jsonToReferralCount(Var &json){
        Mber::ReferralCount result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("count");
        if( !next.isEmpty() ){
            result.count = next;
        }
        next = obj->get("referrer");
        if( !next.isEmpty() ){
            result.referrer = jsonToEntityPointer(next);
        }
        return result;
    };
    Object ReferralCountToJson(Mber::ReferralCount &value){
        Object result;        
        
        result.set("count", toJson(value.count));
        
        result.set("referrer", EntityPointerToJson(value.referrer));
        
        return result;
    };
    Mber::ReferralEntityTotals jsonToReferralEntityTotals(Var &json){
        Mber::ReferralEntityTotals result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("referrer");
        if( !next.isEmpty() ){
            result.referrer = jsonToEntityPointer(next);
        }
        next = obj->get("totals");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.totals.push_back(jsonToEntityTotal(next));
            }
        }
        return result;
    };
    Object ReferralEntityTotalsToJson(Mber::ReferralEntityTotals &value){
        Object result;        
        
        result.set("referrer", EntityPointerToJson(value.referrer));
        
        for (std::list<Mber::EntityTotal>::const_iterator iterator = value.totals.begin(), end = value.totals.end(); iterator != end; ++iterator) {
            Mber::EntityTotal next = *iterator;
            result.set("totals", EntityTotalToJson(next));
        }
        
        return result;
    };
    Mber::Store jsonToStore(Var &json){
        Mber::Store result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("storeId");
        if( !next.isEmpty() ){
            result.storeId = next.convert<std::string>();
        }
        next = obj->get("application");
        if( !next.isEmpty() ){
            result.application = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("offers");
        if( !next.isEmpty() ){
            result.offers = Mber::MberPtr<std::list<Mber::Offer>>(new std::list<Mber::Offer>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.offers->push_back(jsonToOffer(next));
            }
        }
        return result;
    };
    Object StoreToJson(Mber::Store &value){
        Object result;        
        
        result.set("storeId", toJson(value.storeId));
        
        result.set("application", toJson(value.application));
        
        result.set("name", toJson(value.name));
        
        if( !value.offers.isNull() ){
            for (std::list<Mber::Offer>::const_iterator iterator = value.offers->begin(), end = value.offers->end(); iterator != end; ++iterator) {
                Mber::Offer next = *iterator;
                result.set("offers", OfferToJson(next));
            }
        }
        
        return result;
    };
    Mber::VirtualCurrency jsonToVirtualCurrency(Var &json){
        Mber::VirtualCurrency result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("virtualCurrencyId");
        if( !next.isEmpty() ){
            result.virtualCurrencyId = next.convert<std::string>();
        }
        next = obj->get("application");
        if( !next.isEmpty() ){
            result.application = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("disabledSpending");
        if( !next.isEmpty() ){
            result.disabledSpending = next;
        }
        next = obj->get("disabledEarning");
        if( !next.isEmpty() ){
            result.disabledEarning = next;
        }
        next = obj->get("deductionRule");
        if( !next.isEmpty() ){
            result.deductionRule = jsonToDeductionRule(next);
        }
        next = obj->get("walletTtl");
        if( !next.isEmpty() ){
            result.walletTtl = Mber::MberPtr<int>(new int);
            *result.walletTtl = next;
        }
        return result;
    };
    Object VirtualCurrencyToJson(Mber::VirtualCurrency &value){
        Object result;        
        
        result.set("virtualCurrencyId", toJson(value.virtualCurrencyId));
        
        result.set("application", toJson(value.application));
        
        result.set("name", toJson(value.name));
        
        result.set("disabledSpending", toJson(value.disabledSpending));
        
        result.set("disabledEarning", toJson(value.disabledEarning));
        
        result.set("deductionRule", DeductionRuleToJson(value.deductionRule));
        
        if( !value.walletTtl.isNull() ){
            result.set("walletTtl", toJson(*value.walletTtl));
        }
        
        return result;
    };
    Mber::VirtualCurrencyChange jsonToVirtualCurrencyChange(Var &json){
        Mber::VirtualCurrencyChange result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("virtualCurrencyId");
        if( !next.isEmpty() ){
            result.virtualCurrencyId = next.convert<std::string>();
        }
        next = obj->get("virtualCurrencyName");
        if( !next.isEmpty() ){
            result.virtualCurrencyName = next.convert<std::string>();
        }
        next = obj->get("currencyAmount");
        if( !next.isEmpty() ){
            result.currencyAmount = next;
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        return result;
    };
    Object VirtualCurrencyChangeToJson(Mber::VirtualCurrencyChange &value){
        Object result;        
        
        result.set("virtualCurrencyId", toJson(value.virtualCurrencyId));
        
        result.set("virtualCurrencyName", toJson(value.virtualCurrencyName));
        
        result.set("currencyAmount", toJson(value.currencyAmount));
        
        result.set("applicationId", toJson(value.applicationId));
        
        return result;
    };
    Mber::VirtualPurchase jsonToVirtualPurchase(Var &json){
        Mber::VirtualPurchase result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("virtualCurrency");
        if( !next.isEmpty() ){
            result.virtualCurrency = jsonToEntityPointer(next);
        }
        next = obj->get("reason");
        if( !next.isEmpty() ){
            result.reason = Mber::MberPtr<std::string>(new std::string);
            *result.reason = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("total");
        if( !next.isEmpty() ){
            result.total = next;
        }
        next = obj->get("walletLots");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.walletLots.push_back(jsonToWalletLot(next));
            }
        }
        next = obj->get("invoiceId");
        if( !next.isEmpty() ){
            result.invoiceId = Mber::MberPtr<std::string>(new std::string);
            *result.invoiceId = next.convert<std::string>();
        }
        next = obj->get("remainingBalance");
        if( !next.isEmpty() ){
            result.remainingBalance = Mber::MberPtr<double>(new double);
            *result.remainingBalance = next;
        }
        next = obj->get("purchaser");
        if( !next.isEmpty() ){
            result.purchaser = jsonToEntityPointer(next);
        }
        return result;
    };
    Object VirtualPurchaseToJson(Mber::VirtualPurchase &value){
        Object result;        
        
        result.set("virtualCurrency", EntityPointerToJson(value.virtualCurrency));
        
        if( !value.reason.isNull() ){
            result.set("reason", toJson(*value.reason));
        }
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("total", toJson(value.total));
        
        for (std::list<Mber::WalletLot>::const_iterator iterator = value.walletLots.begin(), end = value.walletLots.end(); iterator != end; ++iterator) {
            Mber::WalletLot next = *iterator;
            result.set("walletLots", WalletLotToJson(next));
        }
        
        if( !value.invoiceId.isNull() ){
            result.set("invoiceId", toJson(*value.invoiceId));
        }
        
        if( !value.remainingBalance.isNull() ){
            result.set("remainingBalance", toJson(*value.remainingBalance));
        }
        
        result.set("purchaser", EntityPointerToJson(value.purchaser));
        
        return result;
    };
    Mber::Wallet jsonToWallet(Var &json){
        Mber::Wallet result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("funds");
        if( !next.isEmpty() ){
            result.funds = Mber::MberPtr<std::list<Mber::WalletTotal>>(new std::list<Mber::WalletTotal>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.funds->push_back(jsonToWalletTotal(next));
            }
        }
        next = obj->get("owner");
        if( !next.isEmpty() ){
            result.owner = jsonToEntityPointer(next);
        }
        return result;
    };
    Object WalletToJson(Mber::Wallet &value){
        Object result;        
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("applicationId", toJson(value.applicationId));
        
        if( !value.funds.isNull() ){
            for (std::list<Mber::WalletTotal>::const_iterator iterator = value.funds->begin(), end = value.funds->end(); iterator != end; ++iterator) {
                Mber::WalletTotal next = *iterator;
                result.set("funds", WalletTotalToJson(next));
            }
        }
        
        result.set("owner", EntityPointerToJson(value.owner));
        
        return result;
    };
    Mber::WalletLot jsonToWalletLot(Var &json){
        Mber::WalletLot result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("lotId");
        if( !next.isEmpty() ){
            result.lotId = next.convert<std::string>();
        }
        next = obj->get("virtualCurrencyId");
        if( !next.isEmpty() ){
            result.virtualCurrencyId = next.convert<std::string>();
        }
        next = obj->get("profileId");
        if( !next.isEmpty() ){
            result.profileId = next.convert<std::string>();
        }
        next = obj->get("origin");
        if( !next.isEmpty() ){
            result.origin = jsonToEntityPointer(next);
        }
        next = obj->get("amount");
        if( !next.isEmpty() ){
            result.amount = next;
        }
        next = obj->get("timeCreated");
        if( !next.isEmpty() ){
            result.timeCreated = (UInt64)next;
        }
        next = obj->get("amountChange");
        if( !next.isEmpty() ){
            result.amountChange = Mber::MberPtr<double>(new double);
            *result.amountChange = next;
        }
        return result;
    };
    Object WalletLotToJson(Mber::WalletLot &value){
        Object result;        
        
        result.set("lotId", toJson(value.lotId));
        
        result.set("virtualCurrencyId", toJson(value.virtualCurrencyId));
        
        result.set("profileId", toJson(value.profileId));
        
        result.set("origin", EntityPointerToJson(value.origin));
        
        result.set("amount", toJson(value.amount));
        
        result.set("timeCreated", toJson(value.timeCreated));
        
        if( !value.amountChange.isNull() ){
            result.set("amountChange", toJson(*value.amountChange));
        }
        
        return result;
    };
    Mber::WalletTotal jsonToWalletTotal(Var &json){
        Mber::WalletTotal result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("virtualCurrencyId");
        if( !next.isEmpty() ){
            result.virtualCurrencyId = next.convert<std::string>();
        }
        next = obj->get("virtualCurrencyName");
        if( !next.isEmpty() ){
            result.virtualCurrencyName = next.convert<std::string>();
        }
        next = obj->get("total");
        if( !next.isEmpty() ){
            result.total = next;
        }
        return result;
    };
    Object WalletTotalToJson(Mber::WalletTotal &value){
        Object result;        
        
        result.set("virtualCurrencyId", toJson(value.virtualCurrencyId));
        
        result.set("virtualCurrencyName", toJson(value.virtualCurrencyName));
        
        result.set("total", toJson(value.total));
        
        return result;
    };
    Mber::Heartbeat jsonToHeartbeat(Var &json){
        Mber::Heartbeat result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("serverId");
        if( !next.isEmpty() ){
            result.serverId = next.convert<std::string>();
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = Mber::MberPtr<std::string>(new std::string);
            *result.status = next.convert<std::string>();
        }
        next = obj->get("time");
        if( !next.isEmpty() ){
            result.time = (UInt64)next;
        }
        next = obj->get("currentUsers");
        if( !next.isEmpty() ){
            result.currentUsers = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.currentUsers = (UInt64)next;
        }
        next = obj->get("userCapacity");
        if( !next.isEmpty() ){
            result.userCapacity = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.userCapacity = (UInt64)next;
        }
        next = obj->get("utilization");
        if( !next.isEmpty() ){
            result.utilization = Mber::MberPtr<double>(new double);
            *result.utilization = next;
        }
        return result;
    };
    Object HeartbeatToJson(Mber::Heartbeat &value){
        Object result;        
        
        result.set("serverId", toJson(value.serverId));
        
        if( !value.status.isNull() ){
            result.set("status", toJson(*value.status));
        }
        
        result.set("time", toJson(value.time));
        
        if( !value.currentUsers.isNull() ){
            result.set("currentUsers", toJson(*value.currentUsers));
        }
        
        if( !value.userCapacity.isNull() ){
            result.set("userCapacity", toJson(*value.userCapacity));
        }
        
        if( !value.utilization.isNull() ){
            result.set("utilization", toJson(*value.utilization));
        }
        
        return result;
    };
    Mber::Lobby jsonToLobby(Var &json){
        Mber::Lobby result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("lobbyId");
        if( !next.isEmpty() ){
            result.lobbyId = next.convert<std::string>();
        }
        next = obj->get("serverId");
        if( !next.isEmpty() ){
            result.serverId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("profiles");
        if( !next.isEmpty() ){
            result.profiles = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.profiles->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("addProfiles");
        if( !next.isEmpty() ){
            result.addProfiles = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.addProfiles->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("removeProfiles");
        if( !next.isEmpty() ){
            result.removeProfiles = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.removeProfiles->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object LobbyToJson(Mber::Lobby &value){
        Object result;        
        
        result.set("lobbyId", toJson(value.lobbyId));
        
        result.set("serverId", toJson(value.serverId));
        
        result.set("name", toJson(value.name));
        
        if( !value.profiles.isNull() ){
            result.set("profiles", toJson(*value.profiles));
        }
        
        if( !value.addProfiles.isNull() ){
            result.set("addProfiles", toJson(*value.addProfiles));
        }
        
        if( !value.removeProfiles.isNull() ){
            result.set("removeProfiles", toJson(*value.removeProfiles));
        }
        
        return result;
    };
    Mber::Server jsonToServer(Var &json){
        Mber::Server result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("serverId");
        if( !next.isEmpty() ){
            result.serverId = next.convert<std::string>();
        }
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("host");
        if( !next.isEmpty() ){
            result.host = next.convert<std::string>();
        }
        next = obj->get("port");
        if( !next.isEmpty() ){
            result.port = Mber::MberPtr<int>(new int);
            *result.port = next;
        }
        next = obj->get("state");
        if( !next.isEmpty() ){
            result.state = jsonToServerState(next);
        }
        next = obj->get("heartbeatInterval");
        if( !next.isEmpty() ){
            result.heartbeatInterval = Mber::MberPtr<int>(new int);
            *result.heartbeatInterval = next;
        }
        next = obj->get("lastHeartbeat");
        if( !next.isEmpty() ){
            result.lastHeartbeat = Mber::MberPtr<long>(new long);
            *result.lastHeartbeat = next;
        }
        next = obj->get("status");
        if( !next.isEmpty() ){
            result.status = Mber::MberPtr<std::string>(new std::string);
            *result.status = next.convert<std::string>();
        }
        next = obj->get("serverType");
        if( !next.isEmpty() ){
            result.serverType = next.convert<std::string>();
        }
        next = obj->get("currentUsers");
        if( !next.isEmpty() ){
            result.currentUsers = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.currentUsers = (UInt64)next;
        }
        next = obj->get("userCapacity");
        if( !next.isEmpty() ){
            result.userCapacity = Mber::MberPtr<uint64_t>(new uint64_t);
            *result.userCapacity = (UInt64)next;
        }
        next = obj->get("utilization");
        if( !next.isEmpty() ){
            result.utilization = Mber::MberPtr<double>(new double);
            *result.utilization = next;
        }
        return result;
    };
    Object ServerToJson(Mber::Server &value){
        Object result;        
        
        result.set("serverId", toJson(value.serverId));
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("name", toJson(value.name));
        
        result.set("host", toJson(value.host));
        
        if( !value.port.isNull() ){
            result.set("port", toJson(*value.port));
        }
        
        result.set("state", toJson(value.state));
        
        if( !value.heartbeatInterval.isNull() ){
            result.set("heartbeatInterval", toJson(*value.heartbeatInterval));
        }
        
        if( !value.lastHeartbeat.isNull() ){
            result.set("lastHeartbeat", toJson(*value.lastHeartbeat));
        }
        
        if( !value.status.isNull() ){
            result.set("status", toJson(*value.status));
        }
        
        result.set("serverType", toJson(value.serverType));
        
        if( !value.currentUsers.isNull() ){
            result.set("currentUsers", toJson(*value.currentUsers));
        }
        
        if( !value.userCapacity.isNull() ){
            result.set("userCapacity", toJson(*value.userCapacity));
        }
        
        if( !value.utilization.isNull() ){
            result.set("utilization", toJson(*value.utilization));
        }
        
        return result;
    };
    Mber::DocumentMessage jsonToDocumentMessage(Var &json){
        Mber::DocumentMessage result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("documentIds");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.documentIds.push_back(next.convert<std::string>());
            }
        }
        next = obj->get("properties");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.properties.push_back(jsonToReplacementProperty(next));
            }
        }
        next = obj->get("subject");
        if( !next.isEmpty() ){
            result.subject = Mber::MberPtr<std::string>(new std::string);
            *result.subject = next.convert<std::string>();
        }
        return result;
    };
    Object DocumentMessageToJson(Mber::DocumentMessage &value){
        Object result;        
        
        result.set("documentIds", toJson(value.documentIds));
        
        for (std::list<Mber::ReplacementProperty>::const_iterator iterator = value.properties.begin(), end = value.properties.end(); iterator != end; ++iterator) {
            Mber::ReplacementProperty next = *iterator;
            result.set("properties", ReplacementPropertyToJson(next));
        }
        
        if( !value.subject.isNull() ){
            result.set("subject", toJson(*value.subject));
        }
        
        return result;
    };
    Mber::EmailConfig jsonToEmailConfig(Var &json){
        Mber::EmailConfig result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("host");
        if( !next.isEmpty() ){
            result.host = next.convert<std::string>();
        }
        next = obj->get("port");
        if( !next.isEmpty() ){
            result.port = Mber::MberPtr<int>(new int);
            *result.port = next;
        }
        next = obj->get("useSsl");
        if( !next.isEmpty() ){
            result.useSsl = next;
        }
        next = obj->get("useTls");
        if( !next.isEmpty() ){
            result.useTls = next;
        }
        next = obj->get("userName");
        if( !next.isEmpty() ){
            result.userName = Mber::MberPtr<std::string>(new std::string);
            *result.userName = next.convert<std::string>();
        }
        next = obj->get("password");
        if( !next.isEmpty() ){
            result.password = Mber::MberPtr<std::string>(new std::string);
            *result.password = next.convert<std::string>();
        }
        next = obj->get("senderEmail");
        if( !next.isEmpty() ){
            result.senderEmail = next.convert<std::string>();
        }
        next = obj->get("senderName");
        if( !next.isEmpty() ){
            result.senderName = Mber::MberPtr<std::string>(new std::string);
            *result.senderName = next.convert<std::string>();
        }
        return result;
    };
    Object EmailConfigToJson(Mber::EmailConfig &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        result.set("host", toJson(value.host));
        
        if( !value.port.isNull() ){
            result.set("port", toJson(*value.port));
        }
        
        result.set("useSsl", toJson(value.useSsl));
        
        result.set("useTls", toJson(value.useTls));
        
        if( !value.userName.isNull() ){
            result.set("userName", toJson(*value.userName));
        }
        
        if( !value.password.isNull() ){
            result.set("password", toJson(*value.password));
        }
        
        result.set("senderEmail", toJson(value.senderEmail));
        
        if( !value.senderName.isNull() ){
            result.set("senderName", toJson(*value.senderName));
        }
        
        return result;
    };
    Mber::EmailMessage jsonToEmailMessage(Var &json){
        Mber::EmailMessage result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("applicationId");
        if( !next.isEmpty() ){
            result.applicationId = next.convert<std::string>();
        }
        next = obj->get("to");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.to.push_back(jsonToEntityPointer(next));
            }
        }
        next = obj->get("cc");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.cc.push_back(jsonToEntityPointer(next));
            }
        }
        next = obj->get("bcc");
        if( !next.isEmpty() ){
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.bcc.push_back(jsonToEntityPointer(next));
            }
        }
        next = obj->get("documentMessage");
        if( !next.isEmpty() ){
            result.documentMessage = Mber::MberPtr<Mber::DocumentMessage>(new Mber::DocumentMessage);
            *result.documentMessage = jsonToDocumentMessage(next);
        }
        next = obj->get("stringMessage");
        if( !next.isEmpty() ){
            result.stringMessage = Mber::MberPtr<Mber::StringMessage>(new Mber::StringMessage);
            *result.stringMessage = jsonToStringMessage(next);
        }
        next = obj->get("sendToUnvalidatedEmails");
        if( !next.isEmpty() ){
            result.sendToUnvalidatedEmails = Mber::MberPtr<bool>(new bool);
            *result.sendToUnvalidatedEmails = next;
        }
        return result;
    };
    Object EmailMessageToJson(Mber::EmailMessage &value){
        Object result;        
        
        result.set("applicationId", toJson(value.applicationId));
        
        for (std::list<Mber::EntityPointer>::const_iterator iterator = value.to.begin(), end = value.to.end(); iterator != end; ++iterator) {
            Mber::EntityPointer next = *iterator;
            result.set("to", EntityPointerToJson(next));
        }
        
        for (std::list<Mber::EntityPointer>::const_iterator iterator = value.cc.begin(), end = value.cc.end(); iterator != end; ++iterator) {
            Mber::EntityPointer next = *iterator;
            result.set("cc", EntityPointerToJson(next));
        }
        
        for (std::list<Mber::EntityPointer>::const_iterator iterator = value.bcc.begin(), end = value.bcc.end(); iterator != end; ++iterator) {
            Mber::EntityPointer next = *iterator;
            result.set("bcc", EntityPointerToJson(next));
        }
        
        if( !value.documentMessage.isNull() ){
            result.set("documentMessage", DocumentMessageToJson(*value.documentMessage));
        }
        
        if( !value.stringMessage.isNull() ){
            result.set("stringMessage", StringMessageToJson(*value.stringMessage));
        }
        
        if( !value.sendToUnvalidatedEmails.isNull() ){
            result.set("sendToUnvalidatedEmails", toJson(*value.sendToUnvalidatedEmails));
        }
        
        return result;
    };
    Mber::ReplacementProperty jsonToReplacementProperty(Var &json){
        Mber::ReplacementProperty result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("variable");
        if( !next.isEmpty() ){
            result.variable = next.convert<std::string>();
        }
        next = obj->get("value");
        if( !next.isEmpty() ){
            result.value = next.convert<std::string>();
        }
        next = obj->get("useRegex");
        if( !next.isEmpty() ){
            result.useRegex = Mber::MberPtr<bool>(new bool);
            *result.useRegex = next;
        }
        return result;
    };
    Object ReplacementPropertyToJson(Mber::ReplacementProperty &value){
        Object result;        
        
        result.set("variable", toJson(value.variable));
        
        result.set("value", toJson(value.value));
        
        if( !value.useRegex.isNull() ){
            result.set("useRegex", toJson(*value.useRegex));
        }
        
        return result;
    };
    Mber::StringMessage jsonToStringMessage(Var &json){
        Mber::StringMessage result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("subject");
        if( !next.isEmpty() ){
            result.subject = Mber::MberPtr<std::string>(new std::string);
            *result.subject = next.convert<std::string>();
        }
        next = obj->get("body");
        if( !next.isEmpty() ){
            result.body = next.convert<std::string>();
        }
        return result;
    };
    Object StringMessageToJson(Mber::StringMessage &value){
        Object result;        
        
        if( !value.subject.isNull() ){
            result.set("subject", toJson(*value.subject));
        }
        
        result.set("body", toJson(value.body));
        
        return result;
    };
    Mber::Group jsonToGroup(Var &json){
        Mber::Group result;
        Object::Ptr obj = json.extract<Object::Ptr>();
        Var next;
        // bool empty = false;
        
        next = obj->get("groupId");
        if( !next.isEmpty() ){
            result.groupId = next.convert<std::string>();
        }
        next = obj->get("name");
        if( !next.isEmpty() ){
            result.name = next.convert<std::string>();
        }
        next = obj->get("parentId");
        if( !next.isEmpty() ){
            result.parentId = next.convert<std::string>();
        }
        next = obj->get("parentType");
        if( !next.isEmpty() ){
            result.parentType = jsonToEntityType(next);
        }
        next = obj->get("groupType");
        if( !next.isEmpty() ){
            result.groupType = jsonToEntityType(next);
        }
        next = obj->get("members");
        if( !next.isEmpty() ){
            result.members = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.members->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("addMembers");
        if( !next.isEmpty() ){
            result.addMembers = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.addMembers->push_back(next.convert<std::string>());
            }
        }
        next = obj->get("removeMembers");
        if( !next.isEmpty() ){
            result.removeMembers = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
            for( int i=0; i<nextArray->size(); i++ ){
                next = nextArray->get(i);
                result.removeMembers->push_back(next.convert<std::string>());
            }
        }
        return result;
    };
    Object GroupToJson(Mber::Group &value){
        Object result;        
        
        result.set("groupId", toJson(value.groupId));
        
        result.set("name", toJson(value.name));
        
        result.set("parentId", toJson(value.parentId));
        
        result.set("parentType", toJson(value.parentType));
        
        result.set("groupType", toJson(value.groupType));
        
        if( !value.members.isNull() ){
            result.set("members", toJson(*value.members));
        }
        
        if( !value.addMembers.isNull() ){
            result.set("addMembers", toJson(*value.addMembers));
        }
        
        if( !value.removeMembers.isNull() ){
            result.set("removeMembers", toJson(*value.removeMembers));
        }
        
        return result;
    };
    

    namespace account{
        namespace Account{
            namespace Create{
                // Mber::account::Account::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        accountId = 0;
                        masterProfileId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("accountId");
                        if( !next.isEmpty() ){
                            accountId = Mber::MberPtr<std::string>(new std::string);
                            *accountId = next.convert<std::string>();
                        }
                        
                        next = obj->get("masterProfileId");
                        if( !next.isEmpty() ){
                            masterProfileId = Mber::MberPtr<std::string>(new std::string);
                            *masterProfileId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string username,std::string password,Mber::Region region,Mber::MberPtr<uint64_t > dateOfBirth,Mber::MberPtr<std::string > displayname,Mber::MberPtr<std::string > email,Mber::EntityID sourceApplication,Mber::MberPtr<std::string > sourceReferredUrl,Mber::MberPtr<bool > forcePasswordReset,Mber::MberPtr<std::string > referringAccount,Mber::MberPtr<Mber::EntityPointer > referrer ){
                    m_username = username;
                    m_password = password;
                    m_region = region;
                    m_dateOfBirth = dateOfBirth;
                    m_displayname = displayname;
                    m_email = email;
                    m_sourceApplication = sourceApplication;
                    m_sourceReferredUrl = sourceReferredUrl;
                    m_forcePasswordReset = forcePasswordReset;
                    m_referringAccount = referringAccount;
                    m_referrer = referrer;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Account/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("username", m_username);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", m_password);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("region", m_region);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_dateOfBirth.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("dateOfBirth", *m_dateOfBirth);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_displayname.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("displayname", *m_displayname);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_email.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("email", *m_email);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("sourceApplication", (*(m_sourceApplication.id) != NULL) ? *(m_sourceApplication.id) : "'" + *(m_sourceApplication.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_sourceReferredUrl.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("sourceReferredUrl", *m_sourceReferredUrl);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_forcePasswordReset.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("forcePasswordReset", *m_forcePasswordReset);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_referringAccount.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("referringAccount", *m_referringAccount);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_referrer.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("referrer", EntityPointerToJson(*m_referrer));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::account::Account::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Account>(new Mber::Account);
                            *result = jsonToAccount(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string accountId ){
                    m_accountId = accountId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Account/";
                        Poco::URI::encode(m_accountId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&accountId=");
                        Poco::URI::encode(stringToString(m_accountId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Profile{
            namespace Read{
                // Mber::account::Profile::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Profile>(new Mber::Profile);
                            *result = jsonToProfile(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId ){
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Profile/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::account::Profile::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::MberPtr<std::string > username,Mber::MberPtr<std::string > password,Mber::MberPtr<Mber::Region > region,Mber::MberPtr<uint64_t > dateOfBirth,Mber::MberPtr<std::string > displayname,Mber::MberPtr<std::string > email,Mber::MberPtr<std::string > steamId,Mber::MberPtr<bool > preserveCurrentSteamId ){
                    m_profileId = profileId;
                    m_username = username;
                    m_password = password;
                    m_region = region;
                    m_dateOfBirth = dateOfBirth;
                    m_displayname = displayname;
                    m_email = email;
                    m_steamId = steamId;
                    m_preserveCurrentSteamId = preserveCurrentSteamId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Profile/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_username.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("username", *m_username);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_password.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", *m_password);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_region.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("region", *m_region);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_dateOfBirth.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("dateOfBirth", *m_dateOfBirth);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_displayname.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("displayname", *m_displayname);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_email.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("email", *m_email);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_steamId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("steamId", *m_steamId);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_preserveCurrentSteamId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("preserveCurrentSteamId", *m_preserveCurrentSteamId);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::account::Profile::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                        status = someStatus;
                        errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId ){
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Profile/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::account::Profile::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Profile>>(new std::list<Mber::Profile>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToProfile(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::string > displayName,Mber::MberPtr<std::string > userName,Mber::MberPtr<std::string > email ){
                    m_displayName = displayName;
                    m_userName = userName;
                    m_email = email;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Profile/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_displayName.isNull() ){Poco::URI::encode(stringToString(*m_displayName), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_userName.isNull() ){Poco::URI::encode(stringToString(*m_userName), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_email.isNull() ){Poco::URI::encode(stringToString(*m_email), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileEnable{
            namespace Create{
                // Mber::account::ProfileEnable::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId ){
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileEnable/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::account::ProfileEnable::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId ){
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileEnable/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileQuery{
            namespace Create{
                // Mber::account::ProfileQuery::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Profile>>(new std::list<Mber::Profile>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToProfile(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::Query query ){
                    m_query = query;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileQuery/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("query", QueryToJson(m_query));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileAddress{
            namespace List{
                // Mber::account::ProfileAddress::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::ProfileAddress>>(new std::list<Mber::ProfileAddress>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToProfileAddress(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId ){
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileAddress/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::account::ProfileAddress::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::ProfileAddressType addressType,Mber::MberPtr<std::string > houseNumberOrName,Mber::MberPtr<std::string > street,Mber::MberPtr<std::string > city,Mber::MberPtr<std::string > postalCode,Mber::MberPtr<std::string > stateOrProvince,Mber::MberPtr<std::string > country ){
                    m_profileId = profileId;
                    m_addressType = addressType;
                    m_houseNumberOrName = houseNumberOrName;
                    m_street = street;
                    m_city = city;
                    m_postalCode = postalCode;
                    m_stateOrProvince = stateOrProvince;
                    m_country = country;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileAddress/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("addressType", m_addressType);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_houseNumberOrName.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("houseNumberOrName", *m_houseNumberOrName);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_street.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("street", *m_street);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_city.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("city", *m_city);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_postalCode.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("postalCode", *m_postalCode);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_stateOrProvince.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("stateOrProvince", *m_stateOrProvince);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_country.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("country", *m_country);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::account::ProfileAddress::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::ProfileAddressType addressType ){
                    m_profileId = profileId;
                    m_addressType = addressType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileAddress/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("addressType", m_addressType);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Persona{
            namespace Create{
                // Mber::account::Persona::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        personaId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("personaId");
                        if( !next.isEmpty() ){
                            personaId = Mber::MberPtr<std::string>(new std::string);
                            *personaId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,std::string displayname ){
                    m_profileId = profileId;
                    m_displayname = displayname;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Persona/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("displayname", m_displayname);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::account::Persona::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Persona>(new Mber::Persona);
                            *result = jsonToPersona(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string personaId ){
                    m_personaId = personaId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Persona/";
                        Poco::URI::encode(m_personaId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&personaId=");
                        Poco::URI::encode(stringToString(m_personaId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::account::Persona::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Persona>>(new std::list<Mber::Persona>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToPersona(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = next;
                        }
                        
                        next = obj->get("totalPages");
                        if( !next.isEmpty() ){
                            totalPages = next;
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::MberPtr<uint64_t > page,Mber::MberPtr<uint64_t > maxResults ){
                    m_profileId = profileId;
                    m_page = page;
                    m_maxResults = maxResults;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Persona/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_page.isNull() ){Poco::URI::encode(uint64ToString(*m_page), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxResults.isNull() ){Poco::URI::encode(uint64ToString(*m_maxResults), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::account::Persona::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string personaId,Mber::MberPtr<std::string > displayname ){
                    m_personaId = personaId;
                    m_displayname = displayname;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Persona/";
                        Poco::URI::encode(m_personaId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("personaId", m_personaId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_displayname.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("displayname", *m_displayname);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::account::Persona::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string personaId ){
                    m_personaId = personaId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/Persona/";
                        Poco::URI::encode(m_personaId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("personaId", m_personaId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace PersonaQuery{
            namespace Create{
                // Mber::account::PersonaQuery::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Persona>>(new std::list<Mber::Persona>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToPersona(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::Query query ){
                    m_query = query;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/PersonaQuery/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("query", QueryToJson(m_query));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace SystemRegion{
            namespace List{
                // Mber::account::SystemRegion::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Region>>(new std::list<Mber::Region>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToRegion(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/SystemRegion/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ForgotPassword{
            namespace Create{
                // Mber::account::ForgotPassword::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string username,std::string email,Mber::MberPtr<Mber::EntityID > applicationId ){
                    m_username = username;
                    m_email = email;
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ForgotPassword/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("username", m_username);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("email", m_email);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_applicationId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", ((!m_applicationId->id->empty()) ? *m_applicationId->id : "'" + *m_applicationId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::account::ForgotPassword::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string tokenId,std::string password ){
                    m_tokenId = tokenId;
                    m_password = password;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ForgotPassword/";
                        Poco::URI::encode(m_tokenId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("tokenId", m_tokenId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", m_password);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace PasswordReset{
            namespace Create{
                // Mber::account::PasswordReset::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::MberPtr<std::string > applicationContext ){
                    m_profileId = profileId;
                    m_applicationContext = applicationContext;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/PasswordReset/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_applicationContext.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("applicationContext", *m_applicationContext);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::account::PasswordReset::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId ){
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/PasswordReset/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::account::PasswordReset::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        scope = 0;
                        access_token = 0;
                        token_type = 0;
                        expires_in = 0;
                        refresh_token = 0;
                        error = 0;
                        accountId = 0;
                        profileId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("scope");
                        if( !next.isEmpty() ){
                            scope = Mber::MberPtr<std::string>(new std::string);
                            *scope = next.convert<std::string>();
                        }
                        
                        next = obj->get("access_token");
                        if( !next.isEmpty() ){
                            access_token = Mber::MberPtr<std::string>(new std::string);
                            *access_token = next.convert<std::string>();
                        }
                        
                        next = obj->get("token_type");
                        if( !next.isEmpty() ){
                            token_type = Mber::MberPtr<Mber::AccessTokenType>(new Mber::AccessTokenType);
                            *token_type = jsonToAccessTokenType(next);
                        }
                        
                        next = obj->get("expires_in");
                        if( !next.isEmpty() ){
                            expires_in = Mber::MberPtr<int>(new int);
                            *expires_in = next;
                        }
                        
                        next = obj->get("refresh_token");
                        if( !next.isEmpty() ){
                            refresh_token = Mber::MberPtr<std::string>(new std::string);
                            *refresh_token = next.convert<std::string>();
                        }
                        
                        next = obj->get("error");
                        if( !next.isEmpty() ){
                            error = Mber::MberPtr<Mber::OauthError>(new Mber::OauthError);
                            *error = jsonToOauthError(next);
                        }
                        
                        next = obj->get("accountId");
                        if( !next.isEmpty() ){
                            accountId = Mber::MberPtr<std::string>(new std::string);
                            *accountId = next.convert<std::string>();
                        }
                        
                        next = obj->get("profileId");
                        if( !next.isEmpty() ){
                            profileId = Mber::MberPtr<std::string>(new std::string);
                            *profileId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string tokenId,std::string password ){
                    m_tokenId = tokenId;
                    m_password = password;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/PasswordReset/";
                        Poco::URI::encode(m_tokenId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("tokenId", m_tokenId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", m_password);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileReindexing{
            namespace Update{
                // Mber::account::ProfileReindexing::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EventType eventType,Mber::EntityID applicationId,Mber::MberPtr<bool > deleteIndex ){
                    m_eventType = eventType;
                    m_applicationId = applicationId;
                    m_deleteIndex = deleteIndex;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileReindexing/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("eventType", m_eventType);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_deleteIndex.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("deleteIndex", *m_deleteIndex);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileEntityQuery{
            namespace Create{
                // Mber::account::ProfileEntityQuery::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToEntityPointer(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::Query query ){
                    m_query = query;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileEntityQuery/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("query", QueryToJson(m_query));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace AnonymousUserUpgrade{
            namespace Create{
                // Mber::account::AnonymousUserUpgrade::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string email,Mber::MberPtr<Mber::EntityID > applicationId ){
                    m_email = email;
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/AnonymousUserUpgrade/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("email", m_email);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_applicationId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", ((!m_applicationId->id->empty()) ? *m_applicationId->id : "'" + *m_applicationId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ForgotUsername{
            namespace Create{
                // Mber::account::ForgotUsername::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string email,Mber::MberPtr<Mber::EntityID > applicationId ){
                    m_email = email;
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ForgotUsername/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("email", m_email);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_applicationId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", ((!m_applicationId->id->empty()) ? *m_applicationId->id : "'" + *m_applicationId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace BootProfile{
            namespace Create{
                // Mber::account::BootProfile::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::MberPtr<std::string > clientType,Mber::MberPtr<bool > includeChildApps ){
                    m_profileId = profileId;
                    m_clientType = clientType;
                    m_includeChildApps = includeChildApps;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/BootProfile/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_clientType.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("clientType", *m_clientType);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_includeChildApps.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("includeChildApps", *m_includeChildApps);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace BanProfile{
            namespace Create{
                // Mber::account::BanProfile::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::MberPtr<std::string > clientType,Mber::MberPtr<bool > includeChildApps ){
                    m_profileId = profileId;
                    m_clientType = clientType;
                    m_includeChildApps = includeChildApps;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/BanProfile/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_clientType.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("clientType", *m_clientType);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_includeChildApps.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("includeChildApps", *m_includeChildApps);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::account::BanProfile::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::MberPtr<std::string > clientType,Mber::MberPtr<bool > includeChildApps ){
                    m_profileId = profileId;
                    m_clientType = clientType;
                    m_includeChildApps = includeChildApps;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/BanProfile/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_clientType.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("clientType", *m_clientType);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_includeChildApps.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("includeChildApps", *m_includeChildApps);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileToken{
            namespace Read{
                // Mber::account::ProfileToken::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Token>(new Mber::Token);
                            *result = jsonToToken(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string tokenId,Mber::TokenType tokenType ){
                    m_tokenId = tokenId;
                    m_tokenType = tokenType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileToken/";
                        Poco::URI::encode(m_tokenId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&tokenId=");
                        Poco::URI::encode(stringToString(m_tokenId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&tokenType=");
                        Poco::URI::encode(TokenTypeToString(m_tokenType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::account::ProfileToken::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Token>>(new std::list<Mber::Token>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToToken(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID profileId,Mber::MberPtr<std::list<Mber::TokenType> > tokenTypes ){
                    m_profileId = profileId;
                    m_tokenTypes = tokenTypes;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileToken/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_tokenTypes.isNull() ){
                            for (std::list<Mber::TokenType>::const_iterator iterator = m_tokenTypes->begin(), end = m_tokenTypes->end(); iterator != end; ++iterator) {
                                mberUrl.append("&tokenTypes=");
                                Poco::URI::encode(TokenTypeToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::account::ProfileToken::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string tokenId ){
                    m_tokenId = tokenId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/account/ProfileToken/";
                        Poco::URI::encode(m_tokenId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("tokenId", m_tokenId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace application{
        namespace Application{
            namespace Create{
                // Mber::application::Application::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        applicationId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("applicationId");
                        if( !next.isEmpty() ){
                            applicationId = Mber::MberPtr<std::string>(new std::string);
                            *applicationId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::string > alias,Mber::EntityID parent,Mber::MberPtr<std::string > redirectUri,Mber::MberPtr<std::string > version,Mber::MberPtr<uint64_t > maxPersonas,Mber::MberPtr<bool > uniquePersonas ){
                    m_name = name;
                    m_alias = alias;
                    m_parent = parent;
                    m_redirectUri = redirectUri;
                    m_version = version;
                    m_maxPersonas = maxPersonas;
                    m_uniquePersonas = uniquePersonas;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/application/Application/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("parent", (*(m_parent.id) != NULL) ? *(m_parent.id) : "'" + *(m_parent.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_redirectUri.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("redirectUri", *m_redirectUri);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_version.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("version", *m_version);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxPersonas.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxPersonas", *m_maxPersonas);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_uniquePersonas.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("uniquePersonas", *m_uniquePersonas);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::application::Application::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId,Mber::MberPtr<std::string > name,Mber::MberPtr<std::string > alias,Mber::MberPtr<std::string > redirectUri,Mber::MberPtr<std::string > version,Mber::MberPtr<uint64_t > maxPersonas,Mber::MberPtr<bool > uniquePersonas ){
                    m_applicationId = applicationId;
                    m_name = name;
                    m_alias = alias;
                    m_redirectUri = redirectUri;
                    m_version = version;
                    m_maxPersonas = maxPersonas;
                    m_uniquePersonas = uniquePersonas;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/application/Application/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_redirectUri.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("redirectUri", *m_redirectUri);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_version.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("version", *m_version);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxPersonas.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxPersonas", *m_maxPersonas);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_uniquePersonas.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("uniquePersonas", *m_uniquePersonas);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::application::Application::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Application>>(new std::list<Mber::Application>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToApplication(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<Mber::ApplicationStatus > status ){
                    m_status = status;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/application/Application/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_status.isNull() ){Poco::URI::encode(ApplicationStatusToString(*m_status), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::application::Application::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/application/Application/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::application::Application::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Application>(new Mber::Application);
                            *result = jsonToApplication(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/application/Application/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace State{
            namespace Update{
                // Mber::application::State::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID parent,Mber::EntityID applicationId,Mber::ApplicationStatus status ){
                    m_parent = parent;
                    m_applicationId = applicationId;
                    m_status = status;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/application/State/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("parent", (*(m_parent.id) != NULL) ? *(m_parent.id) : "'" + *(m_parent.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("status", m_status);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace oauth{
        namespace AuthorizationToken{
            namespace Create{
                // Mber::oauth::AuthorizationToken::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        authorization_code = 0;
                        scope = 0;
                        accountId = 0;
                        profileId = 0;
                        applicationId = 0;
                        redirect_uri = 0;
                        passwordResetToken = 0;
                        displayname = 0;
                        steamId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("authorization_code");
                        if( !next.isEmpty() ){
                            authorization_code = Mber::MberPtr<std::string>(new std::string);
                            *authorization_code = next.convert<std::string>();
                        }
                        
                        next = obj->get("scope");
                        if( !next.isEmpty() ){
                            scope = Mber::MberPtr<std::string>(new std::string);
                            *scope = next.convert<std::string>();
                        }
                        
                        next = obj->get("accountId");
                        if( !next.isEmpty() ){
                            accountId = Mber::MberPtr<std::string>(new std::string);
                            *accountId = next.convert<std::string>();
                        }
                        
                        next = obj->get("profileId");
                        if( !next.isEmpty() ){
                            profileId = Mber::MberPtr<std::string>(new std::string);
                            *profileId = next.convert<std::string>();
                        }
                        
                        next = obj->get("applicationId");
                        if( !next.isEmpty() ){
                            applicationId = Mber::MberPtr<std::string>(new std::string);
                            *applicationId = next.convert<std::string>();
                        }
                        
                        next = obj->get("redirect_uri");
                        if( !next.isEmpty() ){
                            redirect_uri = Mber::MberPtr<std::string>(new std::string);
                            *redirect_uri = next.convert<std::string>();
                        }
                        
                        next = obj->get("passwordResetToken");
                        if( !next.isEmpty() ){
                            passwordResetToken = Mber::MberPtr<std::string>(new std::string);
                            *passwordResetToken = next.convert<std::string>();
                        }
                        
                        next = obj->get("displayname");
                        if( !next.isEmpty() ){
                            displayname = Mber::MberPtr<std::string>(new std::string);
                            *displayname = next.convert<std::string>();
                        }
                        
                        next = obj->get("steamId");
                        if( !next.isEmpty() ){
                            steamId = Mber::MberPtr<std::string>(new std::string);
                            *steamId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID client_id,Mber::MberPtr<std::string > redirect_uri,Mber::MberPtr<std::string > refresh_token,Mber::MberPtr<std::string > username,Mber::MberPtr<std::string > password,Mber::MberPtr<std::string > scope ){
                    m_client_id = client_id;
                    m_redirect_uri = redirect_uri;
                    m_refresh_token = refresh_token;
                    m_username = username;
                    m_password = password;
                    m_scope = scope;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/oauth/AuthorizationToken/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("client_id", (*(m_client_id.id) != NULL) ? *(m_client_id.id) : "'" + *(m_client_id.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_redirect_uri.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("redirect_uri", *m_redirect_uri);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_refresh_token.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("refresh_token", *m_refresh_token);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_username.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("username", *m_username);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_password.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", *m_password);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_scope.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("scope", *m_scope);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace AccessToken{
            namespace Create{
                // Mber::oauth::AccessToken::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        scope = 0;
                        access_token = 0;
                        token_type = 0;
                        expires_in = 0;
                        refresh_token = 0;
                        error = 0;
                        accountId = 0;
                        profileId = 0;
                        applicationId = 0;
                        passwordResetToken = 0;
                        displayname = 0;
                        steamId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("scope");
                        if( !next.isEmpty() ){
                            scope = Mber::MberPtr<std::string>(new std::string);
                            *scope = next.convert<std::string>();
                        }
                        
                        next = obj->get("access_token");
                        if( !next.isEmpty() ){
                            access_token = Mber::MberPtr<std::string>(new std::string);
                            *access_token = next.convert<std::string>();
                        }
                        
                        next = obj->get("token_type");
                        if( !next.isEmpty() ){
                            token_type = Mber::MberPtr<Mber::AccessTokenType>(new Mber::AccessTokenType);
                            *token_type = jsonToAccessTokenType(next);
                        }
                        
                        next = obj->get("expires_in");
                        if( !next.isEmpty() ){
                            expires_in = Mber::MberPtr<int>(new int);
                            *expires_in = next;
                        }
                        
                        next = obj->get("refresh_token");
                        if( !next.isEmpty() ){
                            refresh_token = Mber::MberPtr<std::string>(new std::string);
                            *refresh_token = next.convert<std::string>();
                        }
                        
                        next = obj->get("error");
                        if( !next.isEmpty() ){
                            error = Mber::MberPtr<Mber::OauthError>(new Mber::OauthError);
                            *error = jsonToOauthError(next);
                        }
                        
                        next = obj->get("accountId");
                        if( !next.isEmpty() ){
                            accountId = Mber::MberPtr<std::string>(new std::string);
                            *accountId = next.convert<std::string>();
                        }
                        
                        next = obj->get("profileId");
                        if( !next.isEmpty() ){
                            profileId = Mber::MberPtr<std::string>(new std::string);
                            *profileId = next.convert<std::string>();
                        }
                        
                        next = obj->get("applicationId");
                        if( !next.isEmpty() ){
                            applicationId = Mber::MberPtr<std::string>(new std::string);
                            *applicationId = next.convert<std::string>();
                        }
                        
                        next = obj->get("passwordResetToken");
                        if( !next.isEmpty() ){
                            passwordResetToken = Mber::MberPtr<std::string>(new std::string);
                            *passwordResetToken = next.convert<std::string>();
                        }
                        
                        next = obj->get("displayname");
                        if( !next.isEmpty() ){
                            displayname = Mber::MberPtr<std::string>(new std::string);
                            *displayname = next.convert<std::string>();
                        }
                        
                        next = obj->get("steamId");
                        if( !next.isEmpty() ){
                            steamId = Mber::MberPtr<std::string>(new std::string);
                            *steamId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string grant_type,Mber::EntityID client_id,Mber::MberPtr<std::string > client_secret,Mber::MberPtr<std::string > code,Mber::MberPtr<std::string > refresh_token,Mber::MberPtr<std::string > username,Mber::MberPtr<std::string > password,Mber::MberPtr<std::string > redirect_uri,Mber::MberPtr<std::string > scope ){
                    m_grant_type = grant_type;
                    m_client_id = client_id;
                    m_client_secret = client_secret;
                    m_code = code;
                    m_refresh_token = refresh_token;
                    m_username = username;
                    m_password = password;
                    m_redirect_uri = redirect_uri;
                    m_scope = scope;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/oauth/AccessToken/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("grant_type", m_grant_type);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("client_id", (*(m_client_id.id) != NULL) ? *(m_client_id.id) : "'" + *(m_client_id.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_client_secret.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("client_secret", *m_client_secret);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_code.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("code", *m_code);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_refresh_token.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("refresh_token", *m_refresh_token);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_username.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("username", *m_username);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_password.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", *m_password);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_redirect_uri.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("redirect_uri", *m_redirect_uri);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_scope.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("scope", *m_scope);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ClientToken{
            namespace Create{
                // Mber::oauth::ClientToken::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        clientToken = 0;
                        scope = 0;
                        accountId = 0;
                        profileId = 0;
                        applicationId = 0;
                        displayname = 0;
                        ownerHas = 0;
                        expiresIn = 0;
                        steamId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("clientToken");
                        if( !next.isEmpty() ){
                            clientToken = Mber::MberPtr<std::string>(new std::string);
                            *clientToken = next.convert<std::string>();
                        }
                        
                        next = obj->get("scope");
                        if( !next.isEmpty() ){
                            scope = Mber::MberPtr<std::string>(new std::string);
                            *scope = next.convert<std::string>();
                        }
                        
                        next = obj->get("accountId");
                        if( !next.isEmpty() ){
                            accountId = Mber::MberPtr<std::string>(new std::string);
                            *accountId = next.convert<std::string>();
                        }
                        
                        next = obj->get("profileId");
                        if( !next.isEmpty() ){
                            profileId = Mber::MberPtr<std::string>(new std::string);
                            *profileId = next.convert<std::string>();
                        }
                        
                        next = obj->get("applicationId");
                        if( !next.isEmpty() ){
                            applicationId = Mber::MberPtr<std::string>(new std::string);
                            *applicationId = next.convert<std::string>();
                        }
                        
                        next = obj->get("displayname");
                        if( !next.isEmpty() ){
                            displayname = Mber::MberPtr<std::string>(new std::string);
                            *displayname = next.convert<std::string>();
                        }
                        
                        next = obj->get("ownerHas");
                        if( !next.isEmpty() ){
                            ownerHas = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                ownerHas->push_back(jsonToEntityPointer(next));
                            }
                        }
                        
                        next = obj->get("expiresIn");
                        if( !next.isEmpty() ){
                            expiresIn = Mber::MberPtr<int>(new int);
                            *expiresIn = next;
                        }
                        
                        next = obj->get("steamId");
                        if( !next.isEmpty() ){
                            steamId = Mber::MberPtr<std::string>(new std::string);
                            *steamId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string authorization_token,std::string clientType,Mber::MberPtr<int > ttl,Mber::MberPtr<std::list<Mber::EntityPointer> > mustHaveOne ){
                    m_authorization_token = authorization_token;
                    m_clientType = clientType;
                    m_ttl = ttl;
                    m_mustHaveOne = mustHaveOne;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/oauth/ClientToken/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("authorization_token", m_authorization_token);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("clientType", m_clientType);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_ttl.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("ttl", *m_ttl);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_mustHaveOne.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array mustHaveOne_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_mustHaveOne->begin(), end = m_mustHaveOne->end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            mustHaveOne_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("mustHaveOne", mustHaveOne_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace profileGroups{
        namespace ProfileGroups{
            namespace Create{
                // Mber::profileGroups::ProfileGroups::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        profileGroupId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("profileGroupId");
                        if( !next.isEmpty() ){
                            profileGroupId = Mber::MberPtr<std::string>(new std::string);
                            *profileGroupId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::string > alias,Mber::MberPtr<std::list<Mber::EntityPointer> > members ){
                    m_name = name;
                    m_alias = alias;
                    m_members = members;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/profileGroups/ProfileGroups/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_members.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array members_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_members->begin(), end = m_members->end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            members_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("members", members_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::profileGroups::ProfileGroups::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::ProfileGroup>(new Mber::ProfileGroup);
                            *result = jsonToProfileGroup(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID groupId ){
                    m_groupId = groupId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/profileGroups/ProfileGroups/";
                        Poco::URI::encode((*(m_groupId.id) != NULL) ? *(m_groupId.id) : "'" + *(m_groupId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::profileGroups::ProfileGroups::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::ProfileGroup>>(new std::list<Mber::ProfileGroup>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToProfileGroup(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/profileGroups/ProfileGroups/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::profileGroups::ProfileGroups::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID groupId,Mber::MberPtr<std::string > name,Mber::MberPtr<std::string > alias,Mber::MberPtr<std::list<Mber::EntityPointer> > membersToAdd,Mber::MberPtr<std::list<Mber::EntityPointer> > membersToRemove,Mber::MberPtr<Mber::ProfileGroupStatus > status ){
                    m_groupId = groupId;
                    m_name = name;
                    m_alias = alias;
                    m_membersToAdd = membersToAdd;
                    m_membersToRemove = membersToRemove;
                    m_status = status;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/profileGroups/ProfileGroups/";
                        Poco::URI::encode((*(m_groupId.id) != NULL) ? *(m_groupId.id) : "'" + *(m_groupId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("groupId", (*(m_groupId.id) != NULL) ? *(m_groupId.id) : "'" + *(m_groupId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_membersToAdd.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array membersToAdd_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_membersToAdd->begin(), end = m_membersToAdd->end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            membersToAdd_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("membersToAdd", membersToAdd_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_membersToRemove.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array membersToRemove_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_membersToRemove->begin(), end = m_membersToRemove->end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            membersToRemove_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("membersToRemove", membersToRemove_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_status.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("status", *m_status);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::profileGroups::ProfileGroups::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID groupId ){
                    m_groupId = groupId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/profileGroups/ProfileGroups/";
                        Poco::URI::encode((*(m_groupId.id) != NULL) ? *(m_groupId.id) : "'" + *(m_groupId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("groupId", (*(m_groupId.id) != NULL) ? *(m_groupId.id) : "'" + *(m_groupId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileGroupsMembership{
            namespace List{
                // Mber::profileGroups::ProfileGroupsMembership::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToEntityPointer(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId ){
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/profileGroups/ProfileGroupsMembership/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileGroupQuery{
            namespace Create{
                // Mber::profileGroups::ProfileGroupQuery::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::ProfileGroup>>(new std::list<Mber::ProfileGroup>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToProfileGroup(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::Query query ){
                    m_query = query;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/profileGroups/ProfileGroupQuery/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("query", QueryToJson(m_query));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace role{
        namespace Role{
            namespace Create{
                // Mber::role::Role::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        roleId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("roleId");
                        if( !next.isEmpty() ){
                            roleId = Mber::MberPtr<std::string>(new std::string);
                            *roleId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::EntityPointer parent,bool automatic,bool cascading,Mber::MberPtr<std::list<Mber::Permission> > permissions,Mber::MberPtr<std::list<Mber::AutomaticRoleAssignment> > automaticAssignments,Mber::MberPtr<bool > negative ){
                    m_name = name;
                    m_parent = parent;
                    m_automatic = automatic;
                    m_cascading = cascading;
                    m_permissions = permissions;
                    m_automaticAssignments = automaticAssignments;
                    m_negative = negative;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/Role/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("parent", EntityPointerToJson(m_parent));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("automatic", m_automatic);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("cascading", m_cascading);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_permissions.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array permissions_array;
                        for (std::list<Mber::Permission>::const_iterator iterator = m_permissions->begin(), end = m_permissions->end(); iterator != end; ++iterator) {
                            Mber::Permission next = *iterator;
                            
                            // Multiple Struct
                            permissions_array.add(PermissionToJson(next));
                            
                        }
                        reqJson.set("permissions", permissions_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_automaticAssignments.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array automaticAssignments_array;
                        for (std::list<Mber::AutomaticRoleAssignment>::const_iterator iterator = m_automaticAssignments->begin(), end = m_automaticAssignments->end(); iterator != end; ++iterator) {
                            Mber::AutomaticRoleAssignment next = *iterator;
                            
                            // Multiple Struct
                            automaticAssignments_array.add(AutomaticRoleAssignmentToJson(next));
                            
                        }
                        reqJson.set("automaticAssignments", automaticAssignments_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_negative.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("negative", *m_negative);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::role::Role::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Role>(new Mber::Role);
                            *result = jsonToRole(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID roleId ){
                    m_roleId = roleId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/Role/";
                        Poco::URI::encode((*(m_roleId.id) != NULL) ? *(m_roleId.id) : "'" + *(m_roleId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::role::Role::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Role>>(new std::list<Mber::Role>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToRole(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string parentId,Mber::EntityType parentType ){
                    m_parentId = parentId;
                    m_parentType = parentType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/Role/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&parentId=");
                        Poco::URI::encode(stringToString(m_parentId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&parentType=");
                        Poco::URI::encode(EntityTypeToString(m_parentType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::role::Role::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID roleId,std::string name,bool active,bool automatic,bool cascading,Mber::MberPtr<std::list<Mber::Permission> > permissions,Mber::MberPtr<std::list<Mber::AutomaticRoleAssignment> > automaticAssignments,Mber::MberPtr<bool > negative ){
                    m_roleId = roleId;
                    m_name = name;
                    m_active = active;
                    m_automatic = automatic;
                    m_cascading = cascading;
                    m_permissions = permissions;
                    m_automaticAssignments = automaticAssignments;
                    m_negative = negative;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/Role/";
                        Poco::URI::encode((*(m_roleId.id) != NULL) ? *(m_roleId.id) : "'" + *(m_roleId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("roleId", (*(m_roleId.id) != NULL) ? *(m_roleId.id) : "'" + *(m_roleId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("active", m_active);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("automatic", m_automatic);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("cascading", m_cascading);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_permissions.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array permissions_array;
                        for (std::list<Mber::Permission>::const_iterator iterator = m_permissions->begin(), end = m_permissions->end(); iterator != end; ++iterator) {
                            Mber::Permission next = *iterator;
                            
                            // Multiple Struct
                            permissions_array.add(PermissionToJson(next));
                            
                        }
                        reqJson.set("permissions", permissions_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_automaticAssignments.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array automaticAssignments_array;
                        for (std::list<Mber::AutomaticRoleAssignment>::const_iterator iterator = m_automaticAssignments->begin(), end = m_automaticAssignments->end(); iterator != end; ++iterator) {
                            Mber::AutomaticRoleAssignment next = *iterator;
                            
                            // Multiple Struct
                            automaticAssignments_array.add(AutomaticRoleAssignmentToJson(next));
                            
                        }
                        reqJson.set("automaticAssignments", automaticAssignments_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_negative.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("negative", *m_negative);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::role::Role::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID roleId ){
                    m_roleId = roleId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/Role/";
                        Poco::URI::encode((*(m_roleId.id) != NULL) ? *(m_roleId.id) : "'" + *(m_roleId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("roleId", (*(m_roleId.id) != NULL) ? *(m_roleId.id) : "'" + *(m_roleId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace RoleAssignment{
            namespace Create{
                // Mber::role::RoleAssignment::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID roleId,Mber::MberPtr<std::string > profileId,Mber::EntityPointer context,Mber::EntityPointer recipient ){
                    m_roleId = roleId;
                    m_profileId = profileId;
                    m_context = context;
                    m_recipient = recipient;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/RoleAssignment/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("roleId", (*(m_roleId.id) != NULL) ? *(m_roleId.id) : "'" + *(m_roleId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_profileId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", *m_profileId);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("context", EntityPointerToJson(m_context));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("recipient", EntityPointerToJson(m_recipient));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::role::RoleAssignment::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID roleId,Mber::MberPtr<std::string > profileId,Mber::EntityPointer context,Mber::EntityPointer recipient ){
                    m_roleId = roleId;
                    m_profileId = profileId;
                    m_context = context;
                    m_recipient = recipient;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/RoleAssignment/";
                        Poco::URI::encode((*(m_roleId.id) != NULL) ? *(m_roleId.id) : "'" + *(m_roleId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("roleId", (*(m_roleId.id) != NULL) ? *(m_roleId.id) : "'" + *(m_roleId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_profileId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", *m_profileId);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("context", EntityPointerToJson(m_context));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("recipient", EntityPointerToJson(m_recipient));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::role::RoleAssignment::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToEntityPointer(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID roleId ){
                    m_roleId = roleId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/RoleAssignment/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileRoles{
            namespace List{
                // Mber::role::ProfileRoles::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Role>>(new std::list<Mber::Role>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToRole(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::string > profileId,std::string entityId,Mber::MberPtr<Mber::EntityType > entityType ){
                    m_profileId = profileId;
                    m_entityId = entityId;
                    m_entityType = entityType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/ProfileRoles/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_profileId.isNull() ){Poco::URI::encode(stringToString(*m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&entityId=");
                        Poco::URI::encode(stringToString(m_entityId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_entityType.isNull() ){Poco::URI::encode(EntityTypeToString(*m_entityType), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace IPFilter{
            namespace Create{
                // Mber::role::IPFilter::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::list<std::string> ipAddresses,Mber::EntityID role ){
                    m_ipAddresses = ipAddresses;
                    m_role = role;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/IPFilter/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle multiple
                        Poco::JSON::Array ipAddresses_array;
                        for (std::list<std::string>::const_iterator iterator = m_ipAddresses.begin(), end = m_ipAddresses.end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            ipAddresses_array.add(next);
                            
                        }
                        reqJson.set("ipAddresses", ipAddresses_array);
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("role", (*(m_role.id) != NULL) ? *(m_role.id) : "'" + *(m_role.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::role::IPFilter::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID role,Mber::MberPtr<std::list<std::string> > ipsToAdd,Mber::MberPtr<std::list<std::string> > ipsToRemove ){
                    m_role = role;
                    m_ipsToAdd = ipsToAdd;
                    m_ipsToRemove = ipsToRemove;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/IPFilter/";
                        Poco::URI::encode((*(m_role.id) != NULL) ? *(m_role.id) : "'" + *(m_role.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("role", (*(m_role.id) != NULL) ? *(m_role.id) : "'" + *(m_role.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_ipsToAdd.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array ipsToAdd_array;
                        for (std::list<std::string>::const_iterator iterator = m_ipsToAdd->begin(), end = m_ipsToAdd->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            ipsToAdd_array.add(next);
                            
                        }
                        reqJson.set("ipsToAdd", ipsToAdd_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_ipsToRemove.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array ipsToRemove_array;
                        for (std::list<std::string>::const_iterator iterator = m_ipsToRemove->begin(), end = m_ipsToRemove->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            ipsToRemove_array.add(next);
                            
                        }
                        reqJson.set("ipsToRemove", ipsToRemove_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::role::IPFilter::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::IPFilter>(new Mber::IPFilter);
                            *result = jsonToIPFilter(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID role ){
                    m_role = role;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/IPFilter/";
                        Poco::URI::encode((*(m_role.id) != NULL) ? *(m_role.id) : "'" + *(m_role.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::role::IPFilter::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Role>>(new std::list<Mber::Role>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToRole(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string ipAddress,std::string parentId,Mber::EntityType parentType ){
                    m_ipAddress = ipAddress;
                    m_parentId = parentId;
                    m_parentType = parentType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/IPFilter/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&ipAddress=");
                        Poco::URI::encode(stringToString(m_ipAddress), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&parentId=");
                        Poco::URI::encode(stringToString(m_parentId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&parentType=");
                        Poco::URI::encode(EntityTypeToString(m_parentType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::role::IPFilter::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID role ){
                    m_role = role;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/role/IPFilter/";
                        Poco::URI::encode((*(m_role.id) != NULL) ? *(m_role.id) : "'" + *(m_role.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("role", (*(m_role.id) != NULL) ? *(m_role.id) : "'" + *(m_role.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace steam{
        namespace SteamApplication{
            namespace Create{
                // Mber::steam::SteamApplication::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        id = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("id");
                        if( !next.isEmpty() ){
                            id = Mber::MberPtr<std::string>(new std::string);
                            *id = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( int steamApplicationId,std::string name,std::string webAPIKey ){
                    m_steamApplicationId = steamApplicationId;
                    m_name = name;
                    m_webAPIKey = webAPIKey;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/steam/SteamApplication/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("steamApplicationId", m_steamApplicationId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("webAPIKey", m_webAPIKey);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::steam::SteamApplication::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::SteamApplication>(new Mber::SteamApplication);
                            *result = jsonToSteamApplication(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string id ){
                    m_id = id;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/steam/SteamApplication/";
                        Poco::URI::encode(m_id, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&id=");
                        Poco::URI::encode(stringToString(m_id), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::steam::SteamApplication::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::SteamApplication>>(new std::list<Mber::SteamApplication>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToSteamApplication(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/steam/SteamApplication/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace SyncProfile{
            namespace Create{
                // Mber::steam::SyncProfile::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID profileId,Mber::MberPtr<Mber::EntityID > applicationId ){
                    m_profileId = profileId;
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/steam/SyncProfile/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("profileId", (*(m_profileId.id) != NULL) ? *(m_profileId.id) : "'" + *(m_profileId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_applicationId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", ((!m_applicationId->id->empty()) ? *m_applicationId->id : "'" + *m_applicationId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace SyncApplication{
            namespace Create{
                // Mber::steam::SyncApplication::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/steam/SyncApplication/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace LinkProfile{
            namespace Create{
                // Mber::steam::LinkProfile::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID profileId,int steamApplicationId,std::string authSessionTicket ){
                    m_profileId = profileId;
                    m_steamApplicationId = steamApplicationId;
                    m_authSessionTicket = authSessionTicket;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/steam/LinkProfile/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("profileId", (*(m_profileId.id) != NULL) ? *(m_profileId.id) : "'" + *(m_profileId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("steamApplicationId", m_steamApplicationId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("authSessionTicket", m_authSessionTicket);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace version{
        namespace Build{
            namespace List{
                // Mber::version::Build::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Build>>(new std::list<Mber::Build>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToBuild(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/version/Build/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace achievement{
        namespace Definition{
            namespace Create{
                // Mber::achievement::Definition::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        definitionId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("definitionId");
                        if( !next.isEmpty() ){
                            definitionId = Mber::MberPtr<std::string>(new std::string);
                            *definitionId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::list<Mber::AchievementPropertyDefinition> > properties,Mber::MberPtr<std::list<std::string> > categories ){
                    m_name = name;
                    m_properties = properties;
                    m_categories = categories;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Definition/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_properties.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::AchievementPropertyDefinition>::const_iterator iterator = m_properties->begin(), end = m_properties->end(); iterator != end; ++iterator) {
                            Mber::AchievementPropertyDefinition next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(AchievementPropertyDefinitionToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_categories.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array categories_array;
                        for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            categories_array.add(next);
                            
                        }
                        reqJson.set("categories", categories_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::achievement::Definition::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId,std::string name,Mber::MberPtr<std::list<std::string> > categoriesToAdd,Mber::MberPtr<std::list<std::string> > categoriesToRemove ){
                    m_definitionId = definitionId;
                    m_name = name;
                    m_categoriesToAdd = categoriesToAdd;
                    m_categoriesToRemove = categoriesToRemove;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Definition/";
                        Poco::URI::encode((*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_categoriesToAdd.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array categoriesToAdd_array;
                        for (std::list<std::string>::const_iterator iterator = m_categoriesToAdd->begin(), end = m_categoriesToAdd->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            categoriesToAdd_array.add(next);
                            
                        }
                        reqJson.set("categoriesToAdd", categoriesToAdd_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_categoriesToRemove.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array categoriesToRemove_array;
                        for (std::list<std::string>::const_iterator iterator = m_categoriesToRemove->begin(), end = m_categoriesToRemove->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            categoriesToRemove_array.add(next);
                            
                        }
                        reqJson.set("categoriesToRemove", categoriesToRemove_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::achievement::Definition::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::AchievementDefinition>(new Mber::AchievementDefinition);
                            *result = jsonToAchievementDefinition(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId ){
                    m_definitionId = definitionId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Definition/";
                        Poco::URI::encode((*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::achievement::Definition::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId ){
                    m_definitionId = definitionId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Definition/";
                        Poco::URI::encode((*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::achievement::Definition::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        truncated = 0;
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::AchievementDefinition>>(new std::list<Mber::AchievementDefinition>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToAchievementDefinition(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::list<Mber::DefinitionStatus> > setStatuses,Mber::MberPtr<std::list<Mber::DefinitionStatus> > unsetStatuses,Mber::MberPtr<std::list<std::string> > categories ){
                    m_setStatuses = setStatuses;
                    m_unsetStatuses = unsetStatuses;
                    m_categories = categories;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Definition/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_setStatuses.isNull() ){
                            for (std::list<Mber::DefinitionStatus>::const_iterator iterator = m_setStatuses->begin(), end = m_setStatuses->end(); iterator != end; ++iterator) {
                                mberUrl.append("&setStatuses=");
                                Poco::URI::encode(DefinitionStatusToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_unsetStatuses.isNull() ){
                            for (std::list<Mber::DefinitionStatus>::const_iterator iterator = m_unsetStatuses->begin(), end = m_unsetStatuses->end(); iterator != end; ++iterator) {
                                mberUrl.append("&unsetStatuses=");
                                Poco::URI::encode(DefinitionStatusToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_categories.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                                mberUrl.append("&categories=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Earn{
            namespace Create{
                // Mber::achievement::Earn::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        achievementInstanceId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("achievementInstanceId");
                        if( !next.isEmpty() ){
                            achievementInstanceId = Mber::MberPtr<std::string>(new std::string);
                            *achievementInstanceId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId,Mber::EntityPointer entity,Mber::MberPtr<std::list<Mber::Property> > properties ){
                    m_definitionId = definitionId;
                    m_entity = entity;
                    m_properties = properties;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Earn/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("entity", EntityPointerToJson(m_entity));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_properties.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::Property>::const_iterator iterator = m_properties->begin(), end = m_properties->end(); iterator != end; ++iterator) {
                            Mber::Property next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(PropertyToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::achievement::Earn::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::EarnedAchievements>>(new std::list<Mber::EarnedAchievements>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToEarnedAchievements(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId ){
                    m_definitionId = definitionId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Earn/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Instance{
            namespace Delete{
                // Mber::achievement::Instance::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string achievementInstanceId,Mber::EntityID definitionId,Mber::EntityPointer entity ){
                    m_achievementInstanceId = achievementInstanceId;
                    m_definitionId = definitionId;
                    m_entity = entity;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Instance/";
                        Poco::URI::encode(m_achievementInstanceId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("achievementInstanceId", m_achievementInstanceId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("entity", EntityPointerToJson(m_entity));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::achievement::Instance::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::AchievementInstance>>(new std::list<Mber::AchievementInstance>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToAchievementInstance(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string entityId,Mber::EntityType entityType ){
                    m_entityId = entityId;
                    m_entityType = entityType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/achievement/Instance/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&entityId=");
                        Poco::URI::encode(stringToString(m_entityId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&entityType=");
                        Poco::URI::encode(EntityTypeToString(m_entityType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace campaign{
        namespace Campaign{
            namespace Create{
                // Mber::campaign::Campaign::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        campaignId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("campaignId");
                        if( !next.isEmpty() ){
                            campaignId = Mber::MberPtr<std::string>(new std::string);
                            *campaignId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::EntityID digitalGood,Mber::MberPtr<std::string > description,Mber::MberPtr<std::string > url,Mber::MberPtr<Mber::EntityID > invalidWords ){
                    m_name = name;
                    m_digitalGood = digitalGood;
                    m_description = description;
                    m_url = url;
                    m_invalidWords = invalidWords;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/campaign/Campaign/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("digitalGood", (*(m_digitalGood.id) != NULL) ? *(m_digitalGood.id) : "'" + *(m_digitalGood.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_description.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("description", *m_description);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_url.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("url", *m_url);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_invalidWords.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("invalidWords", ((!m_invalidWords->id->empty()) ? *m_invalidWords->id : "'" + *m_invalidWords->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::campaign::Campaign::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Campaign>(new Mber::Campaign);
                            *result = jsonToCampaign(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID campaignId ){
                    m_campaignId = campaignId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/campaign/Campaign/";
                        Poco::URI::encode((*(m_campaignId.id) != NULL) ? *(m_campaignId.id) : "'" + *(m_campaignId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::campaign::Campaign::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Campaign>>(new std::list<Mber::Campaign>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToCampaign(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = next;
                        }
                        
                        next = obj->get("totalPages");
                        if( !next.isEmpty() ){
                            totalPages = next;
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<uint64_t > page,Mber::MberPtr<uint64_t > maxResults ){
                    m_page = page;
                    m_maxResults = maxResults;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/campaign/Campaign/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_page.isNull() ){Poco::URI::encode(uint64ToString(*m_page), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxResults.isNull() ){Poco::URI::encode(uint64ToString(*m_maxResults), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::campaign::Campaign::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID campaignId,Mber::MberPtr<std::string > name,Mber::MberPtr<Mber::EntityID > digitalGood,Mber::MberPtr<std::string > description,Mber::MberPtr<std::string > url,Mber::MberPtr<Mber::EntityID > invalidWords ){
                    m_campaignId = campaignId;
                    m_name = name;
                    m_digitalGood = digitalGood;
                    m_description = description;
                    m_url = url;
                    m_invalidWords = invalidWords;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/campaign/Campaign/";
                        Poco::URI::encode((*(m_campaignId.id) != NULL) ? *(m_campaignId.id) : "'" + *(m_campaignId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("campaignId", (*(m_campaignId.id) != NULL) ? *(m_campaignId.id) : "'" + *(m_campaignId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_digitalGood.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("digitalGood", ((!m_digitalGood->id->empty()) ? *m_digitalGood->id : "'" + *m_digitalGood->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_description.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("description", *m_description);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_url.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("url", *m_url);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_invalidWords.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("invalidWords", ((!m_invalidWords->id->empty()) ? *m_invalidWords->id : "'" + *m_invalidWords->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::campaign::Campaign::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID campaignId ){
                    m_campaignId = campaignId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/campaign/Campaign/";
                        Poco::URI::encode((*(m_campaignId.id) != NULL) ? *(m_campaignId.id) : "'" + *(m_campaignId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("campaignId", (*(m_campaignId.id) != NULL) ? *(m_campaignId.id) : "'" + *(m_campaignId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Keys{
            namespace Create{
                // Mber::campaign::Keys::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        documentId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("documentId");
                        if( !next.isEmpty() ){
                            documentId = Mber::MberPtr<std::string>(new std::string);
                            *documentId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID campaignId,uint64_t numberOfKeys,std::string outputDocumentName,Mber::MberPtr<Mber::EntityID > outputDirectory,Mber::MberPtr<Mber::KeyFormat > keyFormat ){
                    m_campaignId = campaignId;
                    m_numberOfKeys = numberOfKeys;
                    m_outputDocumentName = outputDocumentName;
                    m_outputDirectory = outputDirectory;
                    m_keyFormat = keyFormat;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/campaign/Keys/";
                        Poco::URI::encode((*(m_campaignId.id) != NULL) ? *(m_campaignId.id) : "'" + *(m_campaignId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("campaignId", (*(m_campaignId.id) != NULL) ? *(m_campaignId.id) : "'" + *(m_campaignId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("numberOfKeys", m_numberOfKeys);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("outputDocumentName", m_outputDocumentName);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_outputDirectory.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("outputDirectory", ((!m_outputDirectory->id->empty()) ? *m_outputDirectory->id : "'" + *m_outputDirectory->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_keyFormat.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("keyFormat", *m_keyFormat);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace digitalGood{
        namespace Definition{
            namespace Create{
                // Mber::digitalGood::Definition::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        definitionId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("definitionId");
                        if( !next.isEmpty() ){
                            definitionId = Mber::MberPtr<std::string>(new std::string);
                            *definitionId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::string > documentId,bool autoClaim,Mber::MberPtr<std::list<Mber::DigitalGoodPropertyDefinition> > properties,Mber::MberPtr<std::list<Mber::EntityID> > redeemableFor,Mber::MberPtr<uint64_t > ttl,Mber::MberPtr<bool > selfGrant,Mber::MberPtr<uint64_t > selfGrantCount,Mber::MberPtr<bool > emailOnGrant,Mber::MberPtr<bool > emailOnClaim,Mber::MberPtr<std::list<Mber::Reward> > redemptionRewards,Mber::MberPtr<std::list<std::string> > categories ){
                    m_name = name;
                    m_documentId = documentId;
                    m_autoClaim = autoClaim;
                    m_properties = properties;
                    m_redeemableFor = redeemableFor;
                    m_ttl = ttl;
                    m_selfGrant = selfGrant;
                    m_selfGrantCount = selfGrantCount;
                    m_emailOnGrant = emailOnGrant;
                    m_emailOnClaim = emailOnClaim;
                    m_redemptionRewards = redemptionRewards;
                    m_categories = categories;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Definition/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_documentId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("documentId", *m_documentId);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("autoClaim", m_autoClaim);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_properties.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::DigitalGoodPropertyDefinition>::const_iterator iterator = m_properties->begin(), end = m_properties->end(); iterator != end; ++iterator) {
                            Mber::DigitalGoodPropertyDefinition next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(DigitalGoodPropertyDefinitionToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_redeemableFor.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array redeemableFor_array;
                        for (std::list<Mber::EntityID>::const_iterator iterator = m_redeemableFor->begin(), end = m_redeemableFor->end(); iterator != end; ++iterator) {
                            Mber::EntityID next = *iterator;
                            
                            // Multiple Struct
                            redeemableFor_array.add(EntityIDToJson(next));
                            
                        }
                        reqJson.set("redeemableFor", redeemableFor_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_ttl.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("ttl", *m_ttl);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_selfGrant.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("selfGrant", *m_selfGrant);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_selfGrantCount.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("selfGrantCount", *m_selfGrantCount);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_emailOnGrant.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("emailOnGrant", *m_emailOnGrant);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_emailOnClaim.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("emailOnClaim", *m_emailOnClaim);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_redemptionRewards.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array redemptionRewards_array;
                        for (std::list<Mber::Reward>::const_iterator iterator = m_redemptionRewards->begin(), end = m_redemptionRewards->end(); iterator != end; ++iterator) {
                            Mber::Reward next = *iterator;
                            
                            // Multiple Struct
                            redemptionRewards_array.add(RewardToJson(next));
                            
                        }
                        reqJson.set("redemptionRewards", redemptionRewards_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_categories.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array categories_array;
                        for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            categories_array.add(next);
                            
                        }
                        reqJson.set("categories", categories_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::digitalGood::Definition::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId,std::string name,bool autoClaim,Mber::MberPtr<std::list<Mber::EntityID> > redeemableFor,Mber::MberPtr<uint64_t > ttl,Mber::MberPtr<bool > selfGrant,Mber::MberPtr<uint64_t > selfGrantCount,Mber::MberPtr<bool > emailOnGrant,Mber::MberPtr<bool > emailOnClaim,Mber::MberPtr<std::list<Mber::Reward> > redemptionRewards,Mber::MberPtr<std::list<std::string> > categoriesToAdd,Mber::MberPtr<std::list<std::string> > categoriesToRemove ){
                    m_definitionId = definitionId;
                    m_name = name;
                    m_autoClaim = autoClaim;
                    m_redeemableFor = redeemableFor;
                    m_ttl = ttl;
                    m_selfGrant = selfGrant;
                    m_selfGrantCount = selfGrantCount;
                    m_emailOnGrant = emailOnGrant;
                    m_emailOnClaim = emailOnClaim;
                    m_redemptionRewards = redemptionRewards;
                    m_categoriesToAdd = categoriesToAdd;
                    m_categoriesToRemove = categoriesToRemove;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Definition/";
                        Poco::URI::encode((*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("autoClaim", m_autoClaim);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_redeemableFor.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array redeemableFor_array;
                        for (std::list<Mber::EntityID>::const_iterator iterator = m_redeemableFor->begin(), end = m_redeemableFor->end(); iterator != end; ++iterator) {
                            Mber::EntityID next = *iterator;
                            
                            // Multiple Struct
                            redeemableFor_array.add(EntityIDToJson(next));
                            
                        }
                        reqJson.set("redeemableFor", redeemableFor_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_ttl.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("ttl", *m_ttl);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_selfGrant.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("selfGrant", *m_selfGrant);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_selfGrantCount.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("selfGrantCount", *m_selfGrantCount);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_emailOnGrant.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("emailOnGrant", *m_emailOnGrant);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_emailOnClaim.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("emailOnClaim", *m_emailOnClaim);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_redemptionRewards.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array redemptionRewards_array;
                        for (std::list<Mber::Reward>::const_iterator iterator = m_redemptionRewards->begin(), end = m_redemptionRewards->end(); iterator != end; ++iterator) {
                            Mber::Reward next = *iterator;
                            
                            // Multiple Struct
                            redemptionRewards_array.add(RewardToJson(next));
                            
                        }
                        reqJson.set("redemptionRewards", redemptionRewards_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_categoriesToAdd.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array categoriesToAdd_array;
                        for (std::list<std::string>::const_iterator iterator = m_categoriesToAdd->begin(), end = m_categoriesToAdd->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            categoriesToAdd_array.add(next);
                            
                        }
                        reqJson.set("categoriesToAdd", categoriesToAdd_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_categoriesToRemove.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array categoriesToRemove_array;
                        for (std::list<std::string>::const_iterator iterator = m_categoriesToRemove->begin(), end = m_categoriesToRemove->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            categoriesToRemove_array.add(next);
                            
                        }
                        reqJson.set("categoriesToRemove", categoriesToRemove_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::digitalGood::Definition::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::DigitalGoodDefinition>(new Mber::DigitalGoodDefinition);
                            *result = jsonToDigitalGoodDefinition(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId ){
                    m_definitionId = definitionId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Definition/";
                        Poco::URI::encode((*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::digitalGood::Definition::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId ){
                    m_definitionId = definitionId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Definition/";
                        Poco::URI::encode((*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::digitalGood::Definition::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        truncated = 0;
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::DigitalGoodDefinition>>(new std::list<Mber::DigitalGoodDefinition>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToDigitalGoodDefinition(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::list<Mber::DefinitionStatus> > setStatuses,Mber::MberPtr<std::list<Mber::DefinitionStatus> > unsetStatuses,Mber::MberPtr<std::list<std::string> > categories ){
                    m_setStatuses = setStatuses;
                    m_unsetStatuses = unsetStatuses;
                    m_categories = categories;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Definition/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_setStatuses.isNull() ){
                            for (std::list<Mber::DefinitionStatus>::const_iterator iterator = m_setStatuses->begin(), end = m_setStatuses->end(); iterator != end; ++iterator) {
                                mberUrl.append("&setStatuses=");
                                Poco::URI::encode(DefinitionStatusToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_unsetStatuses.isNull() ){
                            for (std::list<Mber::DefinitionStatus>::const_iterator iterator = m_unsetStatuses->begin(), end = m_unsetStatuses->end(); iterator != end; ++iterator) {
                                mberUrl.append("&unsetStatuses=");
                                Poco::URI::encode(DefinitionStatusToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_categories.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                                mberUrl.append("&categories=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Granted{
            namespace Create{
                // Mber::digitalGood::Granted::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        instanceId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("instanceId");
                        if( !next.isEmpty() ){
                            instanceId = Mber::MberPtr<std::string>(new std::string);
                            *instanceId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID definitionId,Mber::EntityPointer entity,Mber::MberPtr<std::list<Mber::Property> > properties ){
                    m_definitionId = definitionId;
                    m_entity = entity;
                    m_properties = properties;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Granted/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("entity", EntityPointerToJson(m_entity));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_properties.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::Property>::const_iterator iterator = m_properties->begin(), end = m_properties->end(); iterator != end; ++iterator) {
                            Mber::Property next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(PropertyToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Claimed{
            namespace Create{
                // Mber::digitalGood::Claimed::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityPointer entity,std::string instanceId,Mber::MberPtr<std::list<Mber::Property> > properties ){
                    m_entity = entity;
                    m_instanceId = instanceId;
                    m_properties = properties;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Claimed/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("entity", EntityPointerToJson(m_entity));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("instanceId", m_instanceId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_properties.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::Property>::const_iterator iterator = m_properties->begin(), end = m_properties->end(); iterator != end; ++iterator) {
                            Mber::Property next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(PropertyToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Instance{
            namespace Delete{
                // Mber::digitalGood::Instance::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string digitalGoodInstanceId,Mber::EntityID definitionId,Mber::EntityPointer entity ){
                    m_digitalGoodInstanceId = digitalGoodInstanceId;
                    m_definitionId = definitionId;
                    m_entity = entity;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Instance/";
                        Poco::URI::encode(m_digitalGoodInstanceId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("digitalGoodInstanceId", m_digitalGoodInstanceId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("entity", EntityPointerToJson(m_entity));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::digitalGood::Instance::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::DigitalGoodInstance>>(new std::list<Mber::DigitalGoodInstance>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToDigitalGoodInstance(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string entityId,Mber::EntityType entityType,Mber::MberPtr<std::list<std::string> > definitionIds,Mber::MberPtr<std::list<Mber::EntitlementState> > states,Mber::MberPtr<bool > includeExpired,Mber::MberPtr<std::list<std::string> > categories ){
                    m_entityId = entityId;
                    m_entityType = entityType;
                    m_definitionIds = definitionIds;
                    m_states = states;
                    m_includeExpired = includeExpired;
                    m_categories = categories;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Instance/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&entityId=");
                        Poco::URI::encode(stringToString(m_entityId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&entityType=");
                        Poco::URI::encode(EntityTypeToString(m_entityType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_definitionIds.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_definitionIds->begin(), end = m_definitionIds->end(); iterator != end; ++iterator) {
                                mberUrl.append("&definitionIds=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_states.isNull() ){
                            for (std::list<Mber::EntitlementState>::const_iterator iterator = m_states->begin(), end = m_states->end(); iterator != end; ++iterator) {
                                mberUrl.append("&states=");
                                Poco::URI::encode(EntitlementStateToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_includeExpired.isNull() ){Poco::URI::encode(boolToString(*m_includeExpired), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_categories.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                                mberUrl.append("&categories=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Redeemed{
            namespace Create{
                // Mber::digitalGood::Redeemed::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string instanceId,Mber::EntityID definitionId ){
                    m_instanceId = instanceId;
                    m_definitionId = definitionId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/digitalGood/Redeemed/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("instanceId", m_instanceId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("definitionId", (*(m_definitionId.id) != NULL) ? *(m_definitionId.id) : "'" + *(m_definitionId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace entitlement{
        namespace Category{
            namespace List{
                // Mber::entitlement::Category::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(next.convert<std::string>());
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = next;
                        }
                        
                        next = obj->get("totalPages");
                        if( !next.isEmpty() ){
                            totalPages = next;
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<uint64_t > page,Mber::MberPtr<uint64_t > maxResults ){
                    m_page = page;
                    m_maxResults = maxResults;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/entitlement/Category/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_page.isNull() ){Poco::URI::encode(uint64ToString(*m_page), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxResults.isNull() ){Poco::URI::encode(uint64ToString(*m_maxResults), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace data{
        namespace Document{
            namespace Create{
                // Mber::data::Document::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        documentId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("documentId");
                        if( !next.isEmpty() ){
                            documentId = Mber::MberPtr<std::string>(new std::string);
                            *documentId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::string > alias,Mber::MberPtr<std::list<std::string> > tags,Mber::MberPtr<std::list<Mber::Property> > properties,Mber::MberPtr<Mber::EntityID > documentTemplate,Mber::MberPtr<std::string > content,Mber::MberPtr<Mber::EntityID > directoryId,Mber::MberPtr<bool > validateAgainstTemplate,Mber::MberPtr<uint64_t > maxVersionsToKeep,Mber::MberPtr<bool > keepAllVersions,Mber::MberPtr<uint64_t > maxTimeToKeep ){
                    m_name = name;
                    m_alias = alias;
                    m_tags = tags;
                    m_properties = properties;
                    m_documentTemplate = documentTemplate;
                    m_content = content;
                    m_directoryId = directoryId;
                    m_validateAgainstTemplate = validateAgainstTemplate;
                    m_maxVersionsToKeep = maxVersionsToKeep;
                    m_keepAllVersions = keepAllVersions;
                    m_maxTimeToKeep = maxTimeToKeep;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Document/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_tags.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array tags_array;
                        for (std::list<std::string>::const_iterator iterator = m_tags->begin(), end = m_tags->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            tags_array.add(next);
                            
                        }
                        reqJson.set("tags", tags_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_properties.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::Property>::const_iterator iterator = m_properties->begin(), end = m_properties->end(); iterator != end; ++iterator) {
                            Mber::Property next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(PropertyToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_documentTemplate.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("documentTemplate", ((!m_documentTemplate->id->empty()) ? *m_documentTemplate->id : "'" + *m_documentTemplate->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_content.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("content", *m_content);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_directoryId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("directoryId", ((!m_directoryId->id->empty()) ? *m_directoryId->id : "'" + *m_directoryId->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_validateAgainstTemplate.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("validateAgainstTemplate", *m_validateAgainstTemplate);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxVersionsToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxVersionsToKeep", *m_maxVersionsToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_keepAllVersions.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("keepAllVersions", *m_keepAllVersions);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxTimeToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxTimeToKeep", *m_maxTimeToKeep);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::data::Document::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Document>(new Mber::Document);
                            *result = jsonToDocument(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID documentId,Mber::MberPtr<uint64_t > version ){
                    m_documentId = documentId;
                    m_version = version;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Document/";
                        Poco::URI::encode((*(m_documentId.id) != NULL) ? *(m_documentId.id) : "'" + *(m_documentId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_version.isNull() ){Poco::URI::encode(uint64ToString(*m_version), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::data::Document::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::string > name,Mber::MberPtr<std::string > alias,Mber::EntityID documentId,Mber::MberPtr<int > version,Mber::MberPtr<std::list<std::string> > tags,Mber::MberPtr<std::list<Mber::Property> > properties,Mber::MberPtr<std::string > content,Mber::MberPtr<Mber::EntityID > directoryId,Mber::MberPtr<std::list<std::string> > tagsToAdd,Mber::MberPtr<std::list<std::string> > tagsToRemove,Mber::MberPtr<bool > validateAgainstTemplate,Mber::MberPtr<uint64_t > maxVersionsToKeep,Mber::MberPtr<uint64_t > maxTimeToKeep,Mber::MberPtr<bool > keepAllVersions,Mber::MberPtr<int > restoreVersion ){
                    m_name = name;
                    m_alias = alias;
                    m_documentId = documentId;
                    m_version = version;
                    m_tags = tags;
                    m_properties = properties;
                    m_content = content;
                    m_directoryId = directoryId;
                    m_tagsToAdd = tagsToAdd;
                    m_tagsToRemove = tagsToRemove;
                    m_validateAgainstTemplate = validateAgainstTemplate;
                    m_maxVersionsToKeep = maxVersionsToKeep;
                    m_maxTimeToKeep = maxTimeToKeep;
                    m_keepAllVersions = keepAllVersions;
                    m_restoreVersion = restoreVersion;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Document/";
                        Poco::URI::encode((*(m_documentId.id) != NULL) ? *(m_documentId.id) : "'" + *(m_documentId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("documentId", (*(m_documentId.id) != NULL) ? *(m_documentId.id) : "'" + *(m_documentId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_version.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("version", *m_version);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_tags.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array tags_array;
                        for (std::list<std::string>::const_iterator iterator = m_tags->begin(), end = m_tags->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            tags_array.add(next);
                            
                        }
                        reqJson.set("tags", tags_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_properties.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::Property>::const_iterator iterator = m_properties->begin(), end = m_properties->end(); iterator != end; ++iterator) {
                            Mber::Property next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(PropertyToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_content.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("content", *m_content);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_directoryId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("directoryId", ((!m_directoryId->id->empty()) ? *m_directoryId->id : "'" + *m_directoryId->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_tagsToAdd.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array tagsToAdd_array;
                        for (std::list<std::string>::const_iterator iterator = m_tagsToAdd->begin(), end = m_tagsToAdd->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            tagsToAdd_array.add(next);
                            
                        }
                        reqJson.set("tagsToAdd", tagsToAdd_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_tagsToRemove.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array tagsToRemove_array;
                        for (std::list<std::string>::const_iterator iterator = m_tagsToRemove->begin(), end = m_tagsToRemove->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            tagsToRemove_array.add(next);
                            
                        }
                        reqJson.set("tagsToRemove", tagsToRemove_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_validateAgainstTemplate.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("validateAgainstTemplate", *m_validateAgainstTemplate);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxVersionsToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxVersionsToKeep", *m_maxVersionsToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxTimeToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxTimeToKeep", *m_maxTimeToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_keepAllVersions.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("keepAllVersions", *m_keepAllVersions);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_restoreVersion.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("restoreVersion", *m_restoreVersion);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::data::Document::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID documentId ){
                    m_documentId = documentId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Document/";
                        Poco::URI::encode((*(m_documentId.id) != NULL) ? *(m_documentId.id) : "'" + *(m_documentId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("documentId", (*(m_documentId.id) != NULL) ? *(m_documentId.id) : "'" + *(m_documentId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::data::Document::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        truncated = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Document>>(new std::list<Mber::Document>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToDocument(next));
                            }
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<bool > expandTags,Mber::MberPtr<std::list<std::string> > tags ){
                    m_expandTags = expandTags;
                    m_tags = tags;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Document/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_expandTags.isNull() ){Poco::URI::encode(boolToString(*m_expandTags), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_tags.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_tags->begin(), end = m_tags->end(); iterator != end; ++iterator) {
                                mberUrl.append("&tags=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace DocumentTemplate{
            namespace Create{
                // Mber::data::DocumentTemplate::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        documentTemplateId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("documentTemplateId");
                        if( !next.isEmpty() ){
                            documentTemplateId = Mber::MberPtr<std::string>(new std::string);
                            *documentTemplateId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,std::string templateId,Mber::MberPtr<uint64_t > maxVersionsToKeep,Mber::MberPtr<uint64_t > maxTimeToKeep,Mber::MberPtr<bool > keepAllVersions ){
                    m_name = name;
                    m_templateId = templateId;
                    m_maxVersionsToKeep = maxVersionsToKeep;
                    m_maxTimeToKeep = maxTimeToKeep;
                    m_keepAllVersions = keepAllVersions;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentTemplate/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("template", m_templateId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_maxVersionsToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxVersionsToKeep", *m_maxVersionsToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxTimeToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxTimeToKeep", *m_maxTimeToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_keepAllVersions.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("keepAllVersions", *m_keepAllVersions);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::data::DocumentTemplate::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::DocumentTemplate>(new Mber::DocumentTemplate);
                            *result = jsonToDocumentTemplate(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID documentTemplateId ){
                    m_documentTemplateId = documentTemplateId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentTemplate/";
                        Poco::URI::encode((*(m_documentTemplateId.id) != NULL) ? *(m_documentTemplateId.id) : "'" + *(m_documentTemplateId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::data::DocumentTemplate::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::DocumentTemplate>>(new std::list<Mber::DocumentTemplate>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToDocumentTemplate(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentTemplate/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::data::DocumentTemplate::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID documentTemplateId,std::string name,Mber::MberPtr<std::string > templateId,Mber::MberPtr<int > version,Mber::MberPtr<uint64_t > maxVersionsToKeep,Mber::MberPtr<uint64_t > maxTimeToKeep,Mber::MberPtr<bool > keepAllVersions ){
                    m_documentTemplateId = documentTemplateId;
                    m_name = name;
                    m_templateId = templateId;
                    m_version = version;
                    m_maxVersionsToKeep = maxVersionsToKeep;
                    m_maxTimeToKeep = maxTimeToKeep;
                    m_keepAllVersions = keepAllVersions;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentTemplate/";
                        Poco::URI::encode((*(m_documentTemplateId.id) != NULL) ? *(m_documentTemplateId.id) : "'" + *(m_documentTemplateId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("documentTemplateId", (*(m_documentTemplateId.id) != NULL) ? *(m_documentTemplateId.id) : "'" + *(m_documentTemplateId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_templateId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("template", *m_templateId);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_version.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("version", *m_version);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxVersionsToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxVersionsToKeep", *m_maxVersionsToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxTimeToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxTimeToKeep", *m_maxTimeToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_keepAllVersions.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("keepAllVersions", *m_keepAllVersions);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::data::DocumentTemplate::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID documentTemplateId ){
                    m_documentTemplateId = documentTemplateId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentTemplate/";
                        Poco::URI::encode((*(m_documentTemplateId.id) != NULL) ? *(m_documentTemplateId.id) : "'" + *(m_documentTemplateId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("documentTemplateId", (*(m_documentTemplateId.id) != NULL) ? *(m_documentTemplateId.id) : "'" + *(m_documentTemplateId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Directory{
            namespace Create{
                // Mber::data::Directory::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        directoryId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("directoryId");
                        if( !next.isEmpty() ){
                            directoryId = Mber::MberPtr<std::string>(new std::string);
                            *directoryId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::string > alias,Mber::MberPtr<Mber::EntityID > parent,Mber::MberPtr<std::list<Mber::EntityPointer> > children ){
                    m_name = name;
                    m_alias = alias;
                    m_parent = parent;
                    m_children = children;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Directory/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_parent.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("parent", ((!m_parent->id->empty()) ? *m_parent->id : "'" + *m_parent->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_children.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array children_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_children->begin(), end = m_children->end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            children_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("children", children_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::data::Directory::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Directory>(new Mber::Directory);
                            *result = jsonToDirectory(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID directoryId ){
                    m_directoryId = directoryId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Directory/";
                        Poco::URI::encode((*(m_directoryId.id) != NULL) ? *(m_directoryId.id) : "'" + *(m_directoryId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::data::Directory::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::string > name,Mber::MberPtr<std::string > alias,Mber::EntityID directoryId,Mber::MberPtr<Mber::EntityID > parent,Mber::MberPtr<std::list<Mber::EntityPointer> > children ){
                    m_name = name;
                    m_alias = alias;
                    m_directoryId = directoryId;
                    m_parent = parent;
                    m_children = children;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Directory/";
                        Poco::URI::encode((*(m_directoryId.id) != NULL) ? *(m_directoryId.id) : "'" + *(m_directoryId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("directoryId", (*(m_directoryId.id) != NULL) ? *(m_directoryId.id) : "'" + *(m_directoryId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_parent.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("parent", ((!m_parent->id->empty()) ? *m_parent->id : "'" + *m_parent->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_children.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array children_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_children->begin(), end = m_children->end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            children_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("children", children_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::data::Directory::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID directoryId ){
                    m_directoryId = directoryId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Directory/";
                        Poco::URI::encode((*(m_directoryId.id) != NULL) ? *(m_directoryId.id) : "'" + *(m_directoryId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("directoryId", (*(m_directoryId.id) != NULL) ? *(m_directoryId.id) : "'" + *(m_directoryId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::data::Directory::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Directory>>(new std::list<Mber::Directory>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToDirectory(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Directory/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace DocumentQuery{
            namespace Create{
                // Mber::data::DocumentQuery::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        truncated = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Document>>(new std::list<Mber::Document>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToDocument(next));
                            }
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::list<Mber::EntityID> > documentTemplateId,Mber::Query query,Mber::MberPtr<Mber::EntityID > applicationId ){
                    m_documentTemplateId = documentTemplateId;
                    m_query = query;
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentQuery/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        if( !m_documentTemplateId.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array documentTemplateId_array;
                        for (std::list<Mber::EntityID>::const_iterator iterator = m_documentTemplateId->begin(), end = m_documentTemplateId->end(); iterator != end; ++iterator) {
                            Mber::EntityID next = *iterator;
                            
                            // Multiple Struct
                            documentTemplateId_array.add(EntityIDToJson(next));
                            
                        }
                        reqJson.set("documentTemplateId", documentTemplateId_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("query", QueryToJson(m_query));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_applicationId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", ((!m_applicationId->id->empty()) ? *m_applicationId->id : "'" + *m_applicationId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Upload{
            namespace Create{
                // Mber::data::Upload::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        documentId = 0;
                        url = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("documentId");
                        if( !next.isEmpty() ){
                            documentId = Mber::MberPtr<std::string>(new std::string);
                            *documentId = next.convert<std::string>();
                        }
                        
                        next = obj->get("url");
                        if( !next.isEmpty() ){
                            url = Mber::MberPtr<std::string>(new std::string);
                            *url = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::string > alias,long size,Mber::MberPtr<std::string > contentType,Mber::MberPtr<std::list<std::string> > tags,Mber::MberPtr<Mber::EntityID > directoryId ){
                    m_name = name;
                    m_alias = alias;
                    m_size = size;
                    m_contentType = contentType;
                    m_tags = tags;
                    m_directoryId = directoryId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Upload/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("size", m_size);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_contentType.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("contentType", *m_contentType);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_tags.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array tags_array;
                        for (std::list<std::string>::const_iterator iterator = m_tags->begin(), end = m_tags->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            tags_array.add(next);
                            
                        }
                        reqJson.set("tags", tags_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_directoryId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("directoryId", ((!m_directoryId->id->empty()) ? *m_directoryId->id : "'" + *m_directoryId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::data::Upload::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        url = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("url");
                        if( !next.isEmpty() ){
                            url = Mber::MberPtr<std::string>(new std::string);
                            *url = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID documentId,Mber::MberPtr<std::string > name,Mber::MberPtr<std::string > alias,Mber::MberPtr<long > size,Mber::MberPtr<std::string > contentType,Mber::MberPtr<std::list<std::string> > tags,Mber::MberPtr<Mber::EntityID > directoryId ){
                    m_documentId = documentId;
                    m_name = name;
                    m_alias = alias;
                    m_size = size;
                    m_contentType = contentType;
                    m_tags = tags;
                    m_directoryId = directoryId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Upload/";
                        Poco::URI::encode((*(m_documentId.id) != NULL) ? *(m_documentId.id) : "'" + *(m_documentId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("documentId", (*(m_documentId.id) != NULL) ? *(m_documentId.id) : "'" + *(m_documentId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_alias.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("alias", *m_alias);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_size.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("size", *m_size);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_contentType.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("contentType", *m_contentType);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_tags.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array tags_array;
                        for (std::list<std::string>::const_iterator iterator = m_tags->begin(), end = m_tags->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            tags_array.add(next);
                            
                        }
                        reqJson.set("tags", tags_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_directoryId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("directoryId", ((!m_directoryId->id->empty()) ? *m_directoryId->id : "'" + *m_directoryId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::data::Upload::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<std::string>(new std::string);
                            *result = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID documentId,Mber::MberPtr<std::string > contentType ){
                    m_documentId = documentId;
                    m_contentType = contentType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/Upload/";
                        Poco::URI::encode((*(m_documentId.id) != NULL) ? *(m_documentId.id) : "'" + *(m_documentId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_contentType.isNull() ){Poco::URI::encode(stringToString(*m_contentType), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace DocumentReindexing{
            namespace Update{
                // Mber::data::DocumentReindexing::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EventType eventType,Mber::EntityID applicationId,Mber::MberPtr<std::string > templateId,Mber::MberPtr<bool > deleteIndex ){
                    m_eventType = eventType;
                    m_applicationId = applicationId;
                    m_templateId = templateId;
                    m_deleteIndex = deleteIndex;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentReindexing/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("eventType", m_eventType);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_templateId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("templateId", *m_templateId);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_deleteIndex.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("deleteIndex", *m_deleteIndex);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace S3BucketConfig{
            namespace Create{
                // Mber::data::S3BucketConfig::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        bucketConfigId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("bucketConfigId");
                        if( !next.isEmpty() ){
                            bucketConfigId = Mber::MberPtr<std::string>(new std::string);
                            *bucketConfigId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string applicationId,std::string name,std::string accessKey,std::string secretKey,int urlTtl ){
                    m_applicationId = applicationId;
                    m_name = name;
                    m_accessKey = accessKey;
                    m_secretKey = secretKey;
                    m_urlTtl = urlTtl;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/S3BucketConfig/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("applicationId", m_applicationId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("accessKey", m_accessKey);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("secretKey", m_secretKey);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("urlTtl", m_urlTtl);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::data::S3BucketConfig::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string applicationId,Mber::MberPtr<std::string > name,Mber::MberPtr<std::string > accessKey,Mber::MberPtr<std::string > secretKey,Mber::MberPtr<int > urlTtl ){
                    m_applicationId = applicationId;
                    m_name = name;
                    m_accessKey = accessKey;
                    m_secretKey = secretKey;
                    m_urlTtl = urlTtl;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/S3BucketConfig/";
                        Poco::URI::encode(m_applicationId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("applicationId", m_applicationId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_accessKey.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("accessKey", *m_accessKey);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_secretKey.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("secretKey", *m_secretKey);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_urlTtl.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("urlTtl", *m_urlTtl);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::data::S3BucketConfig::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::S3BucketConfig>(new Mber::S3BucketConfig);
                            *result = jsonToS3BucketConfig(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/S3BucketConfig/";
                        Poco::URI::encode(m_applicationId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&applicationId=");
                        Poco::URI::encode(stringToString(m_applicationId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::data::S3BucketConfig::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/S3BucketConfig/";
                        Poco::URI::encode(m_applicationId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("applicationId", m_applicationId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace DocumentHistoryConfiguration{
            namespace Update{
                // Mber::data::DocumentHistoryConfiguration::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string applicationId,Mber::MberPtr<uint64_t > maxVersionsToKeep,Mber::MberPtr<uint64_t > maxTimeToKeep,Mber::MberPtr<bool > keepAllVersions ){
                    m_applicationId = applicationId;
                    m_maxVersionsToKeep = maxVersionsToKeep;
                    m_maxTimeToKeep = maxTimeToKeep;
                    m_keepAllVersions = keepAllVersions;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentHistoryConfiguration/";
                        Poco::URI::encode(m_applicationId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("applicationId", m_applicationId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_maxVersionsToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxVersionsToKeep", *m_maxVersionsToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_maxTimeToKeep.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("maxTimeToKeep", *m_maxTimeToKeep);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_keepAllVersions.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("keepAllVersions", *m_keepAllVersions);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::data::DocumentHistoryConfiguration::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::DocumentHistoryConfiguration>(new Mber::DocumentHistoryConfiguration);
                            *result = jsonToDocumentHistoryConfiguration(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentHistoryConfiguration/";
                        Poco::URI::encode(m_applicationId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&applicationId=");
                        Poco::URI::encode(stringToString(m_applicationId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::data::DocumentHistoryConfiguration::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentHistoryConfiguration/";
                        Poco::URI::encode(m_applicationId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("applicationId", m_applicationId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ApplicationDocumentRestore{
            namespace Update{
                // Mber::data::ApplicationDocumentRestore::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string applicationId,Mber::MberPtr<bool > cascading,Mber::MberPtr<uint64_t > rollbackTime,Mber::MberPtr<bool > earliestVersion ){
                    m_applicationId = applicationId;
                    m_cascading = cascading;
                    m_rollbackTime = rollbackTime;
                    m_earliestVersion = earliestVersion;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/ApplicationDocumentRestore/";
                        Poco::URI::encode(m_applicationId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("applicationId", m_applicationId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_cascading.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("cascading", *m_cascading);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_rollbackTime.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("rollbackTime", *m_rollbackTime);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_earliestVersion.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("earliestVersion", *m_earliestVersion);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace DocumentVersion{
            namespace List{
                // Mber::data::DocumentVersion::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::DocumentVersion>>(new std::list<Mber::DocumentVersion>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToDocumentVersion(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string documentId,Mber::MberPtr<uint64_t > maxResults,Mber::MberPtr<bool > descending ){
                    m_documentId = documentId;
                    m_maxResults = maxResults;
                    m_descending = descending;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DocumentVersion/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&documentId=");
                        Poco::URI::encode(stringToString(m_documentId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_maxResults.isNull() ){Poco::URI::encode(uint64ToString(*m_maxResults), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_descending.isNull() ){Poco::URI::encode(boolToString(*m_descending), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace CDNConfig{
            namespace Create{
                // Mber::data::CDNConfig::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<std::string>(new std::string);
                            *result = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::CDNType cdnType,std::string name,Mber::MberPtr<std::string > defaultPath,Mber::MberPtr<std::string > username,Mber::MberPtr<std::string > password,Mber::MberPtr<std::string > storageUsername,Mber::MberPtr<std::string > storagePassword,Mber::MberPtr<std::string > apiKey,Mber::MberPtr<std::string > account,Mber::MberPtr<std::string > cdnHost,Mber::MberPtr<std::string > baseContainer ){
                    m_cdnType = cdnType;
                    m_name = name;
                    m_defaultPath = defaultPath;
                    m_username = username;
                    m_password = password;
                    m_storageUsername = storageUsername;
                    m_storagePassword = storagePassword;
                    m_apiKey = apiKey;
                    m_account = account;
                    m_cdnHost = cdnHost;
                    m_baseContainer = baseContainer;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/CDNConfig/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("cdnType", m_cdnType);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_defaultPath.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("defaultPath", *m_defaultPath);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_username.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("username", *m_username);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_password.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", *m_password);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_storageUsername.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("storageUsername", *m_storageUsername);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_storagePassword.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("storagePassword", *m_storagePassword);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_apiKey.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("apiKey", *m_apiKey);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_account.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("account", *m_account);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_cdnHost.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("cdnHost", *m_cdnHost);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_baseContainer.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("baseContainer", *m_baseContainer);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::data::CDNConfig::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::CDNConfig>(new Mber::CDNConfig);
                            *result = jsonToCDNConfig(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID id ){
                    m_id = id;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/CDNConfig/";
                        Poco::URI::encode((*(m_id.id) != NULL) ? *(m_id.id) : "'" + *(m_id.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::data::CDNConfig::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID id,Mber::MberPtr<Mber::CDNType > cdnType,Mber::MberPtr<std::string > name,Mber::MberPtr<std::string > defaultPath,Mber::MberPtr<std::string > username,Mber::MberPtr<std::string > password,Mber::MberPtr<std::string > storageUsername,Mber::MberPtr<std::string > storagePassword,Mber::MberPtr<std::string > apiKey,Mber::MberPtr<std::string > account,Mber::MberPtr<std::string > cdnHost,Mber::MberPtr<std::string > baseContainer ){
                    m_id = id;
                    m_cdnType = cdnType;
                    m_name = name;
                    m_defaultPath = defaultPath;
                    m_username = username;
                    m_password = password;
                    m_storageUsername = storageUsername;
                    m_storagePassword = storagePassword;
                    m_apiKey = apiKey;
                    m_account = account;
                    m_cdnHost = cdnHost;
                    m_baseContainer = baseContainer;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/CDNConfig/";
                        Poco::URI::encode((*(m_id.id) != NULL) ? *(m_id.id) : "'" + *(m_id.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("id", (*(m_id.id) != NULL) ? *(m_id.id) : "'" + *(m_id.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_cdnType.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("cdnType", *m_cdnType);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_defaultPath.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("defaultPath", *m_defaultPath);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_username.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("username", *m_username);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_password.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", *m_password);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_storageUsername.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("storageUsername", *m_storageUsername);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_storagePassword.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("storagePassword", *m_storagePassword);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_apiKey.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("apiKey", *m_apiKey);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_account.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("account", *m_account);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_cdnHost.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("cdnHost", *m_cdnHost);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_baseContainer.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("baseContainer", *m_baseContainer);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::data::CDNConfig::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::CDNConfig>>(new std::list<Mber::CDNConfig>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToCDNConfig(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/CDNConfig/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::data::CDNConfig::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID id ){
                    m_id = id;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/CDNConfig/";
                        Poco::URI::encode((*(m_id.id) != NULL) ? *(m_id.id) : "'" + *(m_id.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("id", (*(m_id.id) != NULL) ? *(m_id.id) : "'" + *(m_id.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace CDNSync{
            namespace Create{
                // Mber::data::CDNSync::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityPointer entity,Mber::MberPtr<Mber::EntityID > cdnConfigId,Mber::MberPtr<std::string > resourcePath ){
                    m_entity = entity;
                    m_cdnConfigId = cdnConfigId;
                    m_resourcePath = resourcePath;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/CDNSync/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("entity", EntityPointerToJson(m_entity));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_cdnConfigId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("cdnConfigId", ((!m_cdnConfigId->id->empty()) ? *m_cdnConfigId->id : "'" + *m_cdnConfigId->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_resourcePath.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("resourcePath", *m_resourcePath);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::data::CDNSync::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string entityId,Mber::EntityType entityType,Mber::MberPtr<Mber::EntityID > cdnConfigId ){
                    m_entityId = entityId;
                    m_entityType = entityType;
                    m_cdnConfigId = cdnConfigId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/CDNSync/";
                        Poco::URI::encode(m_entityId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("entityId", m_entityId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("entityType", m_entityType);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_cdnConfigId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("cdnConfigId", ((!m_cdnConfigId->id->empty()) ? *m_cdnConfigId->id : "'" + *m_cdnConfigId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::data::CDNSync::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::CDNConfig>>(new std::list<Mber::CDNConfig>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToCDNConfig(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string entityId,Mber::EntityType entityType ){
                    m_entityId = entityId;
                    m_entityType = entityType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/CDNSync/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&entityId=");
                        Poco::URI::encode(stringToString(m_entityId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&entityType=");
                        Poco::URI::encode(EntityTypeToString(m_entityType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace DirectoryDocumentRestore{
            namespace Update{
                // Mber::data::DirectoryDocumentRestore::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string directoryId,Mber::MberPtr<bool > cascading,Mber::MberPtr<uint64_t > rollbackTime,Mber::MberPtr<bool > earliestVersion ){
                    m_directoryId = directoryId;
                    m_cascading = cascading;
                    m_rollbackTime = rollbackTime;
                    m_earliestVersion = earliestVersion;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/data/DirectoryDocumentRestore/";
                        Poco::URI::encode(m_directoryId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("directoryId", m_directoryId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_cascading.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("cascading", *m_cascading);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_rollbackTime.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("rollbackTime", *m_rollbackTime);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_earliestVersion.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("earliestVersion", *m_earliestVersion);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace openId{
        namespace AuthRequest{
            namespace Create{
                // Mber::openId::AuthRequest::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        providerUrl = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("providerUrl");
                        if( !next.isEmpty() ){
                            providerUrl = Mber::MberPtr<std::string>(new std::string);
                            *providerUrl = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string identity,std::string return_to ){
                    m_identity = identity;
                    m_return_to = return_to;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/openId/AuthRequest/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("identity", m_identity);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("return_to", m_return_to);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::openId::AuthRequest::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        authorization_code = 0;
                        scope = 0;
                        redirect_uri = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("authorization_code");
                        if( !next.isEmpty() ){
                            authorization_code = Mber::MberPtr<std::string>(new std::string);
                            *authorization_code = next.convert<std::string>();
                        }
                        
                        next = obj->get("scope");
                        if( !next.isEmpty() ){
                            scope = Mber::MberPtr<std::string>(new std::string);
                            *scope = next.convert<std::string>();
                        }
                        
                        next = obj->get("redirect_uri");
                        if( !next.isEmpty() ){
                            redirect_uri = Mber::MberPtr<std::string>(new std::string);
                            *redirect_uri = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string AuthRequestId,std::string return_to,std::string client_id,Mber::MberPtr<std::string > redirect_uri,std::list<Mber::Property> properties,Mber::MberPtr<std::string > scope ){
                    m_AuthRequestId = AuthRequestId;
                    m_return_to = return_to;
                    m_client_id = client_id;
                    m_redirect_uri = redirect_uri;
                    m_properties = properties;
                    m_scope = scope;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/openId/AuthRequest/";
                        Poco::URI::encode(m_AuthRequestId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("AuthRequestId", m_AuthRequestId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("return_to", m_return_to);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("client_id", m_client_id);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_redirect_uri.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("redirect_uri", *m_redirect_uri);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::Property>::const_iterator iterator = m_properties.begin(), end = m_properties.end(); iterator != end; ++iterator) {
                            Mber::Property next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(PropertyToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_scope.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("scope", *m_scope);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::openId::AuthRequest::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        mode = 0;
                        responseText = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("mode");
                        if( !next.isEmpty() ){
                            mode = Mber::MberPtr<std::string>(new std::string);
                            *mode = next.convert<std::string>();
                        }
                        
                        next = obj->get("responseText");
                        if( !next.isEmpty() ){
                            responseText = Mber::MberPtr<std::string>(new std::string);
                            *responseText = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::list<Mber::Property> properties ){
                    m_properties = properties;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/openId/AuthRequest/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace OpenIdProvider{
            namespace Update{
                // Mber::openId::OpenIdProvider::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId,std::string domain,std::string identity ){
                    m_applicationId = applicationId;
                    m_domain = domain;
                    m_identity = identity;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/openId/OpenIdProvider/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("domain", m_domain);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("identity", m_identity);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::openId::OpenIdProvider::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/openId/OpenIdProvider/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::openId::OpenIdProvider::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Provider>(new Mber::Provider);
                            *result = jsonToProvider(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/openId/OpenIdProvider/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::openId::OpenIdProvider::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Provider>>(new std::list<Mber::Provider>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToProvider(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/openId/OpenIdProvider/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace Metrics{
        namespace History{
            namespace List{
                // Mber::Metrics::History::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        truncated = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::EventEnvelope>>(new std::list<Mber::EventEnvelope>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToEventEnvelope(next));
                            }
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string entityId,Mber::EntityType entityType,uint64_t startDate,Mber::MberPtr<uint64_t > endDate,Mber::MberPtr<bool > descending,Mber::MberPtr<int > maxResults,Mber::MberPtr<bool > includeChildApplications,Mber::MberPtr<int > version ){
                    m_entityId = entityId;
                    m_entityType = entityType;
                    m_startDate = startDate;
                    m_endDate = endDate;
                    m_descending = descending;
                    m_maxResults = maxResults;
                    m_includeChildApplications = includeChildApplications;
                    m_version = version;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/Metrics/History/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&entityId=");
                        Poco::URI::encode(stringToString(m_entityId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&entityType=");
                        Poco::URI::encode(EntityTypeToString(m_entityType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&startDate=");
                        Poco::URI::encode(uint64ToString(m_startDate), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_endDate.isNull() ){Poco::URI::encode(uint64ToString(*m_endDate), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_descending.isNull() ){Poco::URI::encode(boolToString(*m_descending), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxResults.isNull() ){Poco::URI::encode(intToString(*m_maxResults), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_includeChildApplications.isNull() ){Poco::URI::encode(boolToString(*m_includeChildApplications), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_version.isNull() ){Poco::URI::encode(intToString(*m_version), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileHistory{
            namespace List{
                // Mber::Metrics::ProfileHistory::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        truncated = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::EventEnvelope>>(new std::list<Mber::EventEnvelope>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToEventEnvelope(next));
                            }
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,uint64_t startDate,Mber::MberPtr<std::list<Mber::ProfileHistoryFilter> > filterBy,Mber::MberPtr<int > version ){
                    m_profileId = profileId;
                    m_startDate = startDate;
                    m_filterBy = filterBy;
                    m_version = version;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/Metrics/ProfileHistory/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&startDate=");
                        Poco::URI::encode(uint64ToString(m_startDate), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_filterBy.isNull() ){
                            for (std::list<Mber::ProfileHistoryFilter>::const_iterator iterator = m_filterBy->begin(), end = m_filterBy->end(); iterator != end; ++iterator) {
                                mberUrl.append("&filterBy=");
                                Poco::URI::encode(ProfileHistoryFilterToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_version.isNull() ){Poco::URI::encode(intToString(*m_version), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace OverTime{
            namespace List{
                // Mber::Metrics::OverTime::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        truncated = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::EventEnvelope>>(new std::list<Mber::EventEnvelope>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToEventEnvelope(next));
                            }
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string eventName,Mber::EventType eventType,uint64_t startDate,Mber::MberPtr<uint64_t > endDate,Mber::MberPtr<bool > descending,Mber::MberPtr<int > maxResults,Mber::MberPtr<bool > includeChildApplications,Mber::MberPtr<int > version ){
                    m_eventName = eventName;
                    m_eventType = eventType;
                    m_startDate = startDate;
                    m_endDate = endDate;
                    m_descending = descending;
                    m_maxResults = maxResults;
                    m_includeChildApplications = includeChildApplications;
                    m_version = version;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/Metrics/OverTime/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&eventName=");
                        Poco::URI::encode(stringToString(m_eventName), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&eventType=");
                        Poco::URI::encode(EventTypeToString(m_eventType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&startDate=");
                        Poco::URI::encode(uint64ToString(m_startDate), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_endDate.isNull() ){Poco::URI::encode(uint64ToString(*m_endDate), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_descending.isNull() ){Poco::URI::encode(boolToString(*m_descending), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxResults.isNull() ){Poco::URI::encode(intToString(*m_maxResults), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_includeChildApplications.isNull() ){Poco::URI::encode(boolToString(*m_includeChildApplications), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_version.isNull() ){Poco::URI::encode(intToString(*m_version), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace CountOverTime{
            namespace List{
                // Mber::Metrics::CountOverTime::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        truncated = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Count>>(new std::list<Mber::Count>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToCount(next));
                            }
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string eventName,Mber::EventType eventType,Mber::TimeUnit timeUnit,uint64_t startDate,Mber::MberPtr<uint64_t > endDate,Mber::MberPtr<bool > descending,Mber::MberPtr<bool > includeChildApplications,Mber::MberPtr<int > version ){
                    m_eventName = eventName;
                    m_eventType = eventType;
                    m_timeUnit = timeUnit;
                    m_startDate = startDate;
                    m_endDate = endDate;
                    m_descending = descending;
                    m_includeChildApplications = includeChildApplications;
                    m_version = version;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/Metrics/CountOverTime/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&eventName=");
                        Poco::URI::encode(stringToString(m_eventName), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&eventType=");
                        Poco::URI::encode(EventTypeToString(m_eventType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&timeUnit=");
                        Poco::URI::encode(TimeUnitToString(m_timeUnit), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&startDate=");
                        Poco::URI::encode(uint64ToString(m_startDate), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_endDate.isNull() ){Poco::URI::encode(uint64ToString(*m_endDate), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_descending.isNull() ){Poco::URI::encode(boolToString(*m_descending), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_includeChildApplications.isNull() ){Poco::URI::encode(boolToString(*m_includeChildApplications), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_version.isNull() ){Poco::URI::encode(intToString(*m_version), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace SumOverTime{
            namespace List{
                // Mber::Metrics::SumOverTime::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<long>(new long);
                            *result = next;
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string eventName,Mber::EventType eventType,Mber::MberPtr<uint64_t > startDate,Mber::MberPtr<uint64_t > endDate,Mber::MberPtr<bool > includeChildApplications,Mber::MberPtr<int > version ){
                    m_eventName = eventName;
                    m_eventType = eventType;
                    m_startDate = startDate;
                    m_endDate = endDate;
                    m_includeChildApplications = includeChildApplications;
                    m_version = version;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/Metrics/SumOverTime/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&eventName=");
                        Poco::URI::encode(stringToString(m_eventName), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&eventType=");
                        Poco::URI::encode(EventTypeToString(m_eventType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_startDate.isNull() ){Poco::URI::encode(uint64ToString(*m_startDate), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_endDate.isNull() ){Poco::URI::encode(uint64ToString(*m_endDate), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_includeChildApplications.isNull() ){Poco::URI::encode(boolToString(*m_includeChildApplications), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_version.isNull() ){Poco::URI::encode(intToString(*m_version), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace AvailableEvents{
            namespace List{
                // Mber::Metrics::AvailableEvents::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::AvailableEvent>>(new std::list<Mber::AvailableEvent>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToAvailableEvent(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<int > version ){
                    m_version = version;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/Metrics/AvailableEvents/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_version.isNull() ){Poco::URI::encode(intToString(*m_version), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace RollingSumOverTime{
            namespace List{
                // Mber::Metrics::RollingSumOverTime::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        truncated = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Count>>(new std::list<Mber::Count>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToCount(next));
                            }
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = Mber::MberPtr<bool>(new bool);
                            *truncated = next;
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string eventName,Mber::EventType eventType,Mber::MberPtr<uint64_t > startDate,Mber::MberPtr<uint64_t > endDate,Mber::TimeUnit timeUnit,Mber::MberPtr<bool > descending,Mber::MberPtr<bool > includeChildApplications,Mber::MberPtr<int > version ){
                    m_eventName = eventName;
                    m_eventType = eventType;
                    m_startDate = startDate;
                    m_endDate = endDate;
                    m_timeUnit = timeUnit;
                    m_descending = descending;
                    m_includeChildApplications = includeChildApplications;
                    m_version = version;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/Metrics/RollingSumOverTime/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&eventName=");
                        Poco::URI::encode(stringToString(m_eventName), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&eventType=");
                        Poco::URI::encode(EventTypeToString(m_eventType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_startDate.isNull() ){Poco::URI::encode(uint64ToString(*m_startDate), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_endDate.isNull() ){Poco::URI::encode(uint64ToString(*m_endDate), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&timeUnit=");
                        Poco::URI::encode(TimeUnitToString(m_timeUnit), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_descending.isNull() ){Poco::URI::encode(boolToString(*m_descending), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_includeChildApplications.isNull() ){Poco::URI::encode(boolToString(*m_includeChildApplications), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_version.isNull() ){Poco::URI::encode(intToString(*m_version), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace adyen{
        namespace Notification{
            namespace Create{
                // Mber::adyen::Notification::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        accepted = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("accepted");
                        if( !next.isEmpty() ){
                            accepted = Mber::MberPtr<std::string>(new std::string);
                            *accepted = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::string > basicAuthUserName,Mber::MberPtr<std::string > basicAuthPassword,Mber::MberPtr<bool > live,Mber::MberPtr<std::string > eventCode,Mber::MberPtr<std::string > pspReference,Mber::MberPtr<std::string > originalReference,Mber::MberPtr<std::string > merchantReference,Mber::MberPtr<std::string > merchantAccountCode,Mber::MberPtr<std::string > eventDate,Mber::MberPtr<bool > success,Mber::MberPtr<std::string > paymentMethod,Mber::MberPtr<std::string > operations,Mber::MberPtr<std::string > reason,Mber::MberPtr<long > value,Mber::MberPtr<Mber::CurrencyCode > currency ){
                    m_basicAuthUserName = basicAuthUserName;
                    m_basicAuthPassword = basicAuthPassword;
                    m_live = live;
                    m_eventCode = eventCode;
                    m_pspReference = pspReference;
                    m_originalReference = originalReference;
                    m_merchantReference = merchantReference;
                    m_merchantAccountCode = merchantAccountCode;
                    m_eventDate = eventDate;
                    m_success = success;
                    m_paymentMethod = paymentMethod;
                    m_operations = operations;
                    m_reason = reason;
                    m_value = value;
                    m_currency = currency;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/adyen/Notification/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        if( !m_basicAuthUserName.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("basicAuthUserName", *m_basicAuthUserName);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_basicAuthPassword.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("basicAuthPassword", *m_basicAuthPassword);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_live.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("live", *m_live);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_eventCode.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("eventCode", *m_eventCode);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_pspReference.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("pspReference", *m_pspReference);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_originalReference.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("originalReference", *m_originalReference);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_merchantReference.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("merchantReference", *m_merchantReference);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_merchantAccountCode.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("merchantAccountCode", *m_merchantAccountCode);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_eventDate.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("eventDate", *m_eventDate);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_success.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("success", *m_success);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_paymentMethod.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("paymentMethod", *m_paymentMethod);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_operations.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("operations", *m_operations);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_reason.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("reason", *m_reason);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_value.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("value", *m_value);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_currency.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("currency", *m_currency);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace boaCompra{
        namespace Notification{
            namespace Create{
                // Mber::boaCompra::Notification::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::string > store_id,Mber::MberPtr<std::string > transaction_id,Mber::MberPtr<std::string > order_id,Mber::MberPtr<long > amount,Mber::MberPtr<Mber::CurrencyCode > currency_code,Mber::MberPtr<std::string > payment_id,Mber::MberPtr<std::string > country_payment,Mber::MberPtr<std::string > test_mode ){
                    m_store_id = store_id;
                    m_transaction_id = transaction_id;
                    m_order_id = order_id;
                    m_amount = amount;
                    m_currency_code = currency_code;
                    m_payment_id = payment_id;
                    m_country_payment = country_payment;
                    m_test_mode = test_mode;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/boaCompra/Notification/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        if( !m_store_id.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("store_id", *m_store_id);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_transaction_id.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("transaction_id", *m_transaction_id);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_order_id.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("order_id", *m_order_id);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_amount.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("amount", *m_amount);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_currency_code.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("currency_code", *m_currency_code);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_payment_id.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("payment_id", *m_payment_id);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_country_payment.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("country_payment", *m_country_payment);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_test_mode.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("test_mode", *m_test_mode);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace commerce{
        namespace Offer{
            namespace Create{
                // Mber::commerce::Offer::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        offerId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("offerId");
                        if( !next.isEmpty() ){
                            offerId = Mber::MberPtr<std::string>(new std::string);
                            *offerId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<uint64_t > stock,Mber::MberPtr<std::list<Mber::OfferItem> > inputs,Mber::MberPtr<std::list<Mber::OfferItem> > outputs,Mber::MberPtr<std::list<std::string> > categories,Mber::MberPtr<std::list<Mber::OfferItem> > rewards ){
                    m_name = name;
                    m_stock = stock;
                    m_inputs = inputs;
                    m_outputs = outputs;
                    m_categories = categories;
                    m_rewards = rewards;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Offer/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_stock.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("stock", *m_stock);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_inputs.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array inputs_array;
                        for (std::list<Mber::OfferItem>::const_iterator iterator = m_inputs->begin(), end = m_inputs->end(); iterator != end; ++iterator) {
                            Mber::OfferItem next = *iterator;
                            
                            // Multiple Struct
                            inputs_array.add(OfferItemToJson(next));
                            
                        }
                        reqJson.set("inputs", inputs_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_outputs.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array outputs_array;
                        for (std::list<Mber::OfferItem>::const_iterator iterator = m_outputs->begin(), end = m_outputs->end(); iterator != end; ++iterator) {
                            Mber::OfferItem next = *iterator;
                            
                            // Multiple Struct
                            outputs_array.add(OfferItemToJson(next));
                            
                        }
                        reqJson.set("outputs", outputs_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_categories.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array categories_array;
                        for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            categories_array.add(next);
                            
                        }
                        reqJson.set("categories", categories_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_rewards.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array rewards_array;
                        for (std::list<Mber::OfferItem>::const_iterator iterator = m_rewards->begin(), end = m_rewards->end(); iterator != end; ++iterator) {
                            Mber::OfferItem next = *iterator;
                            
                            // Multiple Struct
                            rewards_array.add(OfferItemToJson(next));
                            
                        }
                        reqJson.set("rewards", rewards_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::commerce::Offer::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Offer>>(new std::list<Mber::Offer>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToOffer(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::list<std::string> > categories ){
                    m_categories = categories;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Offer/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_categories.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                                mberUrl.append("&categories=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::commerce::Offer::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Offer>(new Mber::Offer);
                            *result = jsonToOffer(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID offerId,Mber::MberPtr<Mber::EntityID > application ){
                    m_offerId = offerId;
                    m_application = application;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Offer/";
                        Poco::URI::encode((*(m_offerId.id) != NULL) ? *(m_offerId.id) : "'" + *(m_offerId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::commerce::Offer::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID offerId ){
                    m_offerId = offerId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Offer/";
                        Poco::URI::encode((*(m_offerId.id) != NULL) ? *(m_offerId.id) : "'" + *(m_offerId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("offerId", (*(m_offerId.id) != NULL) ? *(m_offerId.id) : "'" + *(m_offerId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::commerce::Offer::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID offerId,std::string name,Mber::MberPtr<uint64_t > stock,Mber::MberPtr<std::list<Mber::OfferItem> > inputs,Mber::MberPtr<std::list<Mber::OfferItem> > outputs,Mber::MberPtr<std::list<std::string> > categories,Mber::MberPtr<std::list<Mber::OfferItem> > rewards ){
                    m_offerId = offerId;
                    m_name = name;
                    m_stock = stock;
                    m_inputs = inputs;
                    m_outputs = outputs;
                    m_categories = categories;
                    m_rewards = rewards;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Offer/";
                        Poco::URI::encode((*(m_offerId.id) != NULL) ? *(m_offerId.id) : "'" + *(m_offerId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("offerId", (*(m_offerId.id) != NULL) ? *(m_offerId.id) : "'" + *(m_offerId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_stock.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("stock", *m_stock);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_inputs.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array inputs_array;
                        for (std::list<Mber::OfferItem>::const_iterator iterator = m_inputs->begin(), end = m_inputs->end(); iterator != end; ++iterator) {
                            Mber::OfferItem next = *iterator;
                            
                            // Multiple Struct
                            inputs_array.add(OfferItemToJson(next));
                            
                        }
                        reqJson.set("inputs", inputs_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_outputs.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array outputs_array;
                        for (std::list<Mber::OfferItem>::const_iterator iterator = m_outputs->begin(), end = m_outputs->end(); iterator != end; ++iterator) {
                            Mber::OfferItem next = *iterator;
                            
                            // Multiple Struct
                            outputs_array.add(OfferItemToJson(next));
                            
                        }
                        reqJson.set("outputs", outputs_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_categories.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array categories_array;
                        for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            categories_array.add(next);
                            
                        }
                        reqJson.set("categories", categories_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_rewards.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array rewards_array;
                        for (std::list<Mber::OfferItem>::const_iterator iterator = m_rewards->begin(), end = m_rewards->end(); iterator != end; ++iterator) {
                            Mber::OfferItem next = *iterator;
                            
                            // Multiple Struct
                            rewards_array.add(OfferItemToJson(next));
                            
                        }
                        reqJson.set("rewards", rewards_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Store{
            namespace Create{
                // Mber::commerce::Store::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        storeId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("storeId");
                        if( !next.isEmpty() ){
                            storeId = Mber::MberPtr<std::string>(new std::string);
                            *storeId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::list<Mber::EntityID> > offers ){
                    m_name = name;
                    m_offers = offers;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Store/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_offers.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array offers_array;
                        for (std::list<Mber::EntityID>::const_iterator iterator = m_offers->begin(), end = m_offers->end(); iterator != end; ++iterator) {
                            Mber::EntityID next = *iterator;
                            
                            // Multiple Struct
                            offers_array.add(EntityIDToJson(next));
                            
                        }
                        reqJson.set("offers", offers_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::commerce::Store::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Store>>(new std::list<Mber::Store>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToStore(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<Mber::EntityID > application ){
                    m_application = application;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Store/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::commerce::Store::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Store>(new Mber::Store);
                            *result = jsonToStore(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID storeId,Mber::MberPtr<Mber::EntityID > application,Mber::MberPtr<std::list<std::string> > categories ){
                    m_storeId = storeId;
                    m_application = application;
                    m_categories = categories;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Store/";
                        Poco::URI::encode((*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_categories.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_categories->begin(), end = m_categories->end(); iterator != end; ++iterator) {
                                mberUrl.append("&categories=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::commerce::Store::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID storeId ){
                    m_storeId = storeId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Store/";
                        Poco::URI::encode((*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("storeId", (*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::commerce::Store::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID storeId,Mber::MberPtr<std::string > name,Mber::MberPtr<std::list<Mber::EntityID> > addOffers,Mber::MberPtr<std::list<Mber::EntityID> > removeOffers ){
                    m_storeId = storeId;
                    m_name = name;
                    m_addOffers = addOffers;
                    m_removeOffers = removeOffers;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Store/";
                        Poco::URI::encode((*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("storeId", (*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_addOffers.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array addOffers_array;
                        for (std::list<Mber::EntityID>::const_iterator iterator = m_addOffers->begin(), end = m_addOffers->end(); iterator != end; ++iterator) {
                            Mber::EntityID next = *iterator;
                            
                            // Multiple Struct
                            addOffers_array.add(EntityIDToJson(next));
                            
                        }
                        reqJson.set("addOffers", addOffers_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_removeOffers.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array removeOffers_array;
                        for (std::list<Mber::EntityID>::const_iterator iterator = m_removeOffers->begin(), end = m_removeOffers->end(); iterator != end; ++iterator) {
                            Mber::EntityID next = *iterator;
                            
                            // Multiple Struct
                            removeOffers_array.add(EntityIDToJson(next));
                            
                        }
                        reqJson.set("removeOffers", removeOffers_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Cart{
            namespace Read{
                // Mber::commerce::Cart::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Invoice>(new Mber::Invoice);
                            *result = jsonToInvoice(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID storeId,Mber::MberPtr<std::string > paymentRedirectUri ){
                    m_storeId = storeId;
                    m_paymentRedirectUri = paymentRedirectUri;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Cart/";
                        Poco::URI::encode((*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_paymentRedirectUri.isNull() ){Poco::URI::encode(stringToString(*m_paymentRedirectUri), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::commerce::Cart::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        invoice = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("invoice");
                        if( !next.isEmpty() ){
                            invoice = Mber::MberPtr<Mber::Invoice>(new Mber::Invoice);
                            *invoice = jsonToInvoice(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID storeId,Mber::MberPtr<std::list<Mber::EntityID> > offers,Mber::MberPtr<std::string > paymentRedirectUri ){
                    m_storeId = storeId;
                    m_offers = offers;
                    m_paymentRedirectUri = paymentRedirectUri;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Cart/";
                        Poco::URI::encode((*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("storeId", (*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_offers.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array offers_array;
                        for (std::list<Mber::EntityID>::const_iterator iterator = m_offers->begin(), end = m_offers->end(); iterator != end; ++iterator) {
                            Mber::EntityID next = *iterator;
                            
                            // Multiple Struct
                            offers_array.add(EntityIDToJson(next));
                            
                        }
                        reqJson.set("offers", offers_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_paymentRedirectUri.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("paymentRedirectUri", *m_paymentRedirectUri);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Checkout{
            namespace Create{
                // Mber::commerce::Checkout::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID storeId,Mber::MberPtr<Mber::RealMoneyInput > realMoneyInput ){
                    m_storeId = storeId;
                    m_realMoneyInput = realMoneyInput;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Checkout/";
                        Poco::URI::encode((*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("storeId", (*(m_storeId.id) != NULL) ? *(m_storeId.id) : "'" + *(m_storeId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_realMoneyInput.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("realMoneyInput", RealMoneyInputToJson(*m_realMoneyInput));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileInvoice{
            namespace List{
                // Mber::commerce::ProfileInvoice::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Invoice>>(new std::list<Mber::Invoice>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToInvoice(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::MberPtr<Mber::InvoiceStatus > status,Mber::MberPtr<Mber::EntityID > applicationId,Mber::MberPtr<Mber::EntityID > storeId,Mber::MberPtr<uint64_t > minUpdatedTime,Mber::MberPtr<uint64_t > maxUpdatedTime ){
                    m_profileId = profileId;
                    m_status = status;
                    m_applicationId = applicationId;
                    m_storeId = storeId;
                    m_minUpdatedTime = minUpdatedTime;
                    m_maxUpdatedTime = maxUpdatedTime;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/ProfileInvoice/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_status.isNull() ){Poco::URI::encode(InvoiceStatusToString(*m_status), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_minUpdatedTime.isNull() ){Poco::URI::encode(uint64ToString(*m_minUpdatedTime), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxUpdatedTime.isNull() ){Poco::URI::encode(uint64ToString(*m_maxUpdatedTime), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ApplicationInvoice{
            namespace List{
                // Mber::commerce::ApplicationInvoice::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Invoice>>(new std::list<Mber::Invoice>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToInvoice(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<Mber::InvoiceStatus > status,Mber::MberPtr<std::string > profileId,Mber::MberPtr<Mber::EntityID > storeId,Mber::MberPtr<uint64_t > minUpdatedTime,Mber::MberPtr<uint64_t > maxUpdatedTime ){
                    m_status = status;
                    m_profileId = profileId;
                    m_storeId = storeId;
                    m_minUpdatedTime = minUpdatedTime;
                    m_maxUpdatedTime = maxUpdatedTime;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/ApplicationInvoice/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_status.isNull() ){Poco::URI::encode(InvoiceStatusToString(*m_status), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_profileId.isNull() ){Poco::URI::encode(stringToString(*m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_minUpdatedTime.isNull() ){Poco::URI::encode(uint64ToString(*m_minUpdatedTime), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxUpdatedTime.isNull() ){Poco::URI::encode(uint64ToString(*m_maxUpdatedTime), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ProfileCurrency{
            namespace Read{
                // Mber::commerce::ProfileCurrency::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::CurrencyCode>(new Mber::CurrencyCode);
                            *result = jsonToCurrencyCode(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::EntityID applicationId ){
                    m_profileId = profileId;
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/ProfileCurrency/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace VirtualCurrency{
            namespace Create{
                // Mber::commerce::VirtualCurrency::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        virtualCurrencyId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("virtualCurrencyId");
                        if( !next.isEmpty() ){
                            virtualCurrencyId = Mber::MberPtr<std::string>(new std::string);
                            *virtualCurrencyId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::DeductionRule deductionRule,Mber::MberPtr<int > walletTtl ){
                    m_name = name;
                    m_deductionRule = deductionRule;
                    m_walletTtl = walletTtl;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/VirtualCurrency/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("deductionRule", DeductionRuleToJson(m_deductionRule));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_walletTtl.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("walletTtl", *m_walletTtl);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::commerce::VirtualCurrency::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::VirtualCurrency>>(new std::list<Mber::VirtualCurrency>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToVirtualCurrency(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<bool > disabledSpending,Mber::MberPtr<bool > disabledEarning ){
                    m_disabledSpending = disabledSpending;
                    m_disabledEarning = disabledEarning;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/VirtualCurrency/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_disabledSpending.isNull() ){Poco::URI::encode(boolToString(*m_disabledSpending), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_disabledEarning.isNull() ){Poco::URI::encode(boolToString(*m_disabledEarning), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::commerce::VirtualCurrency::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::VirtualCurrency>(new Mber::VirtualCurrency);
                            *result = jsonToVirtualCurrency(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID virtualCurrencyId ){
                    m_virtualCurrencyId = virtualCurrencyId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/VirtualCurrency/";
                        Poco::URI::encode((*(m_virtualCurrencyId.id) != NULL) ? *(m_virtualCurrencyId.id) : "'" + *(m_virtualCurrencyId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::commerce::VirtualCurrency::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID virtualCurrencyId,std::string name,bool disabledSpending,bool disabledEarning,Mber::DeductionRule deductionRule,Mber::MberPtr<int > walletTtl ){
                    m_virtualCurrencyId = virtualCurrencyId;
                    m_name = name;
                    m_disabledSpending = disabledSpending;
                    m_disabledEarning = disabledEarning;
                    m_deductionRule = deductionRule;
                    m_walletTtl = walletTtl;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/VirtualCurrency/";
                        Poco::URI::encode((*(m_virtualCurrencyId.id) != NULL) ? *(m_virtualCurrencyId.id) : "'" + *(m_virtualCurrencyId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("virtualCurrencyId", (*(m_virtualCurrencyId.id) != NULL) ? *(m_virtualCurrencyId.id) : "'" + *(m_virtualCurrencyId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("disabledSpending", m_disabledSpending);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("disabledEarning", m_disabledEarning);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("deductionRule", DeductionRuleToJson(m_deductionRule));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_walletTtl.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("walletTtl", *m_walletTtl);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::commerce::VirtualCurrency::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID virtualCurrencyId ){
                    m_virtualCurrencyId = virtualCurrencyId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/VirtualCurrency/";
                        Poco::URI::encode((*(m_virtualCurrencyId.id) != NULL) ? *(m_virtualCurrencyId.id) : "'" + *(m_virtualCurrencyId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("virtualCurrencyId", (*(m_virtualCurrencyId.id) != NULL) ? *(m_virtualCurrencyId.id) : "'" + *(m_virtualCurrencyId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace WalletLot{
            namespace Create{
                // Mber::commerce::WalletLot::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        lotId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("lotId");
                        if( !next.isEmpty() ){
                            lotId = Mber::MberPtr<std::string>(new std::string);
                            *lotId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID virtualCurrencyId,std::string profileId,double amount ){
                    m_virtualCurrencyId = virtualCurrencyId;
                    m_profileId = profileId;
                    m_amount = amount;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/WalletLot/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("virtualCurrencyId", (*(m_virtualCurrencyId.id) != NULL) ? *(m_virtualCurrencyId.id) : "'" + *(m_virtualCurrencyId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("amount", m_amount);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::commerce::WalletLot::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::WalletLot>(new Mber::WalletLot);
                            *result = jsonToWalletLot(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID virtualCurrencyId,std::string lotId,std::string profileId ){
                    m_virtualCurrencyId = virtualCurrencyId;
                    m_lotId = lotId;
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/WalletLot/";
                        Poco::URI::encode(m_lotId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&lotId=");
                        Poco::URI::encode(stringToString(m_lotId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::commerce::WalletLot::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID virtualCurrencyId,std::string lotId,double amountChange,std::string profileId ){
                    m_virtualCurrencyId = virtualCurrencyId;
                    m_lotId = lotId;
                    m_amountChange = amountChange;
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/WalletLot/";
                        Poco::URI::encode(m_lotId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("virtualCurrencyId", (*(m_virtualCurrencyId.id) != NULL) ? *(m_virtualCurrencyId.id) : "'" + *(m_virtualCurrencyId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("lotId", m_lotId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("amountChange", m_amountChange);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::commerce::WalletLot::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::WalletLot>>(new std::list<Mber::WalletLot>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToWalletLot(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID virtualCurrencyId,std::string profileId ){
                    m_virtualCurrencyId = virtualCurrencyId;
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/WalletLot/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&profileId=");
                        Poco::URI::encode(stringToString(m_profileId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Wallet{
            namespace Read{
                // Mber::commerce::Wallet::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Wallet>(new Mber::Wallet);
                            *result = jsonToWallet(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string entityId,Mber::MberPtr<Mber::EntityType > entityType ){
                    m_entityId = entityId;
                    m_entityType = entityType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Wallet/";
                        Poco::URI::encode(m_entityId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&entityId=");
                        Poco::URI::encode(stringToString(m_entityId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_entityType.isNull() ){Poco::URI::encode(EntityTypeToString(*m_entityType), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Deduction{
            namespace Create{
                // Mber::commerce::Deduction::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID virtualCurrencyId,double amount,Mber::MberPtr<std::string > reason,Mber::EntityPointer recipient ){
                    m_virtualCurrencyId = virtualCurrencyId;
                    m_amount = amount;
                    m_reason = reason;
                    m_recipient = recipient;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Deduction/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("virtualCurrencyId", (*(m_virtualCurrencyId.id) != NULL) ? *(m_virtualCurrencyId.id) : "'" + *(m_virtualCurrencyId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("amount", m_amount);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_reason.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("reason", *m_reason);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("recipient", EntityPointerToJson(m_recipient));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Catalog{
            namespace List{
                // Mber::commerce::Catalog::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::EntityPointer>>(new std::list<Mber::EntityPointer>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToEntityPointer(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<Mber::EntityType > entityType ){
                    m_entityType = entityType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Catalog/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_entityType.isNull() ){Poco::URI::encode(EntityTypeToString(*m_entityType), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Create{
                // Mber::commerce::Catalog::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::list<Mber::EntityPointer> > addItems,Mber::MberPtr<std::list<Mber::EntityPointer> > removeItems ){
                    m_addItems = addItems;
                    m_removeItems = removeItems;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Catalog/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        if( !m_addItems.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array addItems_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_addItems->begin(), end = m_addItems->end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            addItems_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("addItems", addItems_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_removeItems.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array removeItems_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_removeItems->begin(), end = m_removeItems->end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            removeItems_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("removeItems", removeItems_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace PaymentProvider{
            namespace Create{
                // Mber::commerce::PaymentProvider::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        providerId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("providerId");
                        if( !next.isEmpty() ){
                            providerId = Mber::MberPtr<std::string>(new std::string);
                            *providerId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::RealMoneyTransactionProvider provider,Mber::MberPtr<std::string > merchantId,Mber::MberPtr<std::string > paymentPageId,Mber::MberPtr<std::string > merchantSecret,Mber::MberPtr<std::string > paymentPageUri,Mber::MberPtr<std::string > notificationUri,Mber::MberPtr<bool > testMode ){
                    m_provider = provider;
                    m_merchantId = merchantId;
                    m_paymentPageId = paymentPageId;
                    m_merchantSecret = merchantSecret;
                    m_paymentPageUri = paymentPageUri;
                    m_notificationUri = notificationUri;
                    m_testMode = testMode;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/PaymentProvider/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("provider", m_provider);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_merchantId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("merchantId", *m_merchantId);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_paymentPageId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("paymentPageId", *m_paymentPageId);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_merchantSecret.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("merchantSecret", *m_merchantSecret);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_paymentPageUri.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("paymentPageUri", *m_paymentPageUri);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_notificationUri.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("notificationUri", *m_notificationUri);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_testMode.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("testMode", *m_testMode);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::commerce::PaymentProvider::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::PaymentProvider>(new Mber::PaymentProvider);
                            *result = jsonToPaymentProvider(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string providerId ){
                    m_providerId = providerId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/PaymentProvider/";
                        Poco::URI::encode(m_providerId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&providerId=");
                        Poco::URI::encode(stringToString(m_providerId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::commerce::PaymentProvider::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::PaymentProvider>>(new std::list<Mber::PaymentProvider>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToPaymentProvider(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<bool > activeOnly ){
                    m_activeOnly = activeOnly;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/PaymentProvider/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_activeOnly.isNull() ){Poco::URI::encode(boolToString(*m_activeOnly), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::commerce::PaymentProvider::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string providerId ){
                    m_providerId = providerId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/PaymentProvider/";
                        Poco::URI::encode(m_providerId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("providerId", m_providerId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace SteamOfferGrant{
            namespace Create{
                // Mber::commerce::SteamOfferGrant::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID steamApplication,std::string profileId ){
                    m_steamApplication = steamApplication;
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/SteamOfferGrant/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("steamApplication", (*(m_steamApplication.id) != NULL) ? *(m_steamApplication.id) : "'" + *(m_steamApplication.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::commerce::SteamOfferGrant::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID steamApplication,std::string profileId ){
                    m_steamApplication = steamApplication;
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/SteamOfferGrant/";
                        Poco::URI::encode(m_profileId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("steamApplication", (*(m_steamApplication.id) != NULL) ? *(m_steamApplication.id) : "'" + *(m_steamApplication.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Affiliate{
            namespace Create{
                // Mber::commerce::Affiliate::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        affiliateId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("affiliateId");
                        if( !next.isEmpty() ){
                            affiliateId = Mber::MberPtr<std::string>(new std::string);
                            *affiliateId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,Mber::MberPtr<std::string > profileId ){
                    m_name = name;
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Affiliate/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_profileId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", *m_profileId);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::commerce::Affiliate::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Affiliate>(new Mber::Affiliate);
                            *result = jsonToAffiliate(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID affiliateId ){
                    m_affiliateId = affiliateId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Affiliate/";
                        Poco::URI::encode((*(m_affiliateId.id) != NULL) ? *(m_affiliateId.id) : "'" + *(m_affiliateId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::commerce::Affiliate::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Affiliate>(new Mber::Affiliate);
                            *result = jsonToAffiliate(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID affiliateId,Mber::MberPtr<std::string > name,Mber::MberPtr<std::string > profileId ){
                    m_affiliateId = affiliateId;
                    m_name = name;
                    m_profileId = profileId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Affiliate/";
                        Poco::URI::encode((*(m_affiliateId.id) != NULL) ? *(m_affiliateId.id) : "'" + *(m_affiliateId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("affiliateId", (*(m_affiliateId.id) != NULL) ? *(m_affiliateId.id) : "'" + *(m_affiliateId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_profileId.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", *m_profileId);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::commerce::Affiliate::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID affiliateId ){
                    m_affiliateId = affiliateId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Affiliate/";
                        Poco::URI::encode((*(m_affiliateId.id) != NULL) ? *(m_affiliateId.id) : "'" + *(m_affiliateId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("affiliateId", (*(m_affiliateId.id) != NULL) ? *(m_affiliateId.id) : "'" + *(m_affiliateId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::commerce::Affiliate::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Affiliate>>(new std::list<Mber::Affiliate>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToAffiliate(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/Affiliate/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ReferralCount{
            namespace List{
                // Mber::commerce::ReferralCount::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::ReferralCount>>(new std::list<Mber::ReferralCount>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToReferralCount(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<bool > convertedOnly ){
                    m_convertedOnly = convertedOnly;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/ReferralCount/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_convertedOnly.isNull() ){Poco::URI::encode(boolToString(*m_convertedOnly), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace ReferralPurchaseTotals{
            namespace List{
                // Mber::commerce::ReferralPurchaseTotals::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::ReferralEntityTotals>>(new std::list<Mber::ReferralEntityTotals>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToReferralEntityTotals(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityType inputType ){
                    m_inputType = inputType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/commerce/ReferralPurchaseTotals/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&inputType=");
                        Poco::URI::encode(EntityTypeToString(m_inputType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace serverManagement{
        namespace Heartbeat{
            namespace Create{
                // Mber::serverManagement::Heartbeat::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID serverId,Mber::MberPtr<std::string > status,Mber::MberPtr<uint64_t > currentUsers,Mber::MberPtr<uint64_t > userCapacity,Mber::MberPtr<double > utilization ){
                    m_serverId = serverId;
                    m_status = status;
                    m_currentUsers = currentUsers;
                    m_userCapacity = userCapacity;
                    m_utilization = utilization;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Heartbeat/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("serverId", (*(m_serverId.id) != NULL) ? *(m_serverId.id) : "'" + *(m_serverId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_status.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("status", *m_status);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_currentUsers.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("currentUsers", *m_currentUsers);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_userCapacity.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("userCapacity", *m_userCapacity);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_utilization.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("utilization", *m_utilization);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Server{
            namespace Create{
                // Mber::serverManagement::Server::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        serverId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("serverId");
                        if( !next.isEmpty() ){
                            serverId = Mber::MberPtr<std::string>(new std::string);
                            *serverId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,std::string host,Mber::MberPtr<int > port,Mber::MberPtr<int > heartbeatInterval,std::string serverType,Mber::MberPtr<uint64_t > userCapacity ){
                    m_name = name;
                    m_host = host;
                    m_port = port;
                    m_heartbeatInterval = heartbeatInterval;
                    m_serverType = serverType;
                    m_userCapacity = userCapacity;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Server/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("host", m_host);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_port.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("port", *m_port);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_heartbeatInterval.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("heartbeatInterval", *m_heartbeatInterval);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("serverType", m_serverType);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_userCapacity.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("userCapacity", *m_userCapacity);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::serverManagement::Server::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Server>(new Mber::Server);
                            *result = jsonToServer(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID serverId ){
                    m_serverId = serverId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Server/";
                        Poco::URI::encode((*(m_serverId.id) != NULL) ? *(m_serverId.id) : "'" + *(m_serverId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::serverManagement::Server::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID serverId,std::string name,std::string host,Mber::MberPtr<int > port,Mber::MberPtr<int > heartbeatInterval,Mber::MberPtr<std::string > serverType,Mber::MberPtr<std::string > status,Mber::MberPtr<uint64_t > currentUsers,Mber::MberPtr<uint64_t > userCapacity,Mber::MberPtr<double > utilization ){
                    m_serverId = serverId;
                    m_name = name;
                    m_host = host;
                    m_port = port;
                    m_heartbeatInterval = heartbeatInterval;
                    m_serverType = serverType;
                    m_status = status;
                    m_currentUsers = currentUsers;
                    m_userCapacity = userCapacity;
                    m_utilization = utilization;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Server/";
                        Poco::URI::encode((*(m_serverId.id) != NULL) ? *(m_serverId.id) : "'" + *(m_serverId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("serverId", (*(m_serverId.id) != NULL) ? *(m_serverId.id) : "'" + *(m_serverId.name));
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("host", m_host);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_port.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("port", *m_port);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_heartbeatInterval.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("heartbeatInterval", *m_heartbeatInterval);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_serverType.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("serverType", *m_serverType);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_status.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("status", *m_status);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_currentUsers.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("currentUsers", *m_currentUsers);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_userCapacity.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("userCapacity", *m_userCapacity);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_utilization.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("utilization", *m_utilization);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::serverManagement::Server::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID serverId ){
                    m_serverId = serverId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Server/";
                        Poco::URI::encode((*(m_serverId.id) != NULL) ? *(m_serverId.id) : "'" + *(m_serverId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("serverId", (*(m_serverId.id) != NULL) ? *(m_serverId.id) : "'" + *(m_serverId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::serverManagement::Server::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Server>>(new std::list<Mber::Server>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToServer(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                        next = obj->get("truncated");
                        if( !next.isEmpty() ){
                            truncated = next;
                        }
                        
                        next = obj->get("totalPages");
                        if( !next.isEmpty() ){
                            totalPages = next;
                        }
                        
                    };
                };
                Request::Request( Mber::MberPtr<std::list<std::string> > serverType,Mber::MberPtr<std::list<std::string> > status,Mber::MberPtr<Mber::ServerState > state,Mber::MberPtr<uint64_t > minUsers,Mber::MberPtr<uint64_t > maxUsers,Mber::MberPtr<uint64_t > minCapacity,Mber::MberPtr<uint64_t > maxCapacity,Mber::MberPtr<double > minUtilization,Mber::MberPtr<double > maxUtilization,Mber::MberPtr<uint64_t > page,Mber::MberPtr<uint64_t > maxResults ){
                    m_serverType = serverType;
                    m_status = status;
                    m_state = state;
                    m_minUsers = minUsers;
                    m_maxUsers = maxUsers;
                    m_minCapacity = minCapacity;
                    m_maxCapacity = maxCapacity;
                    m_minUtilization = minUtilization;
                    m_maxUtilization = maxUtilization;
                    m_page = page;
                    m_maxResults = maxResults;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Server/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_serverType.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_serverType->begin(), end = m_serverType->end(); iterator != end; ++iterator) {
                                mberUrl.append("&serverType=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_status.isNull() ){
                            for (std::list<std::string>::const_iterator iterator = m_status->begin(), end = m_status->end(); iterator != end; ++iterator) {
                                mberUrl.append("&status=");
                                Poco::URI::encode(stringToString(*iterator), "!#$&'()*+,/:;=?@[]", tmp);
                                mberUrl.append(tmp);
                                tmp = "";
                            }
                        }
                        
                        if( !m_state.isNull() ){Poco::URI::encode(ServerStateToString(*m_state), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_minUsers.isNull() ){Poco::URI::encode(uint64ToString(*m_minUsers), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxUsers.isNull() ){Poco::URI::encode(uint64ToString(*m_maxUsers), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_minCapacity.isNull() ){Poco::URI::encode(uint64ToString(*m_minCapacity), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxCapacity.isNull() ){Poco::URI::encode(uint64ToString(*m_maxCapacity), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_minUtilization.isNull() ){Poco::URI::encode(doubleToString(*m_minUtilization), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxUtilization.isNull() ){Poco::URI::encode(doubleToString(*m_maxUtilization), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_page.isNull() ){Poco::URI::encode(uint64ToString(*m_page), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_maxResults.isNull() ){Poco::URI::encode(uint64ToString(*m_maxResults), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace Lobby{
            namespace Create{
                // Mber::serverManagement::Lobby::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        lobbyId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("lobbyId");
                        if( !next.isEmpty() ){
                            lobbyId = Mber::MberPtr<std::string>(new std::string);
                            *lobbyId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string serverId,std::string name,Mber::MberPtr<std::list<std::string> > profiles ){
                    m_serverId = serverId;
                    m_name = name;
                    m_profiles = profiles;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Lobby/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("serverId", m_serverId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_profiles.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array profiles_array;
                        for (std::list<std::string>::const_iterator iterator = m_profiles->begin(), end = m_profiles->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            profiles_array.add(next);
                            
                        }
                        reqJson.set("profiles", profiles_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::serverManagement::Lobby::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Lobby>(new Mber::Lobby);
                            *result = jsonToLobby(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string lobbyId ){
                    m_lobbyId = lobbyId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Lobby/";
                        Poco::URI::encode(m_lobbyId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&lobbyId=");
                        Poco::URI::encode(stringToString(m_lobbyId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::serverManagement::Lobby::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string lobbyId,std::string name,Mber::MberPtr<std::list<std::string> > addProfiles,Mber::MberPtr<std::list<std::string> > removeProfiles ){
                    m_lobbyId = lobbyId;
                    m_name = name;
                    m_addProfiles = addProfiles;
                    m_removeProfiles = removeProfiles;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Lobby/";
                        Poco::URI::encode(m_lobbyId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("lobbyId", m_lobbyId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_addProfiles.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array addProfiles_array;
                        for (std::list<std::string>::const_iterator iterator = m_addProfiles->begin(), end = m_addProfiles->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            addProfiles_array.add(next);
                            
                        }
                        reqJson.set("addProfiles", addProfiles_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_removeProfiles.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array removeProfiles_array;
                        for (std::list<std::string>::const_iterator iterator = m_removeProfiles->begin(), end = m_removeProfiles->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            removeProfiles_array.add(next);
                            
                        }
                        reqJson.set("removeProfiles", removeProfiles_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::serverManagement::Lobby::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string lobbyId ){
                    m_lobbyId = lobbyId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Lobby/";
                        Poco::URI::encode(m_lobbyId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("lobbyId", m_lobbyId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::serverManagement::Lobby::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Lobby>>(new std::list<Mber::Lobby>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToLobby(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string serverId ){
                    m_serverId = serverId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/Lobby/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&serverId=");
                        Poco::URI::encode(stringToString(m_serverId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace MberProcess{
            namespace List{
                // Mber::serverManagement::MberProcess::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<std::string>>(new std::list<std::string>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(next.convert<std::string>());
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request(  ){
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/MberProcess/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::serverManagement::MberProcess::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string processName,Mber::MberPtr<Mber::EntityID > applicationId,Mber::EventType action,Mber::MberPtr<std::list<Mber::Property> > properties ){
                    m_processName = processName;
                    m_applicationId = applicationId;
                    m_action = action;
                    m_properties = properties;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/serverManagement/MberProcess/";
                        Poco::URI::encode(((!m_applicationId->id->empty()) ? *m_applicationId->id : "'" + *m_applicationId->name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("processName", m_processName);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_applicationId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", ((!m_applicationId->id->empty()) ? *m_applicationId->id : "'" + *m_applicationId->name));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("action", m_action);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_properties.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array properties_array;
                        for (std::list<Mber::Property>::const_iterator iterator = m_properties->begin(), end = m_properties->end(); iterator != end; ++iterator) {
                            Mber::Property next = *iterator;
                            
                            // Multiple Struct
                            properties_array.add(PropertyToJson(next));
                            
                        }
                        reqJson.set("properties", properties_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace messaging{
        namespace Email{
            namespace Create{
                // Mber::messaging::Email::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::list<Mber::EntityPointer> to,std::list<Mber::EntityPointer> cc,std::list<Mber::EntityPointer> bcc,Mber::MberPtr<Mber::DocumentMessage > documentMessage,Mber::MberPtr<Mber::StringMessage > stringMessage ){
                    m_to = to;
                    m_cc = cc;
                    m_bcc = bcc;
                    m_documentMessage = documentMessage;
                    m_stringMessage = stringMessage;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/messaging/Email/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle multiple
                        Poco::JSON::Array to_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_to.begin(), end = m_to.end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            to_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("to", to_array);
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle multiple
                        Poco::JSON::Array cc_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_cc.begin(), end = m_cc.end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            cc_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("cc", cc_array);
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle multiple
                        Poco::JSON::Array bcc_array;
                        for (std::list<Mber::EntityPointer>::const_iterator iterator = m_bcc.begin(), end = m_bcc.end(); iterator != end; ++iterator) {
                            Mber::EntityPointer next = *iterator;
                            
                            // Multiple Struct
                            bcc_array.add(EntityPointerToJson(next));
                            
                        }
                        reqJson.set("bcc", bcc_array);
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_documentMessage.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("documentMessage", DocumentMessageToJson(*m_documentMessage));
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_stringMessage.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("stringMessage", StringMessageToJson(*m_stringMessage));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace EmailValidation{
            namespace Create{
                // Mber::messaging::EmailValidation::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string profileId,Mber::MberPtr<Mber::EntityID > applicationId ){
                    m_profileId = profileId;
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/messaging/EmailValidation/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("profileId", m_profileId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_applicationId.isNull() ){

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", ((!m_applicationId->id->empty()) ? *m_applicationId->id : "'" + *m_applicationId->name));
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::messaging::EmailValidation::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string token ){
                    m_token = token;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/messaging/EmailValidation/";
                        Poco::URI::encode(m_token, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("token", m_token);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    
        namespace EmailConfiguration{
            namespace Update{
                // Mber::messaging::EmailConfiguration::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string host,Mber::MberPtr<int > port,Mber::MberPtr<bool > useSsl,Mber::MberPtr<bool > useTls,Mber::MberPtr<std::string > userName,Mber::MberPtr<std::string > password,std::string senderEmail,Mber::MberPtr<std::string > senderName ){
                    m_host = host;
                    m_port = port;
                    m_useSsl = useSsl;
                    m_useTls = useTls;
                    m_userName = userName;
                    m_password = password;
                    m_senderEmail = senderEmail;
                    m_senderName = senderName;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/messaging/EmailConfiguration/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("host", m_host);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_port.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("port", *m_port);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_useSsl.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("useSsl", *m_useSsl);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_useTls.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("useTls", *m_useTls);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_userName.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("userName", *m_userName);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_password.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("password", *m_password);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("senderEmail", m_senderEmail);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_senderName.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("senderName", *m_senderName);
                        
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::messaging::EmailConfiguration::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/messaging/EmailConfiguration/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Struct
                        reqJson.set("applicationId", (*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name));
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::messaging::EmailConfiguration::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::EmailConfig>(new Mber::EmailConfig);
                            *result = jsonToEmailConfig(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( Mber::EntityID applicationId ){
                    m_applicationId = applicationId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/messaging/EmailConfiguration/";
                        Poco::URI::encode((*(m_applicationId.id) != NULL) ? *(m_applicationId.id) : "'" + *(m_applicationId.name), "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

    namespace groups{
        namespace Group{
            namespace Create{
                // Mber::groups::Group::Create
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        groupId = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("groupId");
                        if( !next.isEmpty() ){
                            groupId = Mber::MberPtr<std::string>(new std::string);
                            *groupId = next.convert<std::string>();
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string name,std::string parentId,Mber::EntityType parentType,Mber::EntityType groupType ){
                    m_name = name;
                    m_parentId = parentId;
                    m_parentType = parentType;
                    m_groupType = groupType;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/groups/Group/";
                        
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", m_name);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("parentId", m_parentId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("parentType", m_parentType);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("groupType", m_groupType);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_POST, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Read{
                // Mber::groups::Group::Read
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        result = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("result");
                        if( !next.isEmpty() ){
                            result = Mber::MberPtr<Mber::Group>(new Mber::Group);
                            *result = jsonToGroup(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string groupId ){
                    m_groupId = groupId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/groups/Group/";
                        Poco::URI::encode(m_groupId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&groupId=");
                        Poco::URI::encode(stringToString(m_groupId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace List{
                // Mber::groups::Group::List
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        results = 0;
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("results");
                        if( !next.isEmpty() ){
                            results = Mber::MberPtr<std::list<Mber::Group>>(new std::list<Mber::Group>);
                            Poco::JSON::Array::Ptr nextArray = next.extract<Poco::JSON::Array::Ptr>();
                            for( int i=0; i<nextArray->size(); i++ ){
                                next = nextArray->get(i);
                                results->push_back(jsonToGroup(next));
                            }
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string parentId,Mber::EntityType parentType,Mber::MberPtr<Mber::EntityType > groupType,Mber::MberPtr<std::string > name ){
                    m_parentId = parentId;
                    m_parentType = parentType;
                    m_groupType = groupType;
                    m_name = name;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/groups/Group/";
                        
                        
                        mberUrl.append("?transactionId=");
                        if( transactionId != 0 ){
                            Poco::URI::encode(*transactionId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        } else {
                            Poco::URI::encode(generateTransactionId(), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( correlationId != 0 ){
                            Poco::URI::encode(*correlationId, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append("&correlationId=");
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        if( token != 0 ){
                            mberUrl.append("&access_token=");
                            Poco::URI::encode(*token, "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        mberUrl.append("&parentId=");
                        Poco::URI::encode(stringToString(m_parentId), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        mberUrl.append("&parentType=");
                        Poco::URI::encode(EntityTypeToString(m_parentType), "!#$&'()*+,/:;=?@[]", tmp);
                        mberUrl.append(tmp);
                        tmp = "";
                        
                        if( !m_groupType.isNull() ){Poco::URI::encode(EntityTypeToString(*m_groupType), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        if( !m_name.isNull() ){Poco::URI::encode(stringToString(*m_name), "!#$&'()*+,/:;=?@[]", tmp);
                            mberUrl.append(tmp);
                            tmp = "";
                        }
                        
                        HTTPRequest request(HTTPRequest::HTTP_GET, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        session->sendRequest(request);
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Update{
                // Mber::groups::Group::Update
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string groupId,Mber::MberPtr<std::string > name,Mber::MberPtr<std::list<std::string> > addMembers,Mber::MberPtr<std::list<std::string> > removeMembers ){
                    m_groupId = groupId;
                    m_name = name;
                    m_addMembers = addMembers;
                    m_removeMembers = removeMembers;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/groups/Group/";
                        Poco::URI::encode(m_groupId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("groupId", m_groupId);
                        
                        

                        // Optional Handler Close
                        
                        // Optional Handler Open
                        if( !m_name.isNull() ){

                        
                        // Handle singular
                        // Simple
                        reqJson.set("name", *m_name);
                        
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_addMembers.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array addMembers_array;
                        for (std::list<std::string>::const_iterator iterator = m_addMembers->begin(), end = m_addMembers->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            addMembers_array.add(next);
                            
                        }
                        reqJson.set("addMembers", addMembers_array);
                        

                        // Optional Handler Close
                        }
                        // Optional Handler Open
                        if( !m_removeMembers.isNull() ){

                        
                        // Handle multiple
                        Poco::JSON::Array removeMembers_array;
                        for (std::list<std::string>::const_iterator iterator = m_removeMembers->begin(), end = m_removeMembers->end(); iterator != end; ++iterator) {
                            std::string next = *iterator;
                            
                            // Multiple Simple
                            removeMembers_array.add(next);
                            
                        }
                        reqJson.set("removeMembers", removeMembers_array);
                        

                        // Optional Handler Close
                        }

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_PUT, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        
            namespace Delete{
                // Mber::groups::Group::Delete
                Response::~Response(){};
                class ResponseError : public Response{
                    public:
                    virtual ~ResponseError(){};
                    ResponseError(const Status& someStatus, const std::string& someError){
                      status = someStatus;
                      errorMessage = someError;
                    }
                };
                class ResponseImpl : public Response{
                    public:
                    virtual ~ResponseImpl(){};
                    ResponseImpl(Object::Ptr obj){
                        errorResult = 0;
                        
                        Var next;
                        // bool empty = false;
                        
                        next = obj->get("status");
                        if( !next.isEmpty() ){
                            status = jsonToStatus(next);
                        }
                        
                        next = obj->get("errorResult");
                        if( !next.isEmpty() ){
                            errorResult = Mber::MberPtr<Mber::ErrorResult>(new Mber::ErrorResult);
                            *errorResult = jsonToErrorResult(next);
                        }
                        
                    };
                };
                Request::Request( std::string groupId ){
                    m_groupId = groupId;
                    
                };
                MberPtr<Response> Request::execute( std::string uri, std::string* token, std::string* transactionId, std::string* correlationId ){
                    std::string jsonRsp = "";
                    try {
                        Poco::URI uri_(uri);
                        PocoSessionWrapper session(uri_);
                        if (!session) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, "Unable to create an HTTP session.") );
                        }

                        std::string tmp;
                        std::string mberUrl = "/service/json/groups/Group/";
                        Poco::URI::encode(m_groupId, "!#$&'()*+,/:;=?@[]", tmp); mberUrl.append(tmp); tmp = "";
                        
                        Object reqJson;
                        if( transactionId != 0 ){
                            reqJson.set("transactionId", *transactionId);
                        } else {
                            reqJson.set("transactionId", generateTransactionId());
                        }
                        if( correlationId != 0 ){
                            reqJson.set("correlationId", *correlationId);
                        }
                        if( token != 0 ){
                            reqJson.set("access_token", *token);
                        }

                        
                        // Optional Handler Open
                        

                        
                        // Handle singular
                        // Simple
                        reqJson.set("groupId", m_groupId);
                        
                        

                        // Optional Handler Close
                        

                        std::ostringstream reqJsonStream;
                        reqJson.stringify(reqJsonStream);
                        std::string reqJsonString = reqJsonStream.str();
                        HTTPRequest request(HTTPRequest::HTTP_DELETE, mberUrl);
                        request.set("REST-API-Version", MBER_VERSION);
                        request.setContentLength((int) reqJsonString.length());
                        request.setContentType("application/json");
                        session->sendRequest(request) << reqJsonString;
                        
                        HTTPResponse response;
                        std::istream& rs = session->receiveResponse(response);
                        std::ostringstream ostr;
                        StreamCopier::copyStream(rs, ostr);
                        jsonRsp = ostr.str();
                        Parser jsonParser;
                        ParseHandler handler;
                        jsonParser.setHandler(&handler);
                        jsonParser.parse(jsonRsp);
                        Object::Ptr rspJson = handler.asVar().extract<Object::Ptr>();

                        if (!rspJson.isNull() && !rspJson->has("status")) {
                            return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                        }

                        return MberPtr<Response>( new ResponseImpl(rspJson) );
                    }
                    catch (const JSONException&) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, jsonRsp) );
                    }
                    catch (const Poco::Exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.displayText()) );
                    }
                    catch (const std::exception& e) {
                        return MberPtr<Response>( new ResponseError(Status_Failed, e.what()) );
                    }
                };
            };
        };
    };

};